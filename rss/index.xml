<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Andree's Musings]]></title><description><![CDATA[Thoughts, stories and wild ideas from the world of Infrastructure Engineering.]]></description><link>http://toonk.io/</link><image><url>http://toonk.io/favicon.png</url><title>Andree&apos;s Musings</title><link>http://toonk.io/</link></image><generator>Ghost 3.34</generator><lastBuildDate>Mon, 23 Nov 2020 17:39:56 GMT</lastBuildDate><atom:link href="http://toonk.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Introducing Mysocket.io]]></title><description><![CDATA[Mysocket is a service that provides users with fast and secure TCP sockets for services that aren’t normally directly reachable from the Internet. Using a simple client, we connect your local services to the Internet.]]></description><link>http://toonk.io/introducing-mysocket-io/</link><guid isPermaLink="false">5fbb2ca251a5ff44fb64d8b7</guid><category><![CDATA[mysocket]]></category><category><![CDATA[anycast]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Mon, 23 Nov 2020 03:40:48 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1519331582073-283f1a211a3e?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<blockquote>In this blog, I’d like to introduce a new project I’m calling Mysocket.io. Before we dive in, a bit of background.</blockquote><img src="https://images.unsplash.com/photo-1519331582073-283f1a211a3e?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Introducing Mysocket.io"><p>Loyal readers know I enjoy building global infrastructure services that need to be able to carry a significant amount of traffic and a large number of requests. Building services like these often require us to solve several challenges. Things to consider include: high availability, scaling, DDoS proofing, monitoring, logging, testing, deployments, user-facing &amp; backend APIs, policy management (user preferences) and distribution, life-cycling, etc. All this while keeping an eye on cost and keeping complexity to a minimum (which really is human, operational cost).</p><p>To experiment with these topics, it’s necessary to have a project to anchor these experiments to. Something I can continuously work on, and while doing so, improve the project as a whole. Now, there are many projects I started over time, but one that I've worked most on recently, and wanted to share with a wider audience, is <a href="https://www.mysocket.io/" rel="noopener"><strong>mysocket.io</strong></a>. A service that provides secure public endpoints for services that are otherwise not publicly reachable.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*43NirbSJ49IN0yPBE5wuAg.png" class="kg-image" alt="Introducing Mysocket.io"></figure><p>A typical example case that <a href="https://mysocket.io" rel="noopener">mysocket.io</a> can help with is a web service running on your laptop, which you’d like to make available to a team member or client. Or ssh access to servers behind NAT or a firewall, like a raspberry pi on your home network or ec2 instances behind NAT.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*yF9ppVXSZcwOz5Rlzh39QQ.png" class="kg-image" alt="Introducing Mysocket.io"><figcaption>make your localhost app available from&nbsp;anywhere</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*E-cZOCwqsH3tOkRjzA-ZJQ.png" class="kg-image" alt="Introducing Mysocket.io"><figcaption>Provide SSH access to your home server behind&nbsp;NAT.</figcaption></figure><h2 id="more-details">More details</h2><p>Alright, a good way to share more details and is to do a quick demo! You can see a brief overview in this video, or even better, try it yourself by simply following the four easy steps below.</p><figure class="kg-card kg-embed-card"><iframe width="459" height="344" src="https://www.youtube.com/embed/lEZX_xCTDlo?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></figure><blockquote>If you’re interested or curious, feel free to give it a spin and let me know what worked or didn’t, or even better, how it can be improved. Getting started will take you just one minute. Just follow these simple steps.</blockquote><pre><code class="language-bash">#Install client, using python's package manager (pip)
pip3 install mysocketctl

#Create account
mysocketctl account create \
    --name "your_name" \
    --email "your_email_address" \
    --password "a_secure_password" \
    --sshkey "$(cat ~/.ssh/id_rsa.pub)"
    
#login
mysocketctl login  \
    --email "your_email_address" \
    --password "a_secure_password" 
    
 
#Launch your first global socket ;)
mysocketctl connect \
    --port 8000 \
    --name "my test service"</code></pre><h2 id="architecture-overview">Architecture overview</h2><p>Ok, so how does it work? The process for requesting a “global socket” starts with an API call. You can do this by directly interfacing with <a href="https://api.mysocket.io/" rel="noopener">the RESTful API</a>, or by using the <a href="https://mysocket.readthedocs.io/en/latest/mysocketctl/mysocket.html" rel="noopener">mysocketctl</a> tool. This returns a global mysocket object, which has a name, port number(s), and some other information.</p><p>Users can now use this socket object to create tunnel objects. These tunnels are then used to connect your local service to the global mysocket.io infrastructure. By stitching these two TCP sessions together, we made your local service globally available.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*L4orGfToNQ3fUgjrZC_3Qw.png" class="kg-image" alt="Introducing Mysocket.io"><figcaption>Creating a Socket, a Tunnel and connecting to mysocket.io</figcaption></figure><p>The diagram below provides a high-level overview of the service data-plane. On the left, we have the origin service. This could be your laptop, your raspberry pi at home, or even a set of containers in a Kubernetes cluster. The origin service can be behind a very strict firewall or even NAT. All it needs is outbound network access. We can then set up a secure encrypted tunnel to any of the mysocket.io servers around the world.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*ePYWcZbw_jzNriOwCThNFQ.png" class="kg-image" alt="Introducing Mysocket.io"><figcaption>Mysocket.io dataplane</figcaption></figure><h2 id="anycast">Anycast</h2><p>The Mysocket.io services use AWS’ global accelerator. With this, I’m making both the tunnel servers and proxy services anycasted. This solves some of the load balancing and high availability challenges. The mysocket tunnel and proxy servers are located in North America, Europe, and Asia.</p><p>Once the tunnel is established, the connection event is signaled to all other nodes in real-time, ensuring that all edge nodes know where the tunnel for the service is.</p><h2 id="documentation">Documentation</h2><p>One of my goals is to make Mysocket super easy to use. One way to do that is to have good documentation. I invite you to check out our readthedocs.io documentation here <a href="https://mysocket.readthedocs.io/en/latest/" rel="noopener">https://mysocket.readthedocs.io/</a></p><p>It’s divided into two sections:</p><ol><li><a href="https://mysocket.readthedocs.io/en/latest/about/about.html" rel="noopener">General information </a>about mysocket.io and some of the concepts.</li><li>Information and user guides for the <a href="https://mysocket.readthedocs.io/en/latest/mysocketctl/mysocket.html" rel="noopener">mysocketctl command-line tool</a>.</li></ol><p>The documentation itself and mysocketctl tool are both <a href="https://github.com/mysocketio" rel="noopener">opensource</a> so feel free to open pull requests or open issues if you have any questions.</p><p>You may have noticed there’s a <a href="https://mysocket.io" rel="noopener">website</a> as well. I wanted to create a quick landing page, so I decided to play with Wix.com. They make it super easy;  I may have gone overboard a bit ;)  All that was clicked together in just one evening, pretty neat.</p><h2 id="more-to-come">More to come</h2><p>There’s a lot more to tell and plenty more geeky details to dive into. More importantly, we can continue to build on this and make it even better (ping me if you have ideas or suggestions)! <br>So stay tuned. That’s the plan for subsequent Blog posts soon, either in this blog or the <a href="https://www.mysocket.io/blog" rel="noopener">mysocket.io blog</a>.</p><p><em>Cheers,</em><br><em> -Andree</em><br></p>]]></content:encoded></item><item><title><![CDATA[AWS and their Billions in IPv4 addresses]]></title><description><![CDATA[<p>Earlier this week, I was doing some work on AWS and wanted to know what IP addresses were being used. Luckily for me, AWS publishes this all here <a href="https://ip-ranges.amazonaws.com/ip-ranges.json" rel="nofollow noopener">https://ip-ranges.amazonaws.com/ip-ranges.json</a>. When you go through this list, you’ll quickly see that AWS has a massive asset</p>]]></description><link>http://toonk.io/aws-and-their-billions-in-ipv4-addresses/</link><guid isPermaLink="false">5f88bf632257c9dcdf92feee</guid><category><![CDATA[aws]]></category><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Tue, 20 Oct 2020 16:01:11 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1572288717056-ea97fb77c71e?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1572288717056-ea97fb77c71e?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="AWS and their Billions in IPv4 addresses"><p>Earlier this week, I was doing some work on AWS and wanted to know what IP addresses were being used. Luckily for me, AWS publishes this all here <a href="https://ip-ranges.amazonaws.com/ip-ranges.json" rel="nofollow noopener">https://ip-ranges.amazonaws.com/ip-ranges.json</a>. When you go through this list, you’ll quickly see that AWS has a massive asset of IPv4 allocations. Just counting quickly I noticed a lot of big prefixes.</p><figure class="kg-card kg-embed-card"><blockquote class="twitter-tweet" data-width="550"><p lang="en" dir="ltr">Ever wondered what all of the AWS network ranges are? You can find them all here:<a href="https://t.co/NBaBF6w0la">https://t.co/NBaBF6w0la</a><br>That&#39;s *a lot* of big prefixes!<br>4x /11, 14x /12, 30x /13, 78x /14, 184x /15, 278x /16</p>&mdash; Andree Toonk, Adelante! (@atoonk) <a href="https://twitter.com/atoonk/status/1316098702260359168?ref_src=twsrc%5Etfw">October 13, 2020</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</figure><p>However, the IPv4 ranges on that list are just the ranges that are in use and allocated today by AWS. Time to dig a bit deeper.</p><h3 id="ipv4-address-acquisitions-by-aws">IPv4 address acquisitions by AWS</h3><p>Over the years, AWS has acquired a lot of IPv4 address space. Most of this happens without gaining too much attention, but there were a few notable acquisitions that I’ll quickly summarize below.</p><h4 id="2017-mit-selling-8-million-ipv4-addresses-to-aws">2017: MIT selling 8 million IPv4 addresses to AWS</h4><p>In 2017 <a href="https://www.internetsociety.org/blog/2017/05/mit-goes-on-ipv4-selling-spree/" rel="noopener">MIT sold half of its 18.0.0.0/8</a> allocation to AWS. This 18.128.0.0/9 range holds about 8 million IPv4 addresses.</p><h4 id="2018-ge-sells-3-0-0-0-8-to-aws">2018: GE sells 3.0.0.0/8 to AWS</h4><p>In 2018 the IPv4 prefix 3.0.0.0/8 was transferred from GE to AWS. With this, AWS became the proud owner of its first /8! That’s sixteen million new IPv4 addresses to feed us hungry AWS customers. <a href="https://news.ycombinator.com/item?id=18407173" rel="nofollow noopener">https://news.ycombinator.com/item?id=18407173</a></p><h4 id="2019-aws-buys-amprnet-44-192-0-0-10">2019: AWS buys AMPRnet 44.192.0.0/10</h4><p>In 2019 AWS bought a /10 from AMPR.org, the Amateur Radio Digital Communications (ARDC). The IPv4 range 44.0.0.0/8 was an allocation made to the Amateur Radio organization in 1981 and known as the AMPRNet. This sell caused a fair bit of discussion, check out the <a href="https://mailman.nanog.org/pipermail/nanog/2019-July/thread.html#102103" rel="noopener">nanog discussion here.</a></p><p>Just this month, it <a href="http://www.southgatearc.org/news/2020/october/sale-of-amateur-radio-amprnet-tcp-ip-addresses.htm" rel="noopener">became public knowledge</a> AWS paid $108 million for this /10. That’s $25.74 per IP address.</p><p>These are just a few examples. Obviously, AWS has way more IP addresses than the three examples I listed here. The IPv4 transfer market is very active. Check out this website to get a sense of all transfers: <a href="https://account.arin.net/public/transfer-log#NRPM-8.3IPv4" rel="noopener">https://account.arin.net/public/transfer-log</a></p><h3 id="all-aws-ipv4-addresses">All AWS IPv4 addresses</h3><p>Armed with the information above it was clear that not all of the AWS owned ranges were in the <a href="https://ip-ranges.amazonaws.com/ip-ranges.json">JSON</a> that AWS published. For example, parts of the 3.0.0.0/8 range are missing. Likely because some of it is reserved for future use.</p><p>I did a bit of digging and tried to figure out how many IPv4 addresses AWS really owns. A good start is the Json that AWS publishes. I then combined that with all the ARIN, APNIC, and RIPE entries for Amazon I could find. A few examples include:<br><br><a href="https://rdap.arin.net/registry/entity/AMAZON-4" rel="nofollow noopener">https://rdap.arin.net/registry/entity/AMAZON-4</a><br><a href="https://rdap.arin.net/registry/entity/AMAZO-4" rel="nofollow noopener">https://rdap.arin.net/registry/entity/AMAZO-4</a><br><a href="https://rdap.arin.net/registry/entity/AT-88-Z" rel="nofollow noopener">https://rdap.arin.net/registry/entity/AT-88-Z</a></p><p>Combining all those IPv4 prefixes, removing duplicates and overlaps by aggregating them results in the following list of unique IPv4 address owned by AWS: <a href="https://gist.github.com/atoonk/b749305012ae5b86bacba9b01160df9f#all-prefixes" rel="nofollow noopener">https://gist.github.com/atoonk/b749305012ae5b86bacba9b01160df9f#all-prefixes</a></p><p>The total number of IPv4 addresses in that list is just over 100 Million (100,750,168). That’s <strong>the equivalent of just over six /8’s,</strong> not bad!</p><p>If we break this down by allocation size, we see the following:</p><pre><code>1x /8     =&gt; 16,777,216 IPv4 addresses
1x /9     =&gt; 8,388,608 IPv4 addresses
4x /10    =&gt; 16,777,216 IPv4 addresses
5x /11    =&gt; 10,485,760 IPv4 addresses
11x /12   =&gt; 11,534,336 IPv4 addresses
13x /13   =&gt; 6,815,744 IPv4 addresses
34x /14   =&gt; 8,912,896 IPv4 addresses
53x /15   =&gt; 6,946,816 IPv4 addresses
182x /16  =&gt; 11,927,552 IPv4 addresses
&lt;and more&gt;</code></pre><p>A complete breakdown can be found here: <a href="https://gist.github.com/atoonk/b749305012ae5b86bacba9b01160df9f#breakdown-by-ipv4-prefix-size" rel="nofollow noopener">https://gist.github.com/atoonk/b749305012ae5b86bacba9b01160df9f#breakdown-by-ipv4-prefix-size</a></p><h3 id="putting-a-valuation-on-aws-ipv4-assets">Putting a valuation on AWS’ IPv4 assets</h3><blockquote>Alright.. this is just for fun…</blockquote><p>Since AWS is (one of) the largest buyers of IPv4 addresses, they have spent a significant amount on stacking up their IPv4 resources. It’s impossible, as an outsider, to know how much AWS paid for each deal. However, we can for fun, try to put a dollar number on AWS’ current IPv4 assets.</p><p>The average price for IPv4 addresses has gone up over the years. From ~$10 per IP a few years back to ~$25 per IP <a href="https://auctions.ipv4.global/" rel="noopener">nowadays</a>. <br>Note that these are market prices, so if AWS would suddenly decide to sell its IPv4 addresses and overwhelm the market with supply, prices would drop. But that won’t happen since we’re all still addicted to IPv4 ;)</p><p>Anyway, let’s stick with $25 and do the math just for fun.</p><pre><code>100,750,168 ipv4 addresses x $25 per IP = $2,518,754,200</code></pre><p>Just<strong> over $2.5 billion worth of IPv4 addresses,</strong> not bad! </p><h3 id="peeking-into-the-future">Peeking into the future</h3><p>It’s clear AWS is working hard behind the scenes to make sure we can all continue to build more on AWS. One final question we could look at is: <em>how much buffer does AWS have?</em> ie. how healthy is their IPv4 reserve?</p><p>According to their <a href="https://ip-ranges.amazonaws.com/ip-ranges.json" rel="noopener">published data</a>, they have allocated roughly 53 Million IPv4 addresses to existing AWS services. We found that all their IPv4 addresses combined equates to approximately 100 Million IPv4 addresses. That means they still have ~47 Million IPv4 addresses, or 47% available for future allocations. That’s pretty healthy! And on top of that, I’m sure they’ll continue to source more IPv4 addresses. The IPv4 market is still hot!</p><p></p>]]></content:encoded></item><item><title><![CDATA[100G networking in AWS, a network performance deep dive]]></title><description><![CDATA[<h3></h3><p>Loyal readers of my blog will have noticed a theme, I’m interested in the continued move to virtualized network functions, and the need for faster networking options on cloud compute. In this blog, we’ll look at the network performance on the juggernaut of cloud computing, AWS.</p><p>AWS is</p>]]></description><link>http://toonk.io/aws-network-performance-deep-dive/</link><guid isPermaLink="false">5f889c6f2257c9dcdf92feb0</guid><category><![CDATA[aws]]></category><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Thu, 15 Oct 2020 19:06:42 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1571864156103-d3c37503b6af?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<h3></h3><img src="https://images.unsplash.com/photo-1571864156103-d3c37503b6af?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="100G networking in AWS, a network performance deep dive"><p>Loyal readers of my blog will have noticed a theme, I’m interested in the continued move to virtualized network functions, and the need for faster networking options on cloud compute. In this blog, we’ll look at the network performance on the juggernaut of cloud computing, AWS.</p><p>AWS is the leader in the cloud computing world, and many companies now run parts of their services on AWS. The question we’ll try to answer in this article is: how well suited is AWS’ ec2 for high throughput network functions.</p><p><em>I’ve decided to experiment with adding a short demo video to this blog. Below you will find a quick demo and summary of this article. Since these videos are new and a bit of an experiment, let me know if you like it.</em></p><figure class="kg-card kg-embed-card"><iframe width="612" height="344" src="https://www.youtube.com/embed/iwe0gL8VBvA?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></figure><h3 id="100g-networking">100G networking</h3><p>It’s already been two years since AWS <a href="https://aws.amazon.com/about-aws/whats-new/2018/11/introducing-amazon-ec2-c5n-instances/" rel="noopener">announced the C5n instances</a>, featuring 100 Gbps networking. I’m not aware of any other cloud provider offering 100G instances, so this is pretty unique. Ever since this was released I wondered exactly what, if any, the constraints were. Can I send/receive 100g line rate (144Mpps)? So, before we dig into the details, let’s just check if we can really get to 100Gbs.</p><figure class="kg-card kg-embed-card kg-card-hascaption"><blockquote class="twitter-tweet" data-width="550"><p lang="en" dir="ltr">this is fun :)  97Gbs <a href="https://t.co/6VdkR2Rlr4">pic.twitter.com/6VdkR2Rlr4</a></p>&mdash; Andree Toonk, Adelante! (@atoonk) <a href="https://twitter.com/atoonk/status/1266037590492241921?ref_src=twsrc%5Etfw">May 28, 2020</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<figcaption>100gbs testing.. We’re gonna need a bigger boat..</figcaption></figure><p>There you have it, I was able to get to 100Gbs between 2 instances! That’s exciting. But there are a few caveats. We’ll dig into all of them in this article, with the aim to understand exactly what’s possible, what the various limits are, and how to get to 100g.</p><h3 id="understand-the-limits">Understand the limits</h3><p>Network performance on Linux is typically a function of a few parameters. Most notably, the number of TX/RX queues available on the NIC (network card). The number of CPU cores, ideally at least equal to the number of queues. The pps (packets per second) limit per queue. And finally, in virtual environments like AWS and GCP, potential admin limits on the instance.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1200/0*JUjZ5NOIWUrey-Xm" class="kg-image" alt="100G networking in AWS, a network performance deep dive"></figure><p>Doing networking in software means that processing a packet (or a batch of them) uses a number of CPU cycles. It’s typically not relevant how many bytes are in a packet. As a result, the best metric to look at is the: pps number (related to our cpu cycle budget). Unfortunately, the pps performance numbers for AWS aren’t published so, we’ll have to measure them in this blog. With that, we should have a much better understanding of the network possibilities on AWS, and hopefully, this saves someone else a lot of time (this took me several days of measuring) ;)</p><h3 id="network-queues-per-instance-type">Network queues per instance type</h3><p>The table below shows the number of NIC queues by ec2 (c5n) Instance type.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*P9_cWmValN63fmRXAWqdqg.png" class="kg-image" alt="100G networking in AWS, a network performance deep dive"></figure><p><em>In the world of ec2, 16 vCPUs on the C5n 4xl instance means 1 Socket, 8 Cores per socket, 2 Threads per core.</em></p><p>On AWS, an Elastic Network Adapter (ENA) NIC has as many queues as you have vCPUs. Though it stops at 32 queues, as you can see with the C5n 9l and C5n 18xl instance.</p><p>Like many things in computing, to make things faster, things are parallelized. We see this clearly when looking at CPU capacity, we’re adding more cores, and programs are written in such a way that can leverage the many cores in parallel (multi-threaded programs).</p><p>Scaling Networking performance on our servers is done largely the same. It’s hard to make things significantly faster, but it is easier to add more ‘workers’, especially if the performance is impacted by our CPU capacity. In the world of NICs, these ‘workers’ are queues. Traffic send and received by a host is load-balanced over the available network queues on the NIC. This load balancing is done by hashing (typically the 5 tuples, protocol, source + destination address, and port number). Something you’re likely familiar with from ECMP.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1200/1*VsV_F3dbhosQXAi9A97mqQ.jpeg" class="kg-image" alt="100G networking in AWS, a network performance deep dive"></figure><blockquote>So queues on a NIC are like lanes on a highway, the more lanes, the more cars can travel the highway. The more queues, the more packets (flows) can be processed.</blockquote><h3 id="test-one-ena-queue-performance">Test one, ENA queue performance</h3><p>As discussed, the network performance of an instance is a function of the number of available queues and cpu’s. So let’s start with measuring the maximum performance of a single flow (queue) and then scale up and measure the pps performance.</p><p>In this measurement, I used two c5n.18xlarge ec2 instances in the same subnet and the same placement zone. The sender is using <a href="https://toonk.io/building-a-high-performance-linux-based-traffic-generator-with-dpdk/index.html" rel="noopener">DPDK-pktgen</a> (igb_uio). The receiver is a stock ubuntu 20.04 LTS instance, using the ena driver.</p><p>The table below shows the TX and RX performance between the two c5n.18xlarge ec2 instances for one and two flows.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*GVmlTopDSacvRFilauWZag.png" class="kg-image" alt="100G networking in AWS, a network performance deep dive"></figure><p>With this, it seems the per queue limit is about 1Mpps. Typically the per queue limit is due to the fact that a single queue (soft IRQ) is served by a single CPU core. Meaning, the per queue performance is limited by how many packets per second a single CPU core can process. So again, what you typically see in virtualized environments is that the number of network queues goes up with the number of cores in the VM. In ec2 this is the same, though it’s maxing out at 32 queues.</p><h3 id="test-two-rx-only-pps-performance">Test two, RX only pps performance</h3><p>Now that we determined that the per queue limit appears to be roughly one million packets per second, it’s natural to presume that this number scales up horizontally with the number of cores and queues. For example, the C5n 18xl comes with 32 nic queues and 72 cores, so in theory, we could naively presume that the (RX/TX) performance (given enough flows) should be 32Mpps. Let’s go ahead and validate that.</p><p>The graph below shows the Transmit (TX) performance as measured on a c5n.18xlarge. In each measurement, I gave the packet generator one more queue and vcpu to work with. Starting with one TX queue and one VCPu, incrementing this by one in each measurement until we reached 32 vCPU and 32 queues (max). The results show that the per TX queue performance varied between 1Mpps to 700Kpps. The maximum total TX performance I was able to get however, was ~8.5Mpps using 12 TX queues. After that, adding more queues and vCPu’s didn’t matter, or actually degraded the performance. So this indicates that the performance scales horizontally (per queue), but does max out at a certain point (varies per instance type), in this case at 8.5 Mpps</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/0*7ATryTmrHyn_Inaj" class="kg-image" alt="100G networking in AWS, a network performance deep dive"><figcaption>c5n.18xlarge per TX queue performance</figcaption></figure><p>In this next measurement, we’ll use two packet generators and one receiver. I’m using two generators, just to make sure the limit we observed earlier isn’t caused by limitations on the packet generator. Each traffic generator is sending many thousands of flows, making sure we leverage all the available queues.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*S8jlTc-v-Krm8BLx1QCGtw.png" class="kg-image" alt="100G networking in AWS, a network performance deep dive"><figcaption>RX pps per C5N instance&nbsp;type</figcaption></figure><p>Alright, after a few minutes of reading (and many, many hours, well really days.. of measurements on my end), we now have a pretty decent idea of the performance numbers. We know how many queues each of the various c5n instance types have.</p><blockquote><strong>We have seen that the per queue limit is roughly 1Mpps. And with the table above, we now see how many packets per second each instance is able to receive (RX)</strong>.</blockquote><h3 id="forwarding-performance">Forwarding performance</h3><p>If we want to use ec2 for virtual network functions, then just receiving traffic isn’t enough. A typical router or firewall should both receive and send traffic at the same time. So let’s take a look at that.</p><p>For this measurement, I used the following setup. Both the traffic generator and receiver were C5n-18xl instances. The Device Under Test (DUT) was a standard Ubuntu 20.04 LTS instance using the ena driver. Since the earlier observed pps numbers weren’t too high, I determined it’s safe to use the regular Linux kernel to forward packets.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*rK_4B6M-0NF2mrrDmheuFQ.png" class="kg-image" alt="100G networking in AWS, a network performance deep dive"><figcaption>test setup</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*UUWrmoLH-MXLMsNBdCvJXg.png" class="kg-image" alt="100G networking in AWS, a network performance deep dive"><figcaption>pps forwarding performance</figcaption></figure><p>The key takeaway from this measurement is that the TX and RX numbers are similar as we’d seen before for the instance types up to (including) the C5n 4xl. For example, earlier we saw the C5n 4xl could receive up to ~3Mpps. This measurement shows that it can do ~3Mpps simultaneously on RX and TX.</p><p>However, if we look at the C5n 9l, we can see it was able to process RX+ TX about 6.2Mpps. Interestingly, earlier we saw it was also able to receive (rx only) ~6Mpps. So it looks like we hit some kind of aggregate limit. We observed a similar limit for the C5n 18xl instance.</p><h3 id="in-summary-">In Summary.</h3><p>In this blog, we looked at the various performance characteristics of networking on ec2. We determined that the <strong>performance of a single queue is roughly 1Mpps</strong>. We then saw how the number of queues goes up with the higher end instances up until <strong>32 queues maximum</strong>.</p><p>We then measure the RX performance of the various instances as well as the forwarding (RX + TX aggregate) performance. Depending on the measurement setup (RX, or TX+RX) we see that <strong>for the largest instance types, the pps performance maxes out at roughly 6.6Mpps to 8.3Mpps</strong>. With that, I think that the C5n 9l hits the sweet spot in terms of cost vs performance.</p><h3 id="so-how-about-that-100g-test">So how about that 100G test?</h3><p>Ah yes! So far, we talked about pps only. How does that translate that to gigabits per second?<br>Let’s look at the quick table below that shows how the pps number translates to Gbs at various packet sizes.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*sXL3CJJ9M955aa8DvRUVyw.png" class="kg-image" alt="100G networking in AWS, a network performance deep dive"></figure><p>These are a few examples to get to 10G at various packet sizes. This shows that in order to support line-rate 10G at the smallest packet size, the system will need to be able to do ~14.88 Mpps. The 366 byte packet size is roughly the equivalent average of what you’ll see with an IMIX test, for which the systems needs to be able to process ~3,4Mpps to get to 10G line rate.</p><p>If we look at the same table but then for 100gbps, we see that at the smallest packet size, an instance would need to be able to process is over 148Mpps. But using 9k jumbo frames, you only need 1.39Mpps.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*WbChAl1uTuUMnP6oHFzRhg.png" class="kg-image" alt="100G networking in AWS, a network performance deep dive"></figure><p>And so, that’s what you need to do to get to 100G networking in ec2. Use Jumbo frames (supported in ec2, in fact, for the larger instances, this was the default). With that and a few parallel flows you’ll be able to get to 100G “easily”!</p><h3 id="a-few-more-limits">A few more limits</h3><p>One more limitation I <a href="https://cloudonaut.io/ec2-network-performance-cheat-sheet/" rel="noopener">read about while researching</a>, but didn’t look into myself. It appears that some of the instances have time-based limits on the performance. This <a href="https://www.bluematador.com/blog/ec2-packets-per-second-guaranteed-throughput-vs-best-effort" rel="noopener">blog</a> calls it Guaranteed vs. Best Effort. Basically, you’re allowed to burst for a while, but after a certain amount of time, you’ll get throttled. Finally, there is a per-flow limit of 10Gbs. So if you’re doing things like IPSEC, GRE, VXLAN, etc, note that you will never go any faster than 10g.</p><h3 id="closing-thoughts">Closing thoughts</h3><p>Throughout this blog, I mentioned the word ‘limits’ quite a bit, which has a bit of a negative connotation. However, it’s important to keep in mind that AWS is a multi-tenant environment, and it’s their job to make sure the user experience is still as much as possible as if the instance is dedicated to you. So you can also think of them as ‘guarantees’. AWS will not call them that, but in my experience, the throughput tests have been pretty reproducible with, say a +/- 10% measurement margin.</p><p>All in all, it’s pretty cool to be able to do 100G on AWS. As long as you are aware of the various limitations, which unfortunately aren’t well documented. Hopefully, this article helps some of you with that in the future. <br>Finally, could you use AWS to run your virtual firewalls, proxies, VPN gateways, etc? Sure, as long as you’re aware of the performance constraints. And with that design a horizontally scalable design, according to AWS best practices. The one thing you really do need to keep an eye on is the (egress) bandwidth pricing, which, when you started doing many gigabits per second, can add up.</p><p><em>Cheers</em><br><em>- Andree</em></p><p><br></p>]]></content:encoded></item><item><title><![CDATA[Building a global anycast service in under a minute]]></title><description><![CDATA[<p>This weekend I decided to take another look at Stackpath and their workload edge compute features. This is a relatively new feature, in fact, <a href="https://medium.com/@atoonk/experimenting-with-stackpath-edge-computing-and-anycast-f335ba86e60d?source=friends_link&amp;sk=ab2c1ae803a9f3ed314624f4545edde4" rel="noopener">I wrote about it in Feb 2109 when it was just released</a>. I remember being quite enthusiastic about the potential but also observed some things that</p>]]></description><link>http://toonk.io/building-a-global-anycast-service-in-under-a-minute/</link><guid isPermaLink="false">5f531ce73680d46e73ec5fdf</guid><category><![CDATA[terraform]]></category><category><![CDATA[anycast]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Sun, 21 Jun 2020 05:15:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1527685216219-c7bee79b0089?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1527685216219-c7bee79b0089?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Building a global anycast service in under a minute"><p>This weekend I decided to take another look at Stackpath and their workload edge compute features. This is a relatively new feature, in fact, <a href="https://medium.com/@atoonk/experimenting-with-stackpath-edge-computing-and-anycast-f335ba86e60d?source=friends_link&amp;sk=ab2c1ae803a9f3ed314624f4545edde4" rel="noopener">I wrote about it in Feb 2109 when it was just released</a>. I remember being quite enthusiastic about the potential but also observed some things that were lacking back then. Now, one and a half years later, it seems most of those have been resolved, so let’s take a look!</p><blockquote><em><em>I’ve decided to experiment with adding a small demo video to these blogs.</em></em><br><em><em>Below you will find a quick 5min demo of the whole setup. Since these videos are new and a bit of an experiment, let me know if you like it.</em></em></blockquote><figure class="kg-card kg-embed-card kg-card-hascaption"><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FoP3_wearfo0%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DoP3_wearfo0&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FoP3_wearfo0%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" allowfullscreen frameborder="0" height="480" width="640" title="Building a global anycast service in under a minute" class="s t u kq ai" scrolling="auto" style="box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 510px;"></iframe><figcaption>Demo: Building a global anycast service in under a minute</figcaption></figure><h1 id="workloads">Workloads</h1><p>Stackpath support two types of workloads (in addition to serverless), VM and container-based deployments. Both can be orchestrated using API’s and Terraform. Terraform is an “Infrastructure as code” tool. You simply specify your intent with Terraform, apply it, and you’re good to go. I’m a big fan of Terraform, so we’ll use that for our test.</p><p>One of the cool things about Stackpath is that they have built-in support for Anycast, for both their VM and Container service. I’m going to use that feature and the Container service to build this highly available, low latency web service. It’s super easy, see for your self <a href="https://github.com/atoonk/stackpath-anycast-terraform" rel="noopener nofollow">on my github here</a>.</p><h1 id="docker-setup">Docker setup</h1><p>Since I’m going to use the container service, we need to create a Docker container to work with. This is my <a href="https://github.com/atoonk/stackpath-anycast-terraform/blob/master/container/Dockerfile" rel="noopener nofollow">Dockerfile</a></p><!--kg-card-begin: markdown--><pre><code>FROM python:3
WORKDIR /usr/src/app
COPY ./mywebserver.py .
EXPOSE 8000
ENV PYTHONUNBUFFERED 1
CMD [ “python”, “./mywebserver.py” ]</code></pre>
<!--kg-card-end: markdown--><p>The <a href="https://github.com/atoonk/stackpath-anycast-terraform/blob/master/container/mywebserver.py" rel="noopener nofollow"><em><em>mywebserver.py</em></em></a> program is a simple web service that prints the hostname environment variable. This will help us determine which node is servicing our request when we start our testing.</p><p>After I built the container, I uploaded it to my <a href="https://hub.docker.com/repository/docker/atoonk/pythonweb" rel="noopener nofollow">Dockerhub</a> repo, so that Stackpath can pull it from there.</p><h1 id="terraform">Terraform</h1><p>Now it’s time to define our infrastructure using terraform. The relevant code can be found on my <a href="https://github.com/atoonk/stackpath-anycast-terraform/blob/master/container/main.tf" rel="noopener nofollow">github here</a>. I’ll highlight a few parts:</p><p>On line 17 we start with defining a new workload, and I’m requesting an Anycast IP for this workload. This means that Stackpath will load balance (ECMP) between all nodes in my workload (which I’m defining later).</p><!--kg-card-begin: markdown--><pre><code>resource “stackpath_compute_workload” “my-anycast-workload” {   
    name = “my-anycast-workload”
    slug = “my-anycast-workload”   
    annotations = {       
        # request an anycast IP       
        “anycast.platform.stackpath.net” = “true”   
    }
</code></pre>
<!--kg-card-end: markdown--><p>On line 31, we define the type of workload, in this case, a container. As part of that we’re opening the correct ports, in my case port 8000 for the python service.</p><!--kg-card-begin: markdown--><pre><code>container {   
    # Name that should be given to the container   
    name = “app”   
    port {      
        name = “web”      
        port = 8000      
        protocol = “TCP”      
        enable_implicit_network_policy = true   
    }
</code></pre>
<!--kg-card-end: markdown--><p>Next up we define the container we’d like to deploy (from Dockerhub)</p><!--kg-card-begin: markdown--><pre><code># image to use for the container
image = “atoonk/pythonweb:latest”
</code></pre>
<!--kg-card-end: markdown--><p>In the resources section we define the container specifications. In my case I’m going with a small spec, of one CPU core and 2G of ram.</p><!--kg-card-begin: markdown--><pre><code>resources {
   requests = {
      “cpu” = “1”
      “memory” = “2Gi”
   }
}
</code></pre>
<!--kg-card-end: markdown--><p>We now get to the section where we define how many containers we’d like per datacenter and in what datacenters we’d like this service to run.</p><p>In the example below, we’re deploying three containers in each datacenter, with the possibility to grow to four as part of auto-scaling. We’re deploying this in both Seattle and Dallas.</p><!--kg-card-begin: markdown--><pre><code>target {
    name         = &quot;global&quot;
    min_replicas = 3
    max_replicas = 4
    scale_settings {
      metrics {
        metric = &quot;cpu&quot;
        # Scale up when CPU averages 50%.
        average_utilization = 50
      }
    }
    # Deploy these instances to Dallas and Seattle
    deployment_scope = &quot;cityCode&quot;
    selector {
      key      = &quot;cityCode&quot;
      operator = &quot;in&quot;
      values   = [
        &quot;DFW&quot;, &quot;SEA&quot;
      ]
    }
  }
</code></pre>
<!--kg-card-end: markdown--><h1 id="time-to-bring-up-the-service-">Time to bring up the service.</h1><p>Now that we’ve defined our intent with terrraform, it’s time to bring this up. The proper way to do this is:</p><!--kg-card-begin: markdown--><pre><code>terraform init
terraform plan
terraform apply</code></pre>
<!--kg-card-end: markdown--><blockquote><em><em>After that, you’ll see the containers come up, and our anycasted python service will become available. Since the containers come up rather quickly, you should have all six containers in the two datacenters up and running in under a minute.</em></em></blockquote><h1 id="testing-the-load-balancing-">Testing the load balancing.</h1><p>I’ve deployed the service in both Seattle and Dallas, and since I am based in Vancouver Canada, I expect to hit the Seattle datacenter as that is the closest datacenter for me.</p><!--kg-card-begin: markdown--><pre><code class="language-bash">$ for i in `seq 1 10`; do curl 185.85.196.41:8000 ; done

my-anycast-workload-global-sea-2
my-anycast-workload-global-sea-0
my-anycast-workload-global-sea-2
my-anycast-workload-global-sea-0
my-anycast-workload-global-sea-1
my-anycast-workload-global-sea-1
my-anycast-workload-global-sea-2
my-anycast-workload-global-sea-1
my-anycast-workload-global-sea-2
my-anycast-workload-global-sea-0</code></pre>
<!--kg-card-end: markdown--><p>The results above show that I am indeed hitting the Seattle datacenter, and that my requests are being load balanced over the three instances in Seattle, all as expected.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://toonk.io/content/images/2020/09/image.png" class="kg-image" alt="Building a global anycast service in under a minute" srcset="http://toonk.io/content/images/size/w600/2020/09/image.png 600w, http://toonk.io/content/images/size/w1000/2020/09/image.png 1000w, http://toonk.io/content/images/2020/09/image.png 1400w" sizes="(min-width: 720px) 720px"><figcaption>In the portal, I can see the per container logs as well</figcaption></figure><h1 id="in-summary">In Summary</h1><p>Compared to <a href="https://medium.com/@atoonk/experimenting-with-stackpath-edge-computing-and-anycast-f335ba86e60d?source=friends_link&amp;sk=ab2c1ae803a9f3ed314624f4545edde4" rel="noopener">my test last year </a>with Stackpath, there has been a nice amount of progress. It’s great to now be able to do all of this with just a Terraform file. It’s kind of exciting you can bring up a fully anycast service in under a minute with only one command! By changing the replicate number in the Terraform file we can also easily grow and shrink our deployment if needed.<br>In this article we looked at the container service only, but the same is possible with Virtual machines, my github repo has an example for that as well.</p><p><em><em>Finally, don’t forget to check the </em></em><a href="https://youtu.be/oP3_wearfo0" rel="noopener nofollow"><em><em>demo recording </em></em></a><em><em>and let me know if you’d like to see more video content.</em></em></p>]]></content:encoded></item><item><title><![CDATA[Building an XDP (eXpress Data Path) based BGP peering router]]></title><description><![CDATA[<p>Over the last few years, we’ve seen an increase in projects and initiatives to speed up networking in Linux. Because the Linux kernel is slow when it comes to forwarding packets, folks have been looking at userland or kernel bypass networking. In the last few blog posts, we’ve</p>]]></description><link>http://toonk.io/building-an-xdp-express-data-path-based-bgp-peering-router/</link><guid isPermaLink="false">5f53ccd83680d46e73ec6039</guid><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Sun, 19 Apr 2020 00:00:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1555496710-2660a86c4557?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1555496710-2660a86c4557?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Building an XDP (eXpress Data Path) based BGP peering router"><p>Over the last few years, we’ve seen an increase in projects and initiatives to speed up networking in Linux. Because the Linux kernel is slow when it comes to forwarding packets, folks have been looking at userland or kernel bypass networking. In the last few blog posts, we’ve looked at examples of this, mostly leveraging DPDK to speed up networking. The trend here is, let’s just take networking away from the kernel and process them in userland. Great for speed, not so great for all the Kernel network stack features that now have to be re-implemented in userland.</p><p>The Linux Kernel community has recently come up with an alternative to userland networking, called XDP, Express data path, it tries to strike a balance between the benefits of the kernel and faster packet processing. In this article, we’ll take a look at what it would take to build a Linux router using XDP. We will go over what XDP is, how to build an XDP packet forwarder combined with a BGP router, and of course, look at the performance.</p><h1 id="xdp-express-data-path-">XDP (eXpress Data Path)</h1><p>XDP (eXpress Data Path) is an eBPF based high-performance data path merged in the Linux kernel since version 4.8. Yes, BPF, the same Berkeley packet filter as you’re likely familiar with from tcpdump filters, though that’s now referred to as Classic BPF. Enhanced BPF has gained a lot of popularity over the last few years within the Linux community. BPF allows you to connect to Linux kernel hook points, each time the kernel reaches one of those hook points, it can execute an eBPF program. I’ve heard some people describe eBPF as what Java script was for the web, an easy way to enhance the ’web’, or in this case, the kernel. With BPF you can execute code without having to write kernel modules. XDP, as part of the BPF family, operates early on in the Kernel network code. The idea behind XDP is to add an early hook in the RX path of the kernel and let a user-supplied eBPF program decide the fate of the packet. The hook is placed in the NIC driver just after the interrupt processing and before any memory allocation needed by the network stack itself. So all this happens before an SKB (the most fundamental data structure in the Linux networking code) is allocated. Practically this means this is executed before things like tc and iptables.</p><p>A BPF program is a small virtual machine, perhaps not the typical virtual machines you’re familiar with, but a tiny (RISC register machine) isolated environment. Since it’s running in conjunction with the kernel, there are some protective measures that limit how much code can be executed and what it can do. For example, it can not contain loops (only bounded loops), there are a limited number of eBPF instructions and helper functions. The maximum instruction limit per program is restricted to 4096 BPF instructions, which, by design, means that any program will terminate quickly. For kernel newer than 5.1, this limit was lifted to 1 million BPF instructions.</p><h1 id="when-and-where-is-the-xdp-code-executed">When and Where is the XDP code executed</h1><p>XDP programs can be attached to three different points. The fastest is to have it run on the NIC itself, for that you need a smartnic and is called offload mode. To the best of my knowledge, this is currently only supported on Netronome cards. The next attachment opportunity is essentially in the driver before the kernel allocates an SKB. This is called “native” mode and means you need your driver to support this, luckily <a href="https://github.com/xdp-project/xdp-project/blob/master/areas/drivers/README.org" rel="noopener nofollow">most popular drivers do nowadays</a>.</p><p>Finally, there is SKB or Generic Mode XDP, where the XDP hook is called from <em><em>netif _ receive _ skb()</em></em>, this is after the packet DMA and skb allocation are completed, as a result, you lose most of the performance benefits.</p><p>Assuming you don’t have a smartnic, the best place to run your XDP program is in native mode as you’ll really benefit from the performance gain.</p><h1 id="xdp-actions">XDP actions</h1><p>Now that we know that XDP code is an eBPF C program, and we understand where it can run, now let’s take a look at what you can do with it. Once the program is called, it receives the packet context and from that point on you can read the content, update some counters, potentially modify the packet, and then the program needs to terminate with one of 5 XDP actions:</p><p><strong><strong>XDP_DROP</strong></strong><br>This does exactly what you think it does; it drops the packet and is often used for XDP based firewalls and DDOS mitigation scenarios.<br><strong><strong>XDP_ABORTED</strong></strong><br>Similar to DROP, but indicates something went wrong when processing. This action is not something a functional program should ever use as a return code.<br><strong><strong>XDP_PASS</strong></strong><br>This will release the packet and send it up to the kernel network stack for regular processing. This could be the original packet or a modified version of it.<br><strong><strong>XDP_TX</strong></strong><br>This action results in bouncing the received packet back out the same NIC it arrived on. This is usually combined with modifying the packet contents, like for example, rewriting the IP and Mac address, such as for a one-legged load balancer.<br><strong><strong>XDP_REDIRECT</strong></strong><br>The redirect action allows a BPF program to redirect the packet somewhere else, either a different CPU or different NIC. We’ll use this function later to build our router. It is also used to implement AF_XDP, a new socket family that solves the highspeed packet acquisition problem often faced by virtual network functions. AF_XDP is, for example, used by IDS’ and now also supported by Open vSwitch.</p><h1 id="building-an-xdp-based-high-performant-router">Building an XDP based high performant router</h1><p>Alright, now that we have a better idea of what XDP is and some of its capabilities, let’s start building! My goal is to build an XDP program that forwards packets at line-rate between two 10G NICs. I also want the program to use the regular Linux routing table. This means I can add static routes using the “ip route” command, but it also means I could use an opensource BGP daemon such as Bird or FRR.</p><p>We’ll jump straight to the code. I’m using the excellent XDP tutorial code to get started.<a href="https://github.com/atoonk/xdp-tutorial/blob/master/packet-solutions/xdp_prog_kern_03.c#L225-L320" rel="noopener nofollow"> I forked it here</a>, but it’s mostly the same code as the original. This is an example called “xdp_router” and uses the <em><em>bpf_fib_lookup()</em></em> function to determine the egress interface for a given packet using the Linux routing table. The program then uses the action <em><em>bpf_redirect_map()</em></em> to send it out to the correct egress interface. <a href="https://github.com/atoonk/xdp-tutorial/blob/master/packet-solutions/xdp_prog_kern_03.c#L225-L335" rel="noopener nofollow">You can see code here</a>. It’s only a hundred lines of code to do all the work.</p><p>After we compile the code (just run make in the parent directory), we load the code using the <em><em>./xdp_loader</em></em> program included in the repo and use the .<em><em>/xdp_prog_user</em></em> program to populate and query the redirect_params maps.</p><pre><code>#pin BPF resources (redirect map) to a persistent filesystem
mount -t bpf bpf /sys/fs/bpf/

# attach xdp_router code to eno2
./xdp_loader -d eno2 -F — progsec xdp_router

# attach xdp_router code to eno4
./xdp_loader -d eno4 -F — progsec xdp_router

# populate redirect_params maps
./xdp_prog_user -d eno2
./xdp_prog_user -d eno4</code></pre><h1 id="test-setup">Test setup</h1><p>So far, so good, we’ve built an XDP based packet forwarder! For each packet that comes in on either network interface eno2 or eno4 it does a route lookup and redirects it to the correct egres interface, all in eBPF code. All in a hundred lines of code, Pretty awesome, right?! Now let’s measure the performance to see if it’s worth it. Below is the test setup.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://toonk.io/content/images/2020/09/image-1.png" class="kg-image" alt="Building an XDP (eXpress Data Path) based BGP peering router" srcset="http://toonk.io/content/images/size/w600/2020/09/image-1.png 600w, http://toonk.io/content/images/size/w1000/2020/09/image-1.png 1000w, http://toonk.io/content/images/2020/09/image-1.png 1400w" sizes="(min-width: 720px) 720px"><figcaption>test setup</figcaption></figure><p>I’m using <a href="https://medium.com/@atoonk/building-a-high-performance-linux-based-traffic-generator-with-dpdk-93bb9904416c?source=friends_link&amp;sk=fb002771094f1f79654ec9a8be5761c7" rel="noopener">the same traffic generator as before </a>to generate 14Mpps at 64Bytes for each 10G link. Below are the results:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://toonk.io/content/images/2020/09/image-2.png" class="kg-image" alt="Building an XDP (eXpress Data Path) based BGP peering router" srcset="http://toonk.io/content/images/size/w600/2020/09/image-2.png 600w, http://toonk.io/content/images/size/w1000/2020/09/image-2.png 1000w, http://toonk.io/content/images/2020/09/image-2.png 1400w" sizes="(min-width: 720px) 720px"><figcaption>XDP forwarding Test results</figcaption></figure><p>The results are amazing! A single flow in one direction can go as high as 4.6 Mpps, using one core. Earlier, we saw the Linux kernel can go as high as 1.4Mpps for one flow using one core.</p><p>14Mpps in one direction between the two NICs require four cores. Our earlier blog showed that the regular kernel would need 16 cores to do this work!</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="http://toonk.io/content/images/2020/09/image-3.png" class="kg-image" alt="Building an XDP (eXpress Data Path) based BGP peering router" srcset="http://toonk.io/content/images/size/w600/2020/09/image-3.png 600w, http://toonk.io/content/images/size/w1000/2020/09/image-3.png 1000w, http://toonk.io/content/images/2020/09/image-3.png 1600w" sizes="(min-width: 1200px) 1200px"><figcaption>Test result — XDP forwarding using XDP_REDIRECT, 5 cores to forward 29Mpps</figcaption></figure><p>Finally, for the bidirectional 10,000 flow test, forwarding 28Mpps, we need five cores. All tests are significantly faster than forwarding packets using the regular kernel and all that with minor changes to the system.</p><h2 id="just-so-you-know">Just so you know</h2><p>Since all packet forwarding happens in XDP, packets redirected by XDP won’t be visible to IPtables or even tcpdump. Everything happens before packets even reach that layer, and since we’re redirecting the packet, it never moves up higher the stack. So if you need features like ACLs or NAT, you will have to implement that in XDP (take a look at <a href="https://cilium.io/" rel="noopener nofollow">https://cilium.io/</a>).</p><p></p><!--kg-card-begin: markdown--><p><strong>A word on measuring cpu usage.</strong><br>
To control and measure the number of CPU cores used by XDP, I’m changing the number of queues the NIC can use. I increase the number of queues on my XL710 Intel NIC incrementally until I get a packet loss-free transfer between the two ports on the traffic generator. For example, to get 14Mpps in one direction from port 0 to 1 on the traffic generator through our XDP router, which was forwarding between eno2 and eno4, I used the following settings:</p>
<pre><code>ethtool -L eno2 combined 4
ethtool -L eno4 combined 4</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>For the 28Mpps testing, I used the following</p>
<pre><code>ethtool -L eno2 combined 4
ethtool -L eno4 combined 4</code></pre>
<!--kg-card-end: markdown--><blockquote><em><em><strong>A word of caution</strong></em></em><br><em><em>Interestingly, increasing the number of queues, and thus using more cores, appears to, in some cases, have a negative impact on the efficiency. Ie. I’ve seen scenarios when using 30 queues, where the unidirectional 14mps test with 10,000 flows appear to use almost no CPU (between 1 and 2) while the same test bidirectionally uses up all 30 cores. When restarting this test, I see some inconsistent behavior in terms of CPU usage, so not sure what’s going on, I will need to spend a bit more time on this later.</em></em></blockquote><h1 id="xdp-as-a-peering-router"><strong>XDP as a peering router</strong></h1><p>The tests above show promising results, but one major difference between a simple forwarding test and a real life peering router is the number of routes in the forwarding table. So the questions we need to answer was how the <em><em>bpf_fib_lookup</em></em> function will perform when there are more than just a few routes in the routing table. More concretely, <strong><strong><em><em>could you use Linux with XDP as a full route peering router?</em></em></strong></strong><br>To answer this question, I installed <a href="https://bird.network.cz/" rel="noopener nofollow">bird</a> as a bgp daemon on the XDP router. Bird has a peering session with an <a href="https://github.com/Exa-Networks/exabgp" rel="noopener nofollow">exabgp</a> instance, which I loaded with a full routing table using <a href="https://github.com/t2mune/mrtparse/blob/master/examples/mrt2exabgp.py" rel="noopener nofollow">mrt2exabgp.py</a> and a MRT files from <a href="https://www.ripe.net/analyse/internet-measurements/routing-information-service-ris/ris-raw-data" rel="noopener nofollow">RIPE RIS</a>.<br>Just to be a <em><em>real</em></em> peering router, I also filtered out the RPKI invalid routes using <a href="https://github.com/job/rtrsub" rel="noopener nofollow">rtrsub</a>. The end result is a full routing table with about 800k routes in the Linux FIB.</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="http://toonk.io/content/images/2020/09/image-4.png" class="kg-image" alt="Building an XDP (eXpress Data Path) based BGP peering router" srcset="http://toonk.io/content/images/size/w600/2020/09/image-4.png 600w, http://toonk.io/content/images/size/w1000/2020/09/image-4.png 1000w, http://toonk.io/content/images/size/w1600/2020/09/image-4.png 1600w, http://toonk.io/content/images/2020/09/image-4.png 2000w" sizes="(min-width: 1200px) 1200px"><figcaption>Test result — XDP router with a ful routing table. 5 cores to forward 28Mpps</figcaption></figure><blockquote>After re-running the performance tests with 800k bgp routes in the FIB, I observed <strong><em>no noticeable decrease in performance</em></strong>.</blockquote><blockquote>This indicates that a larger FIB table has no measurable impact on the XDP helper <em>bpf_fib_lookup</em>(). This is exciting news for those interested in a cheap and fast peering router.</blockquote><h2 id="conclusion-and-closing-thoughts-">Conclusion and closing thoughts.</h2><p>We started the article with a quick introduction to eBPF and XDP. We learned that XDP is a subset of the recent eBPF developments focused specifically on the hooks in the network stack. We went over the different XDP actions and introduced the redirect action, which, together with the bpf_fib_lookup helper allows us to build the XDP router.</p><p>When looking at the performance, we see this we can speed up <a href="https://medium.com/@atoonk/linux-kernel-and-measuring-network-throughput-547c3b68c4d2?source=friends_link&amp;sk=b8a74c58f8b7a0d998a8796410b3fb96">packet forwarding in Linux</a> by roughly five times in terms of CPU efficiency compared to regular kernel forwarding. We observed we needed about five cores to forward 28Mpps bidirectional between two 10G NICs.</p><p>When we compare these results with the results from my last blog,<a href="https://medium.com/swlh/kernel-bypass-networking-with-fd-io-and-vpp-fc3a53a669f9?source=friends_link&amp;sk=ab92fa42f7ffdfb6dca39ae9601f3d3e"> DPDK and VPP</a>, we see that XDP is slightly slower, ie. 3 cores (vpp) vs 5 cores (XDP) for the 28Mpps test. However, the nice part about working with XDP was that I was able to leverage the Linux routing table out of the box, which is a major advantage.</p><p>The exciting part is that this setup integrates natively with Netlink, which allowed us to use Bird, or really any other routing daemon, to populate the FIB. We also saw that the impact of 800K routes in the fib had no measurable impact on the performance.</p><blockquote>The fib_lookup helper function allowed us to build a router and leverage well-known userland routing daemons. I would love to also see a similar helper function for conntrack, or perhaps some other integration with Netfilter. It would make building firewalls and perhaps even NAT a lot easier. Punting the first packet to the kernel, and subsequent packets are handled by XDP.</blockquote><blockquote>Wrapping up, we started with the question can we build a high performant peering router using XDP? The answer is yes! You can build a high performant peering router using just Linux and relying on XDP to accelerate the dataplane. While leveraging the various open-source routing daemons to run your routing protocols. That’s exciting!</blockquote><blockquote>Cheers<br> -Andree</blockquote>]]></content:encoded></item><item><title><![CDATA[Kernel bypass networking with FD.io and VPP.]]></title><description><![CDATA[In this blog, we’ll look at VPP, a fast, flexible, and open-source network forwarding plane. I think you will be blown away by the performance numbers.]]></description><link>http://toonk.io/kernel-bypass-networking-with-fd-io-and-vpp/</link><guid isPermaLink="false">5f53d4c53680d46e73ec6097</guid><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Sun, 05 Apr 2020 18:14:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1514900417871-7912cae3d726?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1514900417871-7912cae3d726?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Kernel bypass networking with FD.io and VPP."><p></p><p>Over the last few years, I have experimented with various flavors of userland, kernel-bypass networking. In this article, we’ll take <a href="https://fd.io/" rel="noopener">FD.IO</a> for a spin.</p><p>We will compare the result with the results of my <a href="https://medium.com/@atoonk/linux-kernel-and-measuring-network-throughput-547c3b68c4d2?source=friends_link&amp;sk=b8a74c58f8b7a0d998a8796410b3fb96">last blog</a> in which we looked at how much a vanilla Linux kernel could do in terms of forwarding (routing) packets. We observed that on Linux, to achieve 14Mpps we needed roughly 16 and 26 cores for a unidirectional and bidirectional test. In this article, we’ll look at what we need to accomplish this with FD.io</p><h3 id="userland-networking">Userland networking</h3><p>The principle of Userland networking is that the networking stack is no longer handled by the kernel, but instead by a userland program. The Linux kernel is incredibly feature-rich, but for fast networking, it also requires a lot of cores to deal with all the (soft) interrupts. Several of the userland networking projects rely on DPDK to achieve incredible numbers. One reason why DPDK is so fast is that it doesn’t rely on Interrupts. Instead, it’s a poll mode driver. Meaning it’s continuously spinning at 100% picking up packets from the NIC. A typical server nowadays comes with quite a few CPU cores, and dedicating one or more cores for picking packets of the NIC is, in some cases, entirely worth it. Especially if the server needs to process lots of network traffic.</p><p>So DPDK provides us with the ability to efficiently and extremely fast, send and receive packets. But that’s also it! Since you’re not using the kernel, we now need a program that takes the packets from DPDK and does something with it. Like for example, a virtual switch or router.</p><h3 id="fd-io">FD.IO</h3><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1200/1*xnuX9v2emwe179_6PGIp7g.png" class="kg-image" alt="Kernel bypass networking with FD.io and VPP."></figure><p><a href="https://fd.io/" rel="noopener">FD.IO</a> is an open-source software dataplane developed by Cisco. At the heart of FD.io is something called Vector Packet Processing (VPP).</p><p>The VPP platform is an <a href="https://fd.io/vppproject/vpptech/" rel="noopener">extensible framework </a>that provides switching and routing functionality. VPP is built on a ‘packet processing graph.’ This modular approach means that anyone can ‘plugin’ new graph nodes. This makes extensibility rather simple, and it means that plugins can be customized for specific purposes.</p><p>FD.io can use DPDK as the drivers for the NIC and can then process the packets at a high performant rate that can run on commodity CPU. It’s important to remember that it is not a fully-featured router, ie. it doesn’t really have a control plane; instead, it’s a forwarding engine. Think of it as a router line-card, with the NIC and the DPDK drivers as the ports. VPP allows us to take a packet from one NIC to another, transform it if needed, do table lookups, and send it out again. There are API’s that allow you to manipulate the forwarding tables. Or you can use the CLI to, for example, configure static routes, VLAN, vrf’s etc.</p><h3 id="test-setup">Test setup</h3><p>I’ll use mostly the same test setup as in my previous test. Again using two<a href="https://www.packet.com/cloud/servers/n2-xlarge/" rel="noopener"> n2.xlarge.x86</a> servers from<a href="https://www.packet.com/" rel="noopener"> packet.com</a> and our <a href="https://medium.com/@atoonk/building-a-high-performance-linux-based-traffic-generator-with-dpdk-93bb9904416c?source=friends_link&amp;sk=fb002771094f1f79654ec9a8be5761c7">DPDK traffic generator</a>. The set up is as below.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*bPwcK3XnekCTdwU3HVgeeQ.png" class="kg-image" alt="Kernel bypass networking with FD.io and VPP."><figcaption>Test setup</figcaption></figure><p>I’m using the VPP code from the FD.io master branch and installed it on a vanilla Ubuntu 18.04 system <a href="https://fd.io/docs/vpp/master/gettingstarted/installing/ubuntu.html" rel="noopener">following these steps</a>.</p><h3 id="test-results-packet-forwarding-using-vpp">Test results — Packet forwarding using VPP</h3><p>Now that we have our test setup ready to go, it’s time to start our testing!<br>To start, I configured VPP with “vppctl” like this, note that I need to set static ARP entries since the packet generator doesn’t respond to ARP.</p><p>set int ip address TenGigabitEthernet19/0/1 10.10.10.2/24<br>set int ip address TenGigabitEthernet19/0/3 10.10.11.2/24<br>set int state TenGigabitEthernet19/0/1 up<br>set int state TenGigabitEthernet19/0/3 up<br>set ip neighbor TenGigabitEthernet19/0/1 10.10.10.3 e4:43:4b:2e:b1:d1<br>set ip neighbor TenGigabitEthernet19/0/3 10.10.11.3 e4:43:4b:2e:b1:d3</p><p>That’s it! Pretty simple right?</p><p>Ok, time to look at the results just like before we did a single flow test, both unidirectional and bidirectional, as well as a 10,000 flow test.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*SOuQiKUviuPLjlOlAlAP8Q.png" class="kg-image" alt="Kernel bypass networking with FD.io and VPP."><figcaption>VPP forwarding test&nbsp;results</figcaption></figure><p>Those are some remarkable numbers! With a single flow, VPP can process and forward about 8Mpps, not bad. The perhaps more realistic test with 10,000 flows, shows us that it can handle 14Mpps with just two cores. To get to a full bi-directional scenario where both NICs are sending and receiving at line rate (28 Mpps per NIC) we need three cores and three receive queues on the NIC. To achieve this last scenario with Linux, we needed approximately 26 cores. Not bad, not bad at all!</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/2400/1*CnHwc00tX2BSnE5c424zuA.png" class="kg-image" alt="Kernel bypass networking with FD.io and VPP."><figcaption>Traffic generator on the left, VPP server on the right. This shows the full line-rate bidirectional test: 14Mpps per NIC, while VPP uses 3&nbsp;cores.</figcaption></figure><h3 id="test-results-nat-using-vpp">Test results — NAT using VPP</h3><p>In my previous blog we saw that when doing SNAT on Linux with iptables, we got as high as 3Mpps per direction needing about 29 CPUs per direction. This showed us that packet rewriting is significantly more expensive than just forwarding. Let’s take a look at how VPP does nat.</p><p>To enable nat on VPP, I used the following commands:</p><pre><code>nat44 add interface address TenGigabitEthernet19/0/3
nat addr-port-assignment-alg default
set interface nat44 in TenGigabitEthernet19/0/1 out TenGigabitEthernet19/0/3 output-feature</code></pre><p>My first test is with one flow only in one direction. With that, I’m able to get 4.3Mpps. That’s’ exactly half of what we saw in the performance test without nat. It’s no surprise this is slower due to the additional work needed. Note that with Linux iptables I was seeing about 1.1Mpps.</p><p>A single flow for nat isn’t super representative of a real-life nat example where you’d be translating many sources. So for the next measurements, I’m using 255 different source IP addresses and 255 destination IP addresses as well as different port numbers; with this setup, the nat code is seeing about 16k sessions. I can now see the numbers go to 3.2Mpps; more flows mean more nat work. Interestingly, this number is exactly the same as I saw with iptables. There is however one big difference, with iptables the system was using about 29 cores. In this test, I’m only using two cores. That’s a low number of workers, and also the reason I’m capped. To remove that cap, I added more cores and validated that the VPP code scales horizontally. Eventually, I need 12 cores to run 14Mpps for a stable experience.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*Rrh8rnpAB-SMMqdpe5pG5w.png" class="kg-image" alt="Kernel bypass networking with FD.io and VPP."><figcaption>VPP forwarding with NAT test&nbsp;results</figcaption></figure><p>Below is the relevant VPP config to control the number of cores used by VPP. Also, I should note that I <a href="https://www.linuxtopia.org/online_books/linux_kernel/kernel_configuration/re46.html" rel="noopener">isolated the cores</a> I allocated to VPP so that the kernel wouldn’t schedule anything else on it.</p><pre><code>cpu {
    main-core 1
    # CPU placement:
    corelist-workers 3–14
    # Also added this to grub: isolcpus=3-31,34-63
}
dpdk {
   dev default {
      # RSS, number of queues
      num-rx-queues 12
      num-tx-queues 12
      num-rx-desc 2048
      num-tx-desc 2048
   }
   dev 0000:19:00.1
   dev 0000:19:00.3
}
plugins {
   plugin default { enable }
   plugin dpdk_plugin.so { enable }
}
nat {
   endpoint-dependent
   translation hash buckets 1048576
   translation hash memory 268435456
   user hash buckets 1024
   max translations per user 10000
 }</code></pre><h3 id="conclusion">Conclusion</h3><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1200/0*6AoxbyuX5YbpSjeu" class="kg-image" alt="Kernel bypass networking with FD.io and VPP."><figcaption>Photo by <a href="https://unsplash.com/@nci?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@nci?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener" target="_blank">National Cancer Institute</a> on&nbsp;<a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener" target="_blank">Unsplash</a></figcaption></figure><p>In this blog, we looked at VPP from the FD.io project as a userland forwarding engine. VPP is one example of a kernel bypass method for processing packets. It works closely with and further augments DPDK.</p><p>We’ve seen that the VPP code is <a href="https://wiki.fd.io/view/VPP/What_is_VPP%3F#Feature_Rich" rel="noopener">feature-rich</a>, especially for a kernel bypass packet forwarder. Most of all, <strong>it’s crazy fast</strong>.</p><p>We need just three cores to have two NICs forward full line-rate (14Mpps) in both directions. Comparing that to the Linux kernel, which needed 26 cores, we see an almost 9x increase in performance. <br>We noticed that the results were even better when using nat. In Linux, I wasn’t able to get any higher than 3.2Mpps for which I needed about 29 cores. With VPP we can do 3.2Mpps with just two cores and get to full line rate nat with 12 cores.</p><p>I think <a href="https://fd.io/" rel="noopener">FD.io</a> is an interesting and exciting project, and I’m a bit surprised it’s not more widely used. One of the reasons is likely that there’s a bit of a learning curve. But if you need high-performance packet forwarding, it’s certainly something to explore! Perhaps this is the start of your VPP project? if so, <a href="https://twitter.com/atoonk" rel="noopener">let me know!</a></p><p><em>Cheers</em><br><em> -Andree</em></p>]]></content:encoded></item><item><title><![CDATA[Linux Kernel and Measuring network throughput.]]></title><description><![CDATA[can Linux route at line-rate between two network interfaces? That’s the question we will try to answer in the next few minutes.]]></description><link>http://toonk.io/linux-kernel-and-measuring-network-throughput/</link><guid isPermaLink="false">5f53d62b3680d46e73ec60b5</guid><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Sun, 29 Mar 2020 18:21:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1448056975861-28196f26abd6?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1448056975861-28196f26abd6?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Linux Kernel and Measuring network throughput."><p>In <a href="https://medium.com/@atoonk/building-a-high-performance-linux-based-traffic-generator-with-dpdk-93bb9904416c">my last blog</a>, I wrote about how we can use dpdk pktgen for performance testing. Today I spent some time on some baseline testing to see what we can expect out of a vanilla Linux system nowadays when used as a router. Over the last two years I’ve been playing a fair bit with kernel bypass networking and hope to write about it in the near future. The promise of kernel bypass networking is higher performance, to determine how much of performance increase over the Kernel we need to establish a baseline first, we’ll do that in this article.</p><h3 id="test-setup">Test setup</h3><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1200/1*Z2de1wSgOo9UGYqJL5X2Ag.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>n2.large.x86 CPU&nbsp;specs.</figcaption></figure><p>I’m using two <a href="https://www.packet.com/cloud/servers/n2-xlarge/" rel="noopener">n2.xlarge.x86</a> servers from <a href="https://www.packet.com/" rel="noopener">packet.com</a>. With its two Numa nodes, 16cores per socket, 32 cores in total, 64 with hyper-threading, this is a very beefy machine! It also comes with a quad-port Intel x710 NIC, giving us 4 x 10Gbs. Packet allows you to create custom vlans and assign network ports to a vlan. I’ve created two vlans and assigned one NIC to each vlan. The setup looks like below.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*TvT0rHAopTG6cx8v8Ny9TA.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>Test setup</figcaption></figure><p>The Device Under Test (DUT), is a vanilla Ubuntu 19.04 system running a 5.0.0–38-generic kernel. The only minor tune I’ve done is to set the NIC rx ring to 4096. And I enabled ip forwarding ( net.ipv4.ip_forward=1)</p><p>Using the <a href="https://github.com/atoonk/dpdk_pktgen" rel="noopener">traffic generator</a>, I’m sending as many packets possible and observe when packets stop coming back at the same rate, which indicates packet-loss. I record the point that happens as the maximum throughput. I’m also keeping a close eye on the CPU usage, to get a sense of how many CPU cores (hyper threads) are needed to serve the traffic.</p><h3 id="test-1-packet-forwarding-on-linux">Test 1 — packet forwarding on Linux</h3><p>The first test was easy. I’m simply sending packets from 10.10.11.1 to 10.10.12.1 and vice versa, through the DUT (Device under Test), which is routing the packets between the two interfaces eno2 and eno4.<br>Note that that I did both a one directional test (10.10.11.1 &gt; 10.10.12.1) and a bidirectional test (10.10.11.1 &gt; 10.10.12.1 AND 10.10.12.1 &gt; 10.10.11.1). <br>I also tested with just one flow, and with 10,000 flows.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1200/1*moJCGd0xZ8uN0F_dSJrlBg.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>Receive Side Scaling&nbsp;(RSS)</figcaption></figure><p>This is important as the NIC is doing something called<a href="https://medium.com/@anubhavchoudhary/introduction-to-receive-side-scaling-rss-7cd97307d220"> Receive Side Scaling (RSS)</a>, which will load balance different flows on to different NIC receive Queues. Each queue is then served by a different core, meaning the system scales horizontally. But, keep in mind, you may still be limited by what a single core can do depending on your traffic patterns.</p><p>Ok, show me the results! Keep in mind that we’re talking mostly about Packets Per Second (PPS) as that is the major indicator of the performance, it’s not super relevant how much data is caried in each packet. In the world of Linux networking, it really comes down to, how many interrrupts per second the system can process.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*qs0jj0QIJRCsGeY-Laf8QA.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>Test results for test&nbsp;1</figcaption></figure><p>In the results above, you can see that one flow can go as high as 1.4Mpps. At that point, the core serving that queue is maxed out (running 100%), and can not process any more packets and will start dropping. The single flow forwarding performance is good to know for DDOS use-cases or large single flow network streams such as ESP. For services like these, the performance is as good as a single queue / cpu can handle.</p><p>When doing the same test with 10,000 flows, I get to 14 Mpps, full 10g line rate at the smallest possible packet size (64B), yay! At this point I can see all cores doing a fair amount of work. This is expected and is due to the hashing of flows over different queues. Looking at the CPU usage, I estimate that you’d need roughly 16 cores at 100% usage to serve this amount of packets (interrupts).</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/2400/1*orhgjD2BpWHCVxGdutKCPg.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>14M pps, unidirectional test.</figcaption></figure><p>Interestingly, I wasn’t able to get to full line rate when doing the bidirectional test. Meaning both NICs both sending and receiving simultaneously. Although I am getting reasonably close at 12Mpps (24Mpps total per NIC). When eyeballing the cpu usage and amount of idle left over, I’d expect you’d need roughly 26 cores at 100% usage to do that.</p><h3 id="test-2-introducing-a-simple-stateful-iptables-rule">Test 2 - Introducing a simple stateful iptables rule</h3><p>In this test we’re adding two simple iptables rules to the DUT to see what the impact is. The hypothesis here is that since we’re now going to ask the system to invoke conntrack and do stateful session mapping, we’re starting to execute more code, which could impact the performance and system load. This test will show us the impact of that.</p><p>The Iptables rules added were:</p><pre><code>iptables -I FORWARD -d 10.10.11.1 -m conntrack — ctstate RELATED,ESTABLISHED -j ACCEPT
iptables -I FORWARD -d 10.10.12.1 -m conntrack — ctstate RELATED,ESTABLISHED -j ACCEPT</code></pre><p></p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*2bA807FtoZwr2K3YgSot9Q.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>Test results for test 2, impact of conntrack</figcaption></figure><p>The results for the single flow performance test look exactly the same, that’s good. The results for the 10,000 flows test, look the same as well when it comes to packet per second. However, we do need a fair amount of extra CPU’s to do the work. Good thing, our test system has plenty. <br>So you can still achieve (close) to full line rate with a simple stateful iptables rule, as long as you have enough cpu’s. Note that in this case, the state table had 10,000 state entries. I didn’t test with more iptables rules.</p><h3 id="test-3-introducing-a-nat-rule">Test 3 - Introducing a NAT rule</h3><p>In this test, we’re starting from scratch as we did in test 1 and I’m adding a simple nat rule which causes all packets going through the DUT to be rewritten to a new source IP. These are the two rules:</p><pre><code>iptables -I POSTROUTING -t nat -d 10.10.12.1 -s 10.10.11.1 -j SNAT — to 10.10.12.2iptables -I POSTROUTING -t nat -d 10.10.11.1 -s 10.10.12.1 -j SNAT — to 10.10.11.2</code></pre><p>The results below are quite different than what we saw earlier.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*zGL9WLmMNQUSItaf0cSmXA.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>Test results for test&nbsp;3</figcaption></figure><p>The results show that rewriting the packets is quite a bit more expensive than just allowing or dropping a packet. For example, if we look at the unidirectional test with 10,000 flows, we see that we dropped from 14M pps (test 1) to 3.2 Mpps, we also needed 13 cores more to do this!</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*vqQ8Ag_pkW7g19SRCpuhxQ.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>This is what a (unhappy) 64core system looks like when trying to forward and NAT 5.9M&nbsp;pps</figcaption></figure><p>For what it’s worth, i did do a quick measurement with using nftables instead of iptables, but saw no significant changes in NAT performance.</p><h3 id="conclusion">Conclusion</h3><p>One of the questions I had starting this experiment was: <strong>can Linux route at line-rate between two network interfaces?</strong> The answer is yes, we saw 14Mpps (unidirectional), as long as there are sufficient flows, and you have enough cores (~16). The bidirectional test made it to 12Mpps (24Mpps total per NIC) with 26cores at 100%.</p><p>We also saw that with the addition of two stateful Iptables rules, I was still able to get the same throughput, but needed extra CPU to do the work. So at least it scales horizontally.</p><p>Finally, we saw the rather dramatic drop in performance when adding SNAT rules to test. With SNAT the maximum I was able to get out of the system was 5.9Mpps; this was for 20k sessions (10k per direction).</p><p>So yes, you can build a close to line rate router in Linux, as long as you have sufficient cores and don’t do too much packet manipulations. All in all, an interesting test, and now we have a starting benchmark for future (kernel bypass / userland) networking experiments on Linux!</p>]]></content:encoded></item><item><title><![CDATA[Building a high performance - Linux Based Traffic generator with DPDK]]></title><description><![CDATA[<hr><p>Often in my, now 20 years, networking career, I had to do some form of network performance testing. Use-cases varied, from troubleshooting a customer problem to testing new network hardware, and nowadays more and more Virtual network functions and software-based ‘bumps in the wire’.</p><p>I’ve always enjoyed playing with</p>]]></description><link>http://toonk.io/building-a-high-performance-linux-based-traffic-generator-with-dpdk/</link><guid isPermaLink="false">5f53d8003680d46e73ec60d6</guid><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Wed, 18 Mar 2020 18:32:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1489976908522-aabacf277f49?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<hr><img src="https://images.unsplash.com/photo-1489976908522-aabacf277f49?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Building a high performance - Linux Based Traffic generator with DPDK"><p>Often in my, now 20 years, networking career, I had to do some form of network performance testing. Use-cases varied, from troubleshooting a customer problem to testing new network hardware, and nowadays more and more Virtual network functions and software-based ‘bumps in the wire’.</p><p>I’ve always enjoyed playing with hardware-based traffic generators. My first experience with for example an IXIA hardware testing goes back to I think 2003, at the <a href="https://www.ams-ix.net/ams" rel="noopener">Amsterdam Internet Exchange</a> where we were testing brand new Foundry 10G cards. These hardware-based testers were super powerful and a great tool to validate new gear, such as router line cards, firewalls, and IPsec gear. However, we don’t always have access to these hardware-based traffic generators, as they tend to be quite expensive or only available in a lab. In this blog, we will look at a software-based traffic generator that anyone can use - based on DPDK. As you’re going through this remember that the scripts and additional info can be found on <a href="https://github.com/atoonk/dpdk_pktgen/" rel="noopener">my GitHub page here</a>.</p><hr><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1200/1*L3shetNxtIGOhKt-_0xv5A.png" class="kg-image" alt="Building a high performance - Linux Based Traffic generator with DPDK"></figure><p>DPDK, The Data Plane Development Kit, is an Open source software project started by Intel and now managed by the Linux Foundation. It provides a set of data plane libraries and network interface controller polling-mode drivers that are running in userspace. Ok, let’s think about that for a sec, what does that mean? Userspace networking is something you likely increasingly hear and read about. The main driver behind userspace networking (aka Kernel bypass) has to do with the way Linux has built its networking stack; it is built as part of a generic, multi-purpose, multi-user OS. Networking in Linux is powerful and feature-rich, but it’s just one of the many features of Linux, and so; as a result, the networking stack needs to play fair and share its resources with the rest of the kernel and userland programs. The end result is that getting a few (1 to 3) million packets per second through the Linux networking stack is about what you can do on a standard system. That’s not enough to fill up a 10G link at 64 bytes packets, which is the equivalent of 14M packets per second (pps). This is the point where the traditional interrupt-driven (IRQs) way of networking in Linux starts to limit what is needed, and this is where DPDK comes in. With DPDK and userland networking programs, we take away the NIC from the kernel and give it to a userland DPDK program. The DPDK driver is a pull mode driver (PMD), which means that, typically, one core per nic always uses a 100% CPU, it’s in a busy loop always pulling for packets. This means that you will see that core running at 100%, regardless of how many packets are arriving or being sent on that nic. This is obviously a bit of waste, but nowadays, with plenty of cores and the need for high throughput systems, this is often a great trade-off, and best of all, it allows us to get to the 14M pps number on Linux.</p><p>Ok, high performance, we should all move to DPDK then, right?! Well, there’s just one problem… Since we’re now bypassing the kernel, we don’t get to benefit from the rich Linux features such as Netfilter and not even some of what we now think are basic features like a TCP/IP stack. This means you can’t just run your Nginx, Mysql, Bind, etc, socket-based applications with DPDK as all of these rely on the Linux Socket API and the Kernel to work. So although DPDK gives us a lot of speed and performance by bypassing the kernel, you also lose a lot of functionality.</p><p>Now there are quite a few DKDK based applications nowadays, varying from network forwarders such as software-based routers and switches as well as TCP/IP stacks such as F-stack.</p><p>In this blog, we’re going to look at DPDK-pktgen, a DPDK based traffic generator maintained by the DPDK team. I’m going to walk through installing DPDK, setting up SR-IOV, and running pktgen; all of the below was tested on a <a href="https://www.packet.com/" rel="noopener">Packet.com</a> server of type <a href="https://www.packet.com/cloud/servers/x1-small/" rel="noopener">x1.small.x86</a> which has a single Intel X710 10G nic and a 4 core E3–1578L Xeon CPU. I’m using Ubuntu 18.04.4 LTS.</p><h3 id="installing-dpdk-and-pktgen">Installing DPDK and Pktgen</h3><p>First, we need to install the DPKD libraries, tools, and drivers. There are various ways to install DPDK and pktgen; I elected to compile the code from source. There are a few things you need to do; to make it easier, you can download the <a href="https://github.com/atoonk/dpdk_pktgen/blob/master/install-dpdk-pktgen.sh" rel="noopener">same bash script </a>I used to help you with the installation.</p><h3 id="solving-the-single-nic-problem">Solving the single NIC problem</h3><p>One of the challenges with DPDK is that it will take full control of the nic. To use DPDK, you will need to release the nic from the kernel and give it to DPDK. Given we only have one nic, once we give it to DKDK, I’d lose all access (remember there’s no easy way to keep on using SSH, etc., since it relies on the Linux kernel). Typically folks solve this by having a management NIC (for Linux) and one or more NICs for DPDK. But I have only one NIC, so we need to be creative: we’re going to use SR-IOV to achieve the same. SR-IOV allows us to make one NIC appear as multiple PCI slots, so in a way, we’re virtualizing the NIC.</p><p>To use SR-IOV, we need to enable iommu in the kernel (done in the DPDK install script). After that, we can set the number of Virtual Functions (the number of new PCI NIC) like this.</p><pre><code class="language-bash">echo 1 &gt; /sys/class/net/eno1/device/sriov_numvfs
ip link set eno1 vf 0 spoofchk off
ip link set eno1 vf 0 trust on</code></pre><p></p><p>dmesg -t will show something like this:</p><pre><code class="language-bash">[Tue Mar 17 19:44:37 2020] i40e 0000:02:00.0: Allocating 1 VFs.
[Tue Mar 17 19:44:37 2020] iommu: Adding device 0000:03:02.0 to group 1
[Tue Mar 17 19:44:38 2020] iavf 0000:03:02.0: Multiqueue Enabled: Queue pair count = 4
[Tue Mar 17 19:44:38 2020] iavf 0000:03:02.0: MAC address: 1a:b5:ea:3e:28:92
[Tue Mar 17 19:44:38 2020] iavf 0000:03:02.0: GRO is enabled
[Tue Mar 17 19:44:39 2020] iavf 0000:03:02.0 em1_0: renamed from eth0</code></pre><p>We can now see the new PCI device and nic name:</p><pre><code class="language-bash">root@ewr1-x1:~# lshw -businfo -class network | grep 000:03:02.0
pci@0000:03:02.0 em1_0 network Illegal Vendor ID</code></pre><p>Next up we will unbind this NIC from the kernel and give it to DPDK to manage:</p><pre><code class="language-bash">/opt/dpdk-20.02/usertools/dpdk-devbind.py -b igb_uio 0000:03:02.0</code></pre><p>We can validate that like this (note em2 is not connected and not used):</p><pre><code class="language-bash">/opt/dpdk-20.02/usertools/dpdk-devbind.py -s
Network devices using DPDK-compatible driver
============================================
0000:03:02.0 'Ethernet Virtual Function 700 Series 154c' drv=igb_uio unused=iavf,vfio-pci,uio_pci_generic
Network devices using kernel driver
===================================
0000:02:00.0 'Ethernet Controller X710 for 10GbE backplane 1581' if=eno1 drv=i40e unused=igb_uio,vfio-pci,uio_pci_generic
0000:02:00.1 'Ethernet Controller X710 for 10GbE backplane 1581' if=em2 drv=i40e unused=igb_uio,vfio-pci,uio_pci_generic</code></pre><h3 id="testing-setup">Testing setup</h3><p>Now that we’re ready to start testing, I should explain our simple test setup. I’m using two x1-small servers; one is the sender (running dpdk-pktgen), the other is a vanilla Ubuntu machine. What we’re going to test is the ability for the receiver Kernel, sometimes referred to as Device Under Test (DUT), to pick up the packets from the NIC. That’s all; we’re not processing anything, the IP address the packets are sent to isn’t even configured on the DUT, so the kernel will drop the packets asap after picking it up from the NIC.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*4dnNk4hTHqehbtjSq7c5kQ.png" class="kg-image" alt="Building a high performance - Linux Based Traffic generator with DPDK"><figcaption>test setup</figcaption></figure><h3 id="single-flow-traffic">Single flow traffic</h3><p>Ok, time to start testing! Let’s run pktgen and generate some packets! My first experiment is to figure out how much I can send in a single flow to the target machine before it starts dropping packets.</p><p>Note that you can find the exact config in the <a href="https://github.com/atoonk/dpdk_pktgen/" rel="noopener">GitHub repo for this blog</a>. The file <a href="https://github.com/atoonk/dpdk_pktgen/blob/master/pktgen.pkt" rel="noopener">pktgen.pkt</a> contains the commands to configure the test setup. Things that I configured were the mac and IP addresses, ports and protocols, and the sending rate. Note that I’m testing from 10.99.204.3 to 10.99.204.8. These are on /31 networks, so I’m setting the destination mac address to that of the default gateway. With the config as defined in <a href="https://github.com/atoonk/dpdk_pktgen/blob/master/pktgen.pkt" rel="noopener">pktgen.pkt</a> I’m sending the same 64 byte packets (5 tuple, UDP 10.99.204.3:1234 &gt; 10.99.204.8:81 ) over and over.</p><p>I’m using the following to start pktgen.</p><pre><code class="language-bash">/opt/pktgen-20.02.0/app/x86_64-native-linuxapp-gcc/pktgen - -T -P -m "2.[0]" -f pktgen.pkt</code></pre><p>After adjusting the sending rate properties on the sender and monitoring with <a href="https://github.com/atoonk/dpdk_pktgen/blob/master/monitorpkts.sh" rel="noopener"><em>./monitorpkts.sh</em></a> on the receiver, we find that a single flow (single queue, single-core) will run clean on this receiver machine up until about 120k pps. If we up the sending rate higher than that, I’m starting to observe packets being dropped on the receiver. That’s a bit lower than expected, and even though it’s one flow, I can see the CPU that is serving that queue having enough idle time left. There must be something else happening…</p><p>The answer has to do with the receive buffer ring on the receiver network card. It was too small for the higher packet rates. After I increased it from 512 to 4096. I can now receive up to 1.4Mpps before seeing drops, not bad for a single flow!</p><pre><code>ethtool -G eno1 rx 4096</code></pre><h3 id="multi-flow-traffic">Multi flow traffic</h3><p>Pktgen also comes with the ability to configure it for ranges. Examples of ranges include source and destination IP addresses as well as source and destination ports. You can find an example in the <a href="https://github.com/atoonk/dpdk_pktgen/blob/master/pktgen-range.pkt" rel="noopener">pktgen-range.pkt file</a>. For most environments, this is a more typical scenario as your server is likely to serve many different flows from many different IP addresses. In fact, the Linux system relies on the existence of many flows to be able to deal with these higher amounts of traffic. The Linux kernel hashes and load-balances these different flows to the available receive queues on the nic. Each queue is then served by a separate Interrupt thread, allowing the kernel to parallelize the work and leverage the multiple cores on the system.</p><p>Below you’ll find a screenshot from when I was running the test with many flows. The receiver terminals can be seen on the left, the sender on the right. The main thing to notice here is that on the receiving node, all available CPU’s are being used, note the <em>ksoftirqd/X</em> processes. Since we are using a wide range of source and destination ports, we’re getting proper load balancing over all cores. With this, I can now achieve 0% lost packets up to about 6Mpps. To get to 14Mpps, 10g line rate @64Bytes packets, I’d need more CPUs.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*H4YbY1b8viqfjoHNi6NPjA.png" class="kg-image" alt="Building a high performance - Linux Based Traffic generator with DPDK"></figure><h3 id="imix-test">IMIX test</h3><p>Finally, we’ll run a basic IMIX test, using the dpdk-pktgen pcap feature. Internet Mix or IMIX refers to typical Internet traffic. When measuring equipment performance using an IMIX of packets, the performance is assumed to resemble what can be seen in “real-world” conditions.</p><p>The <a href="https://github.com/atoonk/dpdk_pktgen/blob/master/imix.pcap" rel="noopener">imix pcap file</a> contains 100 packets with the sizes and ratio according to the <a href="https://en.wikipedia.org/wiki/Internet_Mix" rel="noopener">IMIX specs</a>.</p><pre><code>tshark -r imix.pcap -V | grep 'Frame Length'| sort | uniq -c|sort -n
9 Frame Length: 1514 bytes (12112 bits)
33 Frame Length: 590 bytes (4720 bits)
58 Frame Length: 60 bytes (480 bits)</code></pre><p>I need to rewrite the source and destination IP and MAC addresses so that they match my current setup, this can be done like this:</p><pre><code>tcprewrite \
 - enet-dmac=44:ec:ce:c1:a8:20 \
 - enet-smac=00:52:44:11:22:33 \
 - pnat=16.0.0.0/8:10.10.0.0/16,48.0.0.0/8:10.99.204.8/32 \
 - infile=imix.pcap \
 - outfile=output.pcap</code></pre><blockquote>For more details also see my notes here : <a href="https://github.com/atoonk/dpdk_pktgen/blob/master/DPDKPktgen.md" rel="noopener">https://github.com/atoonk/dpdk_pktgen/blob/master/DPDKPktgen.md</a></blockquote><p>We then start the packetgen app and give it the pcap</p><pre><code>/opt/pktgen-20.02.0/app/x86_64-native-linuxapp-gcc/pktgen - -T -P -m "2.[0]" -s 0:output.pcap</code></pre><p>I can now see I’m sending and receiving packets at a rate of 3.2M pps at 10Gbs, well below the maximum we saw earlier. This means that the Device Under Test (DUT) is capable of receiving packets at 10Gbs using an IMIX traffic pattern.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*xxb0aQmNeSvhvFfOwTI4nw.png" class="kg-image" alt="Building a high performance - Linux Based Traffic generator with DPDK"><figcaption>Result of IMIX test with a PCAP as the source. Receiver (DUT) on the left, sender window on the&nbsp;right.</figcaption></figure><h3 id="conclusion">Conclusion</h3><p>In this article, we looked at getting DPDK up and running, talked a bit about what DPDK is, and used its pktgen traffic generator application. A typical challenge when using DPDK is that you lose the network interface, meaning that the kernel can no longer use it. In this blog, we solved this using SR-IOV, which allowed us to create a second logical interface for DPDK. Using this interface, I was able to generate 14Mpps without issues.</p><p>On the receiving side of this test traffic, we had another Linux machine (no DPDK), and we tested its ability to receive traffic from the NIC (after which the kernel dropped it straight away). We saw how the packets per second number is limited by the rx-buffer, as well as the ability for the CPU cores to pick up the packets (soft interrupts). We saw a single core was able to do about 1,4Mpps. Once we started leveraging more cores, by creating more flows, we started seeing dropped packets at about 6M pps. If we would have had more CPU’s we’d likely be able to do more than that.</p><p>Also note that throughout this blog, I spoke mostly of packets per second and not much in terms of bits per second. The reason for this is that every new packet on the Linux receiver (DUT) creates an interrupt. As a result, the number of interrupts the system can handle is the most critical indicator of how many bits per second the Linux system can handle.</p><p>All in all, pktgen and dpdk require a bit of work to set up, and there is undoubtedly a bit of a learning curve. I hope the scripts and examples in the GitHub repo will help with your testing and remember: with great power comes great responsibility.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*60-YU-v_jMuccCaCqqDw6A.jpeg" class="kg-image" alt="Building a high performance - Linux Based Traffic generator with DPDK"></figure>]]></content:encoded></item><item><title><![CDATA[TCP BBR - Exploring TCP congestion control]]></title><description><![CDATA[<p></p><p>One of the oldest protocols and possibly the most used protocol on the Internet today is TCP. You likely send and receive hundreds of thousands or even over a million TCP packets (eeh segments?) a day. And it just works! Many folks believe TCP development has finished, but that’s</p>]]></description><link>http://toonk.io/tcp-bbr-exploring-tcp-congestion-control/</link><guid isPermaLink="false">5f53dac53680d46e73ec610d</guid><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Sat, 15 Feb 2020 00:00:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1534477357488-36c99519f91d?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1534477357488-36c99519f91d?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="TCP BBR - Exploring TCP congestion control"><p></p><p>One of the oldest protocols and possibly the most used protocol on the Internet today is TCP. You likely send and receive hundreds of thousands or even over a million TCP packets (eeh segments?) a day. And it just works! Many folks believe TCP development has finished, but that’s incorrect. In this blog will take a look at a relatively new TCP congestion control algorithm called BBR and take it for a spin.</p><p>Alright, we all know the difference between the two most popular transport protocols used on the Internet today. We have UDP and TCP. UDP is a send and forget protocol. It is stateless and has no congestion control or reliable delivery support. We often see UDP used for DNS and VPNs. TCP is UDP’s sibling and does provide reliable transfer and flow control, as a result, it is quite a bit more complicated.</p><p>People often think the main difference between TCP and UDP is that TCP gives us guaranteed packet delivery. This is one of the most important features of TCP, but TCP also gives us flow control. Flow control is all about fairness, and critical for the Internet to work, without some form of flow control, the Internet would collapse.</p><p>Over the years, different flow control algorithms have been implemented and used in the various TCP stacks. You may have heard of TCP terms such as Reno, Tahoe, Vegas, Cubic, Westwood, and, more recently, BBR. These are all different congestion control algorithms used in TCP. What these algorithms do is determining how fast the sender should send data while adapting to network changes. Without these algorithms, our Internet pipes would soon be filled with data and collapse.</p><h3 id="bbr">BBR</h3><p>Bottleneck Bandwidth and Round-trip propagation time (BBR) is a TCP congestion control algorithm developed at Google in 2016. Up until recently, the Internet has primarily used loss-based congestion control, relying only on indications of lost packets as the signal to slow down the sending rate. This worked decently well, but the networks have changed. We have much more bandwidth than ever before; The Internet is generally more reliable now, and we see new things such as bufferbloat that impact latency. BBR tackles this with a ground-up rewrite of congestion control, and it uses latency, instead of lost packets as a primary factor to determine the sending rate.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*DwjjUQ3f5Kpv6mtJCASpTw.gif" class="kg-image" alt="TCP BBR - Exploring TCP congestion control"><figcaption><a href="https://cloud.google.com/blog/products/gcp/tcp-bbr-congestion-control-comes-to-gcp-your-internet-just-got-faster" data-href="https://cloud.google.com/blog/products/gcp/tcp-bbr-congestion-control-comes-to-gcp-your-internet-just-got-faster" class="markup--anchor markup--figure-anchor" rel="nofollow noopener noopener" target="_blank">Source: https://cloud.google.com/blog/products/gcp/tcp-bbr-congestion-control-comes-to-gcp-your-internet-just-got-faster</a></figcaption></figure><h3 id="why-is-bbr-better">Why is BBR better?</h3><p>There are a lot of details I’ve omitted, and it gets complicated pretty quickly, but the important thing to know is that with BBR, you can get significantly better throughput and reduced latency. The throughput improvements are especially noticeable on long haul paths such as Transatlantic file transfers, especially when there’s minor packet loss. The improved latency is mostly seen on the last mile path, which is often impacted by Bufferbloat <em>(4 seconds ping times, anyone?</em>). Since BBR attempts not to fill the buffers, it tends to be better in avoiding buffer bloat.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1200/0*oAa5qgaXoDWLx7MZ" class="kg-image" alt="TCP BBR - Exploring TCP congestion control"><figcaption>Photo by <a href="https://unsplash.com/@kaziiparkour?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@kaziiparkour?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener" target="_blank">Zakaria Zayane</a> on&nbsp;<a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener" target="_blank">Unsplash</a></figcaption></figure><h4 id="let-s-take-bbr-for-a-spin-">let’s take BBR for a spin!</h4><p>BBR has been in the Linux kernel since version 4.9 and can be enabled with a simple <em>sysctl</em> command. In my tests, I’m using two Ubuntu machines and Iperf3 to generate TCP traffic. The two servers are located in the same data center; I’m using two <a href="https://www.packet.com/" rel="noopener">Packet.com </a>servers type: <a href="https://www.packet.com/cloud/servers/t1-small/" rel="noopener">t1.small</a>, which come with a 2.5Gbps NIC.</p><p>The first test is a quick test to see what we can get from a single TCP flow between the two servers. This shows 2.35Gb/s, which sounds about right, good enough to run our experiments.</p><p><strong>The effect of latency on TCP throughput</strong><br>In my day job, I deal with machines that are distributed over many dozens of locations all around the world, so I’m mostly interested in the performance between machines that have some latency between them. In this test, we are going to introduce 140ms round trip time between the two servers using Linux Traffic Control (tc). This is roughly the equivalent of the latency between San Francisco and Amsterdam. This can be done by adding 70ms per direction on both servers like this:</p><pre><code class="language-bash">tc qdisc replace dev enp0s20f0 root netem latency 70ms</code></pre><p>If we do a quick ping, we can now see the 140ms round trip time</p><pre><code class="language-bash">root@compute-000:~# ping 147.75.69.253
PING 147.75.69.253 (147.75.69.253) 56(84) bytes of data.
64 bytes from 147.75.69.253: icmp_seq=1 ttl=61 time=140 ms
64 bytes from 147.75.69.253: icmp_seq=2 ttl=61 time=140 ms
64 bytes from 147.75.69.253: icmp_seq=3 ttl=61 time=140 ms</code></pre><p>Ok, time for our first tests, I’m going to use Cubic to start, as that is the most common TCP congestion control algorithm used today.</p><pre><code>sysctl -w net.ipv4.tcp_congestion_control=cubic</code></pre><p>A 30 second iperf shows an average transfer speed of 347Mbs. This is the first clue of the effect of latency on TCP throughput. The only thing that changed from our initial test (2.35Gbs) is the introduction of 140ms round trip delay. Let’s now set the congestion control algorithm to bbr and test again.</p><pre><code>sysctl -w net.ipv4.tcp_congestion_control=bbr</code></pre><p>The result is very similar, the 30seconds average now is 340Mbs, slightly lower than with Cubic. So far no real changes.</p><h3 id="the-effect-of-packet-loss-on-throughput">The effect of packet loss on throughput</h3><p>We’re going to repeat the same test as above, but with the addition of a minor amount of packet loss. With the command below, I’m introducing 1,5% packet loss on the server (sender) side only.</p><pre><code>tc qdisc replace dev enp0s20f0 root netem loss 1.5% latency 70ms</code></pre><p>The first test with Cubic shows a <strong>dramatic</strong> drop in throughput; the throughput drops from 347Mb/s to 1.23 Mbs/s. That’s a ~99.5% drop and results in this link basically being unusable for today’s bandwidth needs.</p><p>If we repeat the exact same test with BBR we see a significant improvement over Cubic. With BBR the throughput drops to 153Mbs, which is a 55% drop.</p><p>The tests above show the effect of packet loss and latency on TCP throughput. The impact of just a minor amount (1,5%) of packet loss on a long latency path is dramatic. Using anything other than BBR on these longer paths will cause significant issues when there is even a minor amount of packet loss. Only BBR maintains a decent throughput number at anything more than 1,5% loss.</p><p>The table below shows the complete set of results for the various TCP throughput tests I did using different congestion control algorithms, latency and packet loss parameters.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*BzXd_1HLSAdRSBQNtPQ_Nw.png" class="kg-image" alt="TCP BBR - Exploring TCP congestion control"><figcaption>Throughput Test results with various congestion control algorithms</figcaption></figure><blockquote>Note: the congestion control algorithm used for a TCP session is only locally relevant. So, two TCP speakers can use different congestion control algorithms on each side of the TCP session. In other words: the server (sender), can enable BBR locally; there is no need for the client to be BBR aware or support BBR.</blockquote><h3 id="tcp-socket-statistics">TCP socket statistics</h3><p>As you’re exploring tuning TCP performance, make sure to use <em>socket statistics</em>, or <em>ss,</em> like below. This tool displays a ton of socket information, including the TCP flow control algorithm used, the round trip time per TCP session as well as the calculated bandwidth and actual delivery rate between the two peers.</p><figure class="kg-card kg-image-card"><img src="http://toonk.io/content/images/2020/09/Screen-Shot-2020-09-05-at-11.41.38-AM.png" class="kg-image" alt="TCP BBR - Exploring TCP congestion control" srcset="http://toonk.io/content/images/size/w600/2020/09/Screen-Shot-2020-09-05-at-11.41.38-AM.png 600w, http://toonk.io/content/images/size/w1000/2020/09/Screen-Shot-2020-09-05-at-11.41.38-AM.png 1000w, http://toonk.io/content/images/2020/09/Screen-Shot-2020-09-05-at-11.41.38-AM.png 1364w" sizes="(min-width: 720px) 720px"></figure><h2 id="when-to-use-bbr">When to use BBR</h2><p>Both Cubic and BBR perform well for these longer latency links when there is no packet loss, and BBR really shines under (moderate) packet loss. Why is that important? You could argue why you would want to design for these packet loss situations. For that, let’s think about a situation where you have multiple data centers around the world, and you rely on transit to connect the various data centers (possibly using your own Overlay VPN). You likely have a steady stream of data between the various data centers, think of logs files, ever-changing configuration or preference files, database synchronization, backups, etc. All major Transit providers at times suffer from packet loss due to various reasons. If you have a few dozen of these globally distributed data centers, depending on your Transit providers and the locations of your POPs you can expect packet loss incidents between a set of data centers several times a week. In situations like this BBR will shine and help you maintain your SLO’s.</p><p>I’ve mostly focused on the benefits of BBR for long haul links. But CDNs and various application hosting environments will also see benefits. In fact, Youtube has been using BBR for a while now to speed up their already highly optimized experience. This is mostly due to the fact that BBR ramps up to the optimal sending rate aggressively, causing your video stream to load even faster.</p><h4 id="downsides-of-bbr">Downsides of BBR</h4><p>It sounds great right, just execute this one <em>sysctl</em> command, and you get much better throughput resulting in your users to get a better experience. Why would you not do this? Well, BBR has <a href="https://huitema.wordpress.com/2019/01/12/will-transport-innovation-collapse-the-internet/" rel="noopener">received some criticism </a>due to its tendency to consume all available bandwidth and pushing out other TCP streams that use say Cubic or different congestion algorithms. This is something to be mindful of when testing BBR in your environment. <a href="https://datatracker.ietf.org/meeting/105/materials/slides-105-iccrg-bbr-v2-a-model-based-congestion-control" rel="noopener">BBRv2</a> is supposed to resolve some of these challenges.</p><p>All in all, I was amazed by the results. It looks to me this is certainly worth taking a closer look at. You won’t be the first, in addition to Google, <a href="https://blogs.dropbox.com/tech/2017/09/optimizing-web-servers-for-high-throughput-and-low-latency/" rel="noopener">Dropbox</a> and <a href="https://labs.spotify.com/2018/08/31/smoother-streaming-with-bbr/" rel="noopener">Spotify</a> are two other examples where BBR is being used or experimented with.</p>]]></content:encoded></item><item><title><![CDATA[Building A Smarter AWS Global Accelerator]]></title><description><![CDATA[In this blog post, we’ll take a look at how we could build our own global accelerator.  I’ve been thinking a lot about Global Accelerator and while it provides a powerful data plane, I think it would benefit from a smarter control plane.]]></description><link>http://toonk.io/building-a-smarter-aws-global-accelerator/</link><guid isPermaLink="false">5f53e04f3680d46e73ec613f</guid><category><![CDATA[aws]]></category><category><![CDATA[anycast]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Sun, 01 Dec 2019 00:00:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1553623095-2b4d2819983f?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1553623095-2b4d2819983f?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Building A Smarter AWS Global Accelerator"><p>In my last blog post, we looked at Global Accelerator, a global load balancer provided by AWS. I think Global Accelerator is an excellent tool for folks building global applications in AWS as it will help them directing traffic to the right origin locations or servers. This is great for high volume applications, as well as providing improved availability.</p><p>In this blog post, we’ll take a look at how we could build our own global accelerator by building on other previous blog posts (<a href="https://medium.com/@atoonk/building-a-high-available-anycast-application-in-5-minutes-on-packet-198c82eaabc">building anycast applications on packet</a>). I’ve been thinking a lot about Global Accelerator and while it provides a powerful data plane, I think it would benefit from a smarter control plane. A control plane that provides load balancing with more intelligence, by taking into account the capacity, load and round trip time to each origin. In this blog post, we’ll evaluate and demonstrate what that could look like by implementing a <em>Smarter Global Accelerator </em>ourselves.</p><h3 id="typical-architecture"><strong>Typical Architecture</strong></h3><p>Many applications nowadays are delivered using the architecture below. Clients always hit one of the nearest edge nodes (the blue diamonds). Which edge node depends on the way traffic is directed to the edge node, typically either using DNS based load balancing, or straight anycast, this is what AWS Global Accelerator uses.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1200/1*YI0T8iXatDz57M-7eHDvZw.png" class="kg-image" alt="Building A Smarter AWS Global Accelerator"><figcaption>Typical application delivery architecture</figcaption></figure><p>The edge node then needs to determine what origin server to send the request to (assuming there is no caching or cache misses). This is how your typical CDN works, but also how for example, Google and Facebook deliver their applications. In the case of a simple CDN there could be one or more origin servers. In the case of Facebook, the choice is more which of their ‘core’ or ‘larger’ datacenters to send the request to.</p><p>With AWS Global Accelerator you can configure listeners (the diamond) in a region to send a certain percentage of traffic to an origin group, ‘Endpoint Groups’ in AWS speak. This is a static configuration, which is not ideal. Additionally, if an origin (the green box in the diagram) reaches its capacity, you will need to update the configuration. This is the part we’re going to make smarter.</p><p>In an ideal world, each edge node (the diamond) routes the requests to the closest origin based on the latency between the edge node and the origin. It should also be aware of the total load the origin is under, and how much load the origin can handle. An individual edge node doesn’t know how many other edge nodes there are, and how much each of them is sending each origin. So we need a centralized brain and a feedback loop.</p><h3 id="building-a-closed-loop-system">Building a Closed-loop system</h3><p>To have the system continuously adapt to the changing environment, we need to have access to several operational metrics. We need to know how many requests each edge node (load balancer) is receiving, with that we can infer the total, global, number of incoming requests per second. We also need to know the capacity of each origin since we want to make sure we don’t send more traffic to an origin than it can handle. Finally, we need to know the health and latency between each edge node and each origin. Most of these metrics are dynamic, so we need to continuously publish (or poll) the health information and request per second information.</p><p>Now that we have all the input data, we can feed this into our software. The software essentially a scheduler, solving a constraint-based assignment problem. The output is a list with all edge nodes and a weight assignment per edge node for each origin. A simple example could look like this:</p><pre><code>-Listener 192.0.2.10:443 
 - Edge node Amsterdam:
    - Origin EU DC:  90%
    - Origin US-WEST DC:  0%
    - Origin US-EAST DC:  10%
    - Origin Asia DC:  0%
 - Edge node New York:
    - Origin EU DC: 0%
    - Origin US-WEST DC:  0%
    - Origin US-EAST DC:  100%
    - Origin Asia DC:  0%</code></pre><p>In the above example for listener <em>192.0.2.10:443</em>, the Amsterdam edge node will send 90% of the requests to the EU origin, while the remaining 10% is directed to the next closest DC, US-EAST. This means this the EU datacenter is at capacity and is offloading traffic to the next closest origin.</p><p>The New York edge node is sending all traffic to the EU-EAST datacenter as there is enough capacity at this point and no need to offload traffic.</p><p>Our closed-loop system will re-calculate and publish the results every few seconds so that we can respond to changes quickly.</p><h3 id="let-s-start-building"><strong>Let’s start building</strong></h3><p>I’m going to re-use much of what we’ve built earlier, in this experiment I’m again using <a href="https://medium.com/@atoonk/building-a-high-available-anycast-application-in-5-minutes-on-packet-198c82eaabc">Packet.net and their BGP anycast support</a> to build the edge nodes. Please see this <a href="https://medium.com/@atoonk/building-a-high-available-anycast-application-in-5-minutes-on-packet-198c82eaabc">blog for details</a>. I’m using Linux LVS as a load balancer for this setup. Each edge node is publishing the needed metrics to <a href="https://prometheus.io/" rel="noopener">prometheus</a>, a time-series database, every 15 seconds. With this, we now have a handful of edge nodes, fully anycasted, and access to all needed metrics per edge node in a centralized system.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1200/1*iXsxBwPZsGxrGXEOVtXiCg.png" class="kg-image" alt="Building A Smarter AWS Global Accelerator"><figcaption>Swagger file, built using Flask-RESTPlus</figcaption></figure><p>The other thing that is needed is a centralized source of truth. For this, I wrote a Flask based REST API. This API allows us to create new load balancers, add origins, etc. We can also ask this same API for all load balancers, its origins and the health and operational metrics.</p><p>The next thing we needed is a script that every few seconds talks to the API to retrieve the latest configuration. With that information, each edge node can update the load balancer configuration, such as create new load balancer listeners and update the origin details such as weight per origin. We now have everything in place and can start testing.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*PbSBDEjF_1mYGVH4snMhTQ.png" class="kg-image" alt="Building A Smarter AWS Global Accelerator"><figcaption>JSON definition for each load&nbsp;balancer</figcaption></figure><h3 id="observations-and-tuning"><strong>Observations and tuning</strong></h3><p>I started testing by generating many get requests to one Listener that has two origins, one <a href="https://www.digitalocean.com/" rel="noopener">digitalocean</a> VM in the US and one in Europe. Since all testing was performed from one location, it was hitting one edge datacenter, that has two edge nodes. Those edge nodes would send the traffic to the closest origin, which is the US origin. Now imagine this origin server was hitting its maximum capacity and I want to protect it from being overloaded and start sending some traffic to the other origin. To do that I set the maximum load number for the US origin to 200 requests per second (also see JSON above).</p><p>Below you’ll see an interesting visualization of this measurement. At t=0 the total traffic load for both origins is 0, no traffic is coming in at all, which also meant that both origins are well below their max capacity. This means that the US load balancers are configured to send all requests to the US origin as they have the lowest latency and are below the max threshold.</p><p>After we generate the traffic, all requests are sent to the US origin to start. As the metrics start coming in the system detects that the total number of incoming requests is exceeding 200, as a result, the load balancer configuration will be updated to start sending traffic to both origin servers, with the intent to not send more than 200 requests per second to the US origin.</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://cdn-images-1.medium.com/max/2400/1*I_rh2VgUAN2w45QQXnpuzg.png" class="kg-image" alt="Building A Smarter AWS Global Accelerator"></figure><h4 id="speed-vs-accuracy-">Speed vs. accuracy.</h4><p>One of the things we want to prevent is big sudden swings in traffic. To achieve that I built in a dampening factor that limits the load shifting (ie. load balancer configuration) change to 2 percent per origin for each 15-second interval. Note; that if you have two origins, this means a 2% change per origin, so 4% swing per 15 secsond cycle. This means it will take a bit longer for the system to respond to major changes but will give us substantially more stability, meaning less oscillation between origins and will allow for the system to stabilize. In my initial version, I had no dampening and the system never stabilized and showed significant unwanted sudden traffic swings.</p><p>The graph shows an interesting side effect of my testing setup. Since I’m testing from the US west coast and start offloading more and more requests to the EU origin, this means that on average, a single curl will take longer due to the increased round trip time. As a result, the total number of requests goes down. Which is fun, because it means the software needs to adapt constantly. Every time we change the origin weights slightly, the total number or requests changes slightly. This causes some oscillation, but it’s also exactly the oscillation a closed-loop system is designed for, and it works well as long as we have a dampening factor. It also shows that in some instances the total number of inbound requests increases if your website (or any app) is responding faster. Though I’m not sure if that’s representative of a real-world scenario. Still, this was a fun side effect that put a bit of extra stress on the software.</p><h3 id="closing-thoughts">Closing thoughts</h3><blockquote>This project was fun as it allowed me to combine several of my interests. One of them is global traffic engineering, ie. how do we get traffic to where we’d like it to be processed. We also go to re-use the lessons learned and experience gained from a few of the previous blog posts, specifically how to build anycasted applications with Packet and a deep-dive into AWS Global Accelerator. I got to improve my Python skills by building a Restful API in Flask and make sure it was properly documented using the OpenAPI spec.</blockquote><blockquote>Finally, building the actual scheduler was a fun challenge, and it took me a while to figure out how to best solve the assignment problem before I was really happy with the outcome. The result is what could be a Smarter Global Accelerator.</blockquote>]]></content:encoded></item><item><title><![CDATA[Building a high available Anycast service using AWS Global Accelerator]]></title><description><![CDATA[In my last two blogs, I wrote about building highly available applications using anycast on Packet and Stackpath. Today we’ll look at how to do this on AWS using its recently released service: Global Accelerator.]]></description><link>http://toonk.io/building-a-high-available-anycast-service-using-aws-global-accelerator/</link><guid isPermaLink="false">5f53e1f33680d46e73ec6157</guid><category><![CDATA[terraform]]></category><category><![CDATA[aws]]></category><category><![CDATA[anycast]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Mon, 02 Sep 2019 00:00:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1544161497-6095fb868d58?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1544161497-6095fb868d58?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Building a high available Anycast service using AWS Global Accelerator"><p>Everything I’m demonstrating below can easily be replicated by using <a href="https://github.com/atoonk/aws_global_accelerator" rel="noopener"><strong>the terraform code </strong>here,</a> with that we will have a global anycast load-balancer, and origin web &amp; dns servers in under 5 minutes.</p><p>Global Accelerator became publicly available in late 2018, and I’ve looked at it various times since then with a few potential use-cases in mind. The main value proposition for users is the ability to get a static IPv4 address that isn’t tied to a region. With global accelerator, customers get two globally anycasted IPv4 addresses that can be used to load balance across 14 unique AWS regions. A user request will get routed to the closest AWS edge POP based on BGP routing. From there, you can load balance requests to the AWS regions where your applications are deployed. Global accelerator comes with traffic dials that allow you to control how much traffic goes to what region, as well as instances in that region. It also has built-in health checking to make sure traffic is only routed to healthy instances.</p><p>Global accelerator comes with a few primitives, let’s briefly review these:</p><ul><li><strong>Global Accelerator</strong>, think of this of your anycast endpoint. It’s a global primitive and comes with two IPv4 addresses.</li><li>Next up, you create a <strong>Listener</strong> which defines what port and protocol (tcp or udp) to listen on. A Global Accelerator can have multiple listeners. We’ll create two for this article later on.</li><li>For each Listener, you then create one or more <strong>Endpoint Groups. </strong>An endpoint group allows you to group endpoint together by region. For example, EU-CENTRAL-1 can be an endpoint group. Each endpoint group has a traffic dial that controls the percentage of traffic you’d like to send to a region.</li><li>Finally, we have an <strong>Endpoint</strong>, this can be either an Elastic IP address, a Network Load Balancer, or an Application Load Balancer. You can have multiple endpoints in an Endpoint group. For each endpoint, you can configure a weight that controls how traffic is load-balanced over the various endpoints within an endpoint group.</li></ul><p>These are some basic yet powerful primitives to help you build a highly available, low latency application with granular traffic control.</p><h3 id="let-s-start-building-">Let’s start building!</h3><p>Alright that sounds cool, let’s dive right in. In this example, we’re going to build a highly available web service and DNS service in four AWS regions, us-east-1, us-west-2, eu-central-1, and ap-southeast-1. Each region will have two ec2 instances with a simple Go web server and a simple DNS server. We’ll create the global accelerator, listeners, endpoint groups, endpoints, as well as all the supporting infrastructure such as VPCs, subnets, security groups all through terraform.</p><p>I’ve published the terraform and other supporting code on my github page: <a href="https://github.com/atoonk/aws_global_accelerator" rel="noopener">https://github.com/atoonk/aws_global_accelerator</a>. This allows you to try it yourself with minimum effort. Time to deploy our infrastructure:</p><pre><code>terraform init &amp;&amp; terraform plan &amp;&amp; terraform apply -auto-approve
…
Plan: 63 to add, 0 to change, 0 to destroy.
...
GlobalAccelerator = [
  [
    [
      {
        "ip_addresses" = [
          "13.248.138.197",
          "76.223.8.146",
        ]
        "ip_family" = "IPv4"
      },
    ],
  ],
]</code></pre><p><br>After a few minutes, all 63 components have been built. Now our globally distributed application is available over two anycast IPv4 addresses, in four regions, with two origin servers per region like the diagram below.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*QzlZImYojTUNWc9EW9zZiw.png" class="kg-image" alt="Building a high available Anycast service using AWS Global Accelerator"></figure><p>In the AWS console, you’ll now see something like this. In my example, you see two listeners, one for the webserver on TCP 80 and one for our DNS test on UDP 53.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*uWIV0IN_qoNgHlvcHhbMzw.png" class="kg-image" alt="Building a high available Anycast service using AWS Global Accelerator"><figcaption>Global Accelerator AWS&nbsp;Console</figcaption></figure><h3 id="time-to-start-testing-">Time to start testing.</h3><p>Now that we have our anycasted global load balancer up and running, it’s time to start testing. First let’s do a quick http check from 4 servers around the world, Tokyo, Amsterdam, New York and Seattle. To check if load balancing works as expected, I’m using to following test:</p><pre><code class="language-bash">for i in {1..100}
	do curl -s -q http://13.248.138.197 
 done | sort -n | uniq -c | sort -rn</code></pre><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*jmpHigFU_rYC75y0B16oSQ.png" class="kg-image" alt="Building a high available Anycast service using AWS Global Accelerator"><figcaption>http load balancing test</figcaption></figure><p>The above shows that the hundred requests from each of the servers indeed go to the region we’d expect it to go and are nicely balanced over the two origin servers in each region.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1200/1*S0U1k8V8wcgRwps66ru_5Q.png" class="kg-image" alt="Building a high available Anycast service using AWS Global Accelerator"></figure><p>Next, we’ll use RIPE Atlas, a globally distributed measurement network to check the traffic distribution globally on a larger scale. This will tell us how well the AWS anycast routing setup works.</p><p>I’m going to use the <a href="https://github.com/atoonk/aws_global_accelerator/blob/master/scripts/nsd.sh" rel="noopener">DNS listener </a>for this. Using RIPE Atlas, I’m asking 500 probes to run the following dig command. The output will tell us what node and region are being used.</p><pre><code class="language-bash">dig @13.248.138.197 id.server txt ch +short
"i-0e32d5b1a3f76cc05.us-west-2c"</code></pre><p>The image below is visualization of the measurement results. It shows four different colors; each color represents one of the four regions. At first glance, there’s certainly a good distribution among the four geographic regions. The odd ones out are the clients in Australia and New Zealand, which AWS is sending to the us-west-2 region instead of the closer and lower latency Singapore, ap-southeast-1 region. I could, of course, solve this myself by creating a listener and origin server in Australia as well. Other than that there very few outliers, so that looks good.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*Ha-IOgGjbOfyESPI_hMqmw.png" class="kg-image" alt="Building a high available Anycast service using AWS Global Accelerator"><figcaption>Global Accelerator Anycast Traffic distribution using RIPE&nbsp;atlas</figcaption></figure><p>Based on this measure from 500 random Ripe Atlas nodes, We can see the region that is getting most of the traffic is the Europe region. In a real-life scenario, this region could now be running hot. To resolve that I’m going to lower the traffic dial for the Europe endpoint group to 50%. This means 50% of the traffic that was previously going to Europe should now go to the next best region. The visualization below shows that the majority of the 50% offload traffic ended up in the us-east region and small portion spilled over into ap-southeast-1 (remember, I’m only deployed in four regions).</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*N-jZ7UcqaiqyFotN6Trl1Q.png" class="kg-image" alt="Building a high available Anycast service using AWS Global Accelerator"><figcaption>50% of the EU traffic offloaded to alternative regions</figcaption></figure><h3 id="routing-and-session-termination">Routing and session termination</h3><p>An interesting difference between Global Accelerator and regular public ec2 IP addresses is how traffic is routed to AWS. For Global Accelerator AWS will try and get traffic on its own network as soon as possible. As compared to the scenario with regular AWS public IP addresses; Amazon only announces those prefixes out of the region where the IP addresses are used. That means that for Global Accelerator IP addresses your traffic is handed off to AWS at its closest Global Accelerator POP and then uses the AWS backbone to get to the origin. For regular AWS public IP addresses, AWS relies on public transit and peering to get the traffic to the region it needs to get to.</p><p>Let’s look at a traceroute to illustrate this. One of my origin servers in the ap-southeast-1 regions is 13.251.41.53, a traceroute to that ec2 instance in Singapore from a non AWS server in Sydney looks like this:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*b8Dpylb2iOclIZgFlsxoxw.png" class="kg-image" alt="Building a high available Anycast service using AWS Global Accelerator"><figcaption>Traceroute from Sydney to an origin Server in Singapore, ap-southeast-1</figcaption></figure><p>In this case, we hand off traffic to NTT in Sydney, which sends it to Japan and then to Singapore, where it’s handed off to AWS, it eventually took 180ms to get there. It’s important to observe that traffic was handed of to AWS in Singapore, near the end of the traceroute.</p><p>Now, as a comparison, we’ll look at a traceroute from the same server in Sydney to the anycasted Global Accelerator IP</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*LhwltVZSHTsjKmTdT5QSOQ.png" class="kg-image" alt="Building a high available Anycast service using AWS Global Accelerator"><figcaption>Traceroute from Sydney to anycasted Global Accelerator IP</figcaption></figure><p>The Global Accelerator address on hop 4 is just under a millisecond away. In this case, AWS is announcing the prefix locally via the Internet Exchange and it is handed off to AWS on the second hop. Quite a latency difference.</p><p>Keep in mind, although you certainly get better “ping” times to your service’s IP address, the actual response time of the application will still be dependent on where the application is deployed. It’s interesting to note though, that based on the above, AWS does appear to terminate the network connection at all of its Global Accelerator sites even if your application is not deployed there. This is also visible in the logs of our webserver, this is where we observe that the source IP address of the client isn’t the actual client’s IP, instead it’s an IP address of AWS’ Global Accelerator service. Not being able to see the original client IP address, is I imagine, a challenge for many use-cases.</p><h3 id="conclusion">Conclusion</h3><p>In this article, we looked at how Global Accelerator works and behaves. I think it’s a powerful service. Having the ability to flexibly steer traffic to particular regions and even endpoints gives you a lot of control, which will be useful for high traffic applications. It also makes it easier to make applications highly available even on a per IP address basis (as compared to using DNS based load-balancing). A potentially useful feature for Global Accelerator would be to combine it with the Bring Your Own IP feature.</p><p>Global Accelerator is still a relatively young service, and new features will likely be added over time. Currently, I find one of the significant limitations the lack of client IP visibility. Interestingly, AWS just a few days ago, announced <a href="https://aws.amazon.com/blogs/aws/new-client-ip-address-preservation-for-aws-global-accelerator/" rel="noopener">Client IP preservation for ALB </a>(only) endpoints. Given that improvement, I’d imagine that Client IP preservation for other types of endpoints such as elastic IP and NLBs may come at some point too.</p><p>Finally, other than the <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html" rel="noopener">flow logs</a>, I didn’t find any logging or statistics in the AWS console for Global Accelerator. This would, in my opinion, be a valuable add-on.</p><p>All in all, a cool and useful service that I’m sure will be valuable too many AWS users. For me, it was fun to test drive Global Accelerator, check out AWS’ anycast routing setup and build it all using terraform. Hope you enjoyed it too :)</p>]]></content:encoded></item><item><title><![CDATA[Building a high available Anycast application in 5 minutes on Packet]]></title><description><![CDATA[As the demand on our applications and infrastructure grow, it becomes more important to be able to quickly deploy your applications and supporting infrastructure in a safe, fast and scalable way. Luckily the tooling and various cloud providers are catching up and making this a lot easier for us.]]></description><link>http://toonk.io/building-a-high-available-anycast-application-in-5-minutes-on-packet/</link><guid isPermaLink="false">5f53e3ba3680d46e73ec617b</guid><category><![CDATA[anycast]]></category><category><![CDATA[networking]]></category><category><![CDATA[terraform]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Sun, 24 Feb 2019 00:00:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1486411959861-41a3eb8da389?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1486411959861-41a3eb8da389?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Building a high available Anycast application in 5 minutes on Packet"><p></p><p>In my <a href="https://medium.com/@atoonk/experimenting-with-stackpath-edge-computing-and-anycast-f335ba86e60d">previous blog,</a> we took a peek at Stackpath’s Workload features with Anycast. In this blog we will take a look at one of my other favorite compute providers: <a href="https://www.packet.com/" rel="noopener">Packet</a> and we will use <a href="https://www.terraform.io/" rel="noopener">Terraform</a> to describe and deploy our infrastructure as code.</p><h4 id="packet"><strong>Packet</strong></h4><p>I have been using Packet for about 1,5 years now for various projects. There are a few things why I like Packet. It all started with their BGP and Anycast support, yup BGP straight to your server! That combined with their powerful bare-metal compute options, great customer success team and excellent Terraform support makes Packet one of my go-to supplier for my pet projects.</p><h3 id="what-are-we-building">What are we building?</h3><p>Alright, let’s dive in! A brief description of what we’re going to build today: We have a small <a href="https://github.com/atoonk/packet_anycast/blob/master/scripts/web.go" rel="noopener">Golang web application</a> that does nothing more than print the machine’s hostname. We want this application to be highly available and deployed to various locations around the world so that our users can access it with low latency. In our case, we are going to deploy this to four Packet datacenters around the globe, with two instances in each datacenter. Each Packet server will have BGP enabled, and we’ll use Anycast for load balancing and high availability.</p><p>Using the Packet Terraform provider we can do all of this in an automated way, allowing me to all this in less than five minutes! Sounds like fun? Alright, let’s dive in.</p><h3 id="terraform">Terraform</h3><p>We could provision our servers using the web portal, but the ability to describe our infrastructure as code using Terraform is a lot easier and allows us to grow and shrink our deployment easily. If you’d like to play with this yourself and follow along: you can find the code for this demo on <a href="https://github.com/atoonk/packet_anycast" rel="noopener">my Github page here.</a> <br>Next up we will take a brief look at the important parts of the Terraform code.</p><p>First off we create a project in Packet, set some BGP parameters for this project (AS number and optionally a password). Next up comes the cool part, we reserve what Packet calls a <code>global IPv4 address</code>. This IP address is the Anycast address that we’ll be using and will be announced to Packet using the Bird BGP daemon from all our servers.</p><pre><code>provider "packet" {
 auth_token = "${var.packet_api_key}"
}
# Create project
resource "packet_project" "anycast_test" {
 name = "anycast project"
 bgp_config {
 deployment_type = "local"
 #md5 = "${var.bgp_password}"
 asn = 65000
 }
}
# Create a Global IPv4 IP to be used for Anycast
# the Actual Ip is available as: packet_reserved_ip_block.anycast_ip.address
# We'll pass that along to each compute node, so they can assign it to all nodes and announce it in BGP
resource "packet_reserved_ip_block" "anycast_ip" {
 project_id = "${packet_project.anycast_test.id}"
 type = "global_ipv4"
 quantity = 1
}</code></pre><p>Next up we define where we want to deploy our compute nodes to, and how many per datacenter.</p><pre><code>module "compute_sjc" {
 source = "./modules/compute"
 project_id = "${packet_project.anycast_test.id}"
 anycast_ip = "${packet_reserved_ip_block.anycast_ip.address}"
 operating_system = "ubuntu_18_04"
 instance_type = "baremetal_0"
 facility = "sjc1"
 compute_count = "2"
}
module "compute_nrt" {
 source = "./modules/compute"
 project_id = "${packet_project.anycast_test.id}"
 anycast_ip = "${packet_reserved_ip_block.anycast_ip.address}"
 operating_system = "ubuntu_18_04"
 instance_type = "baremetal_0"
 facility = "nrt1"
 compute_count = "2"
}
module "compute_ams" {
 source = "./modules/compute"
 project_id = "${packet_project.anycast_test.id}"
 anycast_ip = "${packet_reserved_ip_block.anycast_ip.address}"
 operating_system = "ubuntu_18_04"
 instance_type = "baremetal_0"
 facility = "ams1"
 compute_count = "2"
}
module "compute_ewr" {
 source = "./modules/compute"
 project_id = "${packet_project.anycast_test.id}"
 anycast_ip = "${packet_reserved_ip_block.anycast_ip.address}"
 operating_system = "ubuntu_18_04"
 instance_type = "baremetal_0"
 facility = "ewr1"
 compute_count = "2"
}</code></pre><p>I created a module to define the compute node, with that we can easily create many of them in the various datacenters. In the example above I created two instances in the following locations: San Jose (<code>sjc1</code>), Tokyo (<code>nrt1</code>), Amsterdam (<code>ams1</code>) and New York (<code>ewr1</code>).</p><p>Let’s take a quick look at the compute module:</p><pre><code>variable facility { }
variable project_id { }
variable compute_count { }
variable operating_system { }
variable instance_type { }
variable anycast_ip { }
#variable bgp_password { }

resource "packet_device" "compute-server" {
 hostname = "${format("compute-%03d", count.index)}.${var.facility}"
 count = "${var.compute_count}"
 plan = "${var.instance_type}"
 facilities = ["${var.facility}"]
 operating_system = "${var.operating_system}"
 billing_cycle = "hourly"
 project_id = "${var.project_id}"

provisioner "local-exec" {
 command = "scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null scripts/create_bird_conf.sh root@${self.access_public_ipv4}:/root/create_bird_conf.sh"
 }

provisioner "local-exec" {
 command = "scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null scripts/web.go root@${self.access_public_ipv4}:/root/web.go"
 }

 provisioner "local-exec" {
 command = "scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null scripts/start.sh root@${self.access_public_ipv4}:/root/start.sh"
 }
 
 provisioner "local-exec" {
 command = "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@${self.access_public_ipv4} 'bash /root/start.sh ${var.anycast_ip} &gt; /dev/null 2&gt;&amp;1 '"
 }
}

#Enable BGP for the newly creates compute node
resource "packet_bgp_session" "test" {
 count = "${var.compute_count}"
 device_id = "${packet_device.compute-server.*.id[count.index]}"
 address_family = "ipv4"
}</code></pre><p>Alright that’s quite a bit of text, luckily most of it is pretty descriptive. The code above creates the compute node we requested at the specified datacenter. You will also see a few <code>local-exec</code> statements; these instruct Terraform to execute a script locally as soon as the instance is created. In this case, I used it to secure copy (scp) some files over and run <code>start.sh</code> on the compute node. Once you have more tasks, it will be easier and cleaner to replace this with an ansible playbook, but this will work just fine for now. <br>The <code><a href="https://github.com/atoonk/packet_anycast/blob/master/scripts/start.sh" rel="noopener">start.sh</a></code> script installs Bird (the BGP daemon), generates the correct Bird BGP config, restarts Bird and starts our Golang web service. Finally, we instruct Terraform to enable BGP on the Packet side for each of our compute nodes.</p><p>And we’re done! With this, we should be able to deploy our infrastructure using the commands below, and within 5 minutes we should have our application deployed globally with an Anycast IP.<br>So enough talking, let’s ask Terraform to build our infrastructure:</p><pre><code class="language-bash">terraform plan
terraform apply</code></pre><p>While we wait, let’s keep an eye on the Packet portal to see what global IP we’ve been allocated. In my case, it’s 147.75.40.35/32.</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://cdn-images-1.medium.com/max/2400/0*xM4dk9oTnmmlunnX" class="kg-image" alt="Building a high available Anycast application in 5 minutes on Packet"></figure><p>Once Terraform is done you’ll see something like this.<br><code>Apply complete! Resources: 18 added, 0 changed, 0 destroyed.</code></p><p>In this case, the 18 resources include: 1 Project, 1 Global IP, 8 compute nodes and 8 BGP sessions. In my case that took just 5 minutes! That’s amazing, eight new bare-metal machines, fully deployed, BGP running with an Anycast IP and my App deployed to various datacenters around the world, load balanced and all. A few years ago that was almost unthinkable.</p><p>The Packet portal also shows the eight compute instances I requested with the hostnames and unicast IP addresses.</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://cdn-images-1.medium.com/max/2400/0*ORbtFYiMzQpHATgF" class="kg-image" alt="Building a high available Anycast application in 5 minutes on Packet"></figure><h3 id="time-to-test">Time to test</h3><p>Alright so now this is all deployed we should be all done! Let’s test our Go web application using my local machine, it should be reachable via <a href="http://147.75.40.35" rel="nofollow noopener noopener">http://147.75.40.35</a> … boom! There it is.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*D33w3GdFu2bto2lZoj7OvQ.png" class="kg-image" alt="Building a high available Anycast application in 5 minutes on Packet"></figure><h3 id="testing-anycast">Testing Anycast</h3><p>Cool, it works! I’m hitting the compute node in San Jose, which is as expected since that is closest to Vancouver, Canada. Next up let’s test from a few locations around the world to make sure Anycast routing works as expected. The screenshot below shows tests from a handful of servers outside the Packet network. Here I’m testing from Palo Alto, New York, Amsterdam, and New York. In all cases, we’re getting routed to the expected closest location, and in all cases, the requests are being load balanced between the two instances in a datacenter.</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/2400/0*G2umtsbNJoDDEVgN" class="kg-image" alt="Building a high available Anycast application in 5 minutes on Packet"><figcaption>Curl tests from around the world to test Anycast Load Balancing</figcaption></figure><p>Now let’s say our web application all of a sudden becomes popular in Japan and in order to keep up with demand we need to scale up our resources there. Doubling our capacity in Tokyo is easy. All we do is edit the <code>cluster.tf </code>Terraform file and change the compute count number from 2 to 4.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1200/1*aeIxPrcq0U-TE98XzQw4aA.png" class="kg-image" alt="Building a high available Anycast application in 5 minutes on Packet"><figcaption>Scaling out our capacity in Tokyo to 4&nbsp;nodes</figcaption></figure><p>Run <code>terraform plan</code> and <code>terraform apply, </code>wait 5 minutes and voila. A few minutes later I indeed see that our clients hitting the Tokyo datacenter are indeed being load balanced over four instances now (<code>compute-000.nrt1 compute-001.nrt1 compute-002.nrt1 compute-003.nrt1</code>), instead of the two previously.</p><h3 id="summary">Summary</h3><p>In this post we looked at deploying our little Golang App to 4 datacenters around the world with two instances per datacenter. We demonstrated how we can scale up deployments and how clients are being routed to the closest datacenter to guarantee low latency and saw requests being load balanced between the instances.</p><p>Even though we used actual bare-metal machines, the experience is mostly the same as deploying VM’s. I used the smallest instance type available to keep cost down. The Tiny But Mighty t1-small that I used is a 4 Core (atom C2550)CPU, 8GB RAM, with SSD storage and 2.5Gbps network connectivity for just $0.07 per hour, great for pet project likes these.<br>Packet provides many different configurations, should you need more powerful hardware, make sure to check out <a href="https://www.packet.com/cloud/servers/" rel="noopener">all options here</a>.</p><p>The power of Terraform really shines for use-cases like this. Kudos to Packet for having excellent Terraform support, it’s pretty cool to do all of the above, including requesting a global Anycast IP using Terraform. The complete deployment takes about 5 minutes, no matter how many datacenters or instances.</p><p>Defining and deploying your applications like we did here, using infrastructure as code and Anycast used to be reserved for the large CDN’s, DNS and major infrastructure providers. Packet now makes it easy for everyone to build high available and low latency infrastructure. Working with Packet has been a great experience and I recommend everyone to give it a spin.</p>]]></content:encoded></item><item><title><![CDATA[Experimenting with StackPath Edge Computing and Anycast]]></title><description><![CDATA[<p></p><p>I love tinkering with new tech, and since it was a cold and snowy weekend here in Vancouver, I figured I’d explore Edge Containers from Stackpath. Earlier this week I read Stackpath’s blog in which they describe their new service: <a href="https://blog.stackpath.com/introducing-containers-and-virtual-machines-at-the-edge" rel="noopener">Introducing containers and virtual machines at the edge</a></p>]]></description><link>http://toonk.io/experimenting-with-stackpath-edge-computing-and-anycast/</link><guid isPermaLink="false">5f53e5733680d46e73ec61a9</guid><category><![CDATA[terraform]]></category><category><![CDATA[networking]]></category><category><![CDATA[anycast]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Mon, 11 Feb 2019 00:00:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1564425583885-822a00f3e1e6?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1564425583885-822a00f3e1e6?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Experimenting with StackPath Edge Computing and Anycast"><p></p><p>I love tinkering with new tech, and since it was a cold and snowy weekend here in Vancouver, I figured I’d explore Edge Containers from Stackpath. Earlier this week I read Stackpath’s blog in which they describe their new service: <a href="https://blog.stackpath.com/introducing-containers-and-virtual-machines-at-the-edge" rel="noopener">Introducing containers and virtual machines at the edge</a></p><blockquote>Update June 21, 2020: a follow-up article is available here: <a href="https://medium.com/swlh/building-a-global-anycast-service-in-under-a-minute-99b0c59c1a4c?source=friends_link&amp;sk=5cbd024efe001ebe2cce422e70ef116f">Building a global anycast service in under a minute</a></blockquote><p>The service offering resonated strongly with me, mostly the ability to deploy your containers or VM’s to many of their locations in one operation, whether that’s an API call or click in the portal. That combined with the fact that Stackpath called out BGP Anycast support in the blog post (for those who know me, I’m a BGP geek), convinced me to give this a spin.</p><h3 id="brand-new-feature"><strong>Brand new Feature</strong></h3><p>So instead of building a snowman, I created an account with stackpath.com. I soon found out their new “Workload” feature is still gated, but within an hour or so Stackpath unlocked this feature for me and it showed up in the Stackpath portal.</p><p><strong><em>Update Feb 12 2019</em></strong><em>: Stackpath advised me that the “Workload” feature is no longer gated and available for all users now.</em></p><h3 id="creating-workloads"><strong>Creating workloads</strong></h3><p>I’ll briefly describe how I created the workload, but also make sure to check out their documentation <a href="https://support.stackpath.com/hc/en-us/articles/360022756051-Getting-Started-With-StackPath-Edge-Computing" rel="noopener">here</a>.<br>I gave my workload a name “stackpath-anycast-fun” and used the following docker image “atoonk/stackpath-fun:latest”, more about that later. Next up I exposed port 80 and defined the compute spec for each container. Also, note that I selected the “Add Anycast IP Address.”</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://cdn-images-1.medium.com/max/2400/1*vBIbWeOFF8Cp4BShSD_Wjg.png" class="kg-image" alt="Experimenting with StackPath Edge Computing and Anycast"></figure><p>Next up I defined what locations I want to deploy the workload to. This is grouped by continent, in my case I used Europe and North America. In each continent, I chose two PoPs: Amsterdam, London, New York, and Los Angeles. So with that my deployment should be live within four datacenters globally, great for my Anycast testing! Finally, I made sure to bring up two instances in each datacenter just so that I can test the load balancing or ECMP routing within a datacenter.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*qKy_k6u3a0-9aTsFYmVbsw.png" class="kg-image" alt="Experimenting with StackPath Edge Computing and Anycast"></figure><h3 id="pricing"><strong>Pricing</strong></h3><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1200/1*6hyuUOzr7xcNE1YwAkcvNg.png" class="kg-image" alt="Experimenting with StackPath Edge Computing and Anycast"></figure><p>At the end, it nicely showed me the pricing. Since I have a particular interest in Anycast, I looked specifically at pricing for that, which at 14 cents per hour comes to $100 per month. All in all for the month for these eight instances &amp; Anycast the price comes to about $627 per month.</p><h3 id="creating-a-docker-image"><strong>Creating a Docker image</strong></h3><p>Earlier on I defined the Docker image that I wanted to have deployed. Stackpath will pull these images from Dockerhub, in my case I defined <a href="https://cloud.docker.com/repository/docker/atoonk/stackpath-fun/" rel="noopener">atoonk/stackpath-fun:latest</a>. So what does this container do? Basically, it’s a container with Apache + PHP, and a little script that prints the hostname variable using <em>gethostname();.</em> This will allow me to, later on, test what instance I’m hitting by requesting a webpage.</p><h3 id="start-the-workload"><strong>Start the workload</strong></h3><p>Now that we have a Docker image on Dockerhub and the workload is created it’s time to test it. After you create the workload in the Stackpath portal, it takes about 2 minutes or so for all instances to come online. Eventually, it will look like this.</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://cdn-images-1.medium.com/max/2400/1*eFdoPVGEcnUBKrQOQFRayg.png" class="kg-image" alt="Experimenting with StackPath Edge Computing and Anycast"></figure><p>Cool, all my container instances went from Starting to Running. In addition to an external IP for each container, I also have an Anycast IP: 185.85.196.10</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*oxXwKP82dGujxchF_wtMTg.png" class="kg-image" alt="Experimenting with StackPath Edge Computing and Anycast"></figure><h3 id="time-to-test-anycast"><strong>Time to test Anycast</strong></h3><p>I can hit all the containers via their external IP address using my browser. Next up checked to see if the Anycast address worked, and yes it did! The example below shows I’m hitting one of the LAX instances, which is as expected since that’s the closest location from my home in Vancouver. <br>I refreshed my browser a few times and indeed saw it flip between the two Los Angeles instances I created: <code>stackpath-anycast-fun-na1-lax-0</code> and <code>stackpath-anycast-fun-na1-lax-1</code> (note the last digit).</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*CvE7aQK43NYBxvrlctG9Xw.png" class="kg-image" alt="Experimenting with StackPath Edge Computing and Anycast"></figure><h3 id="global-testing"><strong>Global testing</strong></h3><p>Next up it’s time to test from a few more locations to make sure the global Anycast setup works as expected. To test this, I did a curl from some shell servers in Amsterdam, London, New York and Seattle like this:</p><pre><code>time for i in `seq 1 15`; do curl -s 185.85.196.10/server.php | grep stackpath-anycast-fun; done</code></pre><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/2400/1*9bXqOdJKhlSJnGJTrOXvBA.png" class="kg-image" alt="Experimenting with StackPath Edge Computing and Anycast"><figcaption>Curl tests from around the world to test Anycast Load Balancing</figcaption></figure><p>The screenshot above shows the full high availability and load balancing story in one picture.<br>My Amsterdam server is hitting the Amsterdam containers and being load balanced between the containers there. Seattle is routed to Los Angeles as expected, and similarly, the New York client is being served by the two containers in New York (JFK). <br>The one that stands out though is my London shell server. That client is following the Anycast route to New York. That’s odd, especially since I have a cluster deployed in both Amsterdam and London. Also note the last line, showing that to complete this request it took over 2secs, while the client in Amsterdam finished its requests in 200ms.</p><h4 id="the-london-routing-mystery"><strong>The London routing mystery</strong></h4><p>I did a bit of poking to understand why the London server is going to New York, instead of staying local in London. By looking at the routing table, I see the following in London:</p><pre><code>&gt; 185.85.196.0/24 
*[BGP/170] 3d 13:19:37, MED 38020, localpref 100
 AS path: 3356 209 33438 I, validation-state: unverified
 
 [BGP/170] 23:46:15, MED 2011, localpref 100
 AS path: 2914 1299 33438 I, validation-state: unverified
 
 [BGP/170] 2w0d 09:36:24, MED 30, localpref 100
 AS path: 3257 1299 33438 I, validation-state: unverified</code></pre><p>The above indicates this router learns the path to 185.85.196.10 via three ISPs:<code> Level3 (AS3356)</code>, <code>NTT (AS2914)</code> and<code> GTT (AS3257)</code>. The router selected the path via Level3. Level3 then uses the path via <code>Centurylink (AS209)</code> to send it to <code>Stackpath (AS33438)</code>. <br>This shows us that <code>Stackpath (AS33438)</code>, is buying connectivity from Centurylink in the USA. Since Level3 prefers the US path via Centurylink all Level3 customers in Europe are routed to the US, New York in this case. Just announcing Anycast routes out of the US and not scoping them (make sure the announcements stay in the US) will inevitably cause the Anycast routing challenges we see here.</p><p><strong><em>Update Feb 12 2019</em></strong><em>: The Anycast routing issue has now been resolved by the Stackpath network team. Routing from my test client in London is now correctly routed to the container cluster in London.</em></p><h3 id="summary"><strong>Summary</strong></h3><p>In summary, it was pretty easy to get going with Stackpath’s container service. It’s cool to be able to deploy your workloads around the world with just a single click. The icing on the cake for me is the global load balancing with Anycast feature. <br>Anycast used to be a feature used by mostly DNS operators and CDN folks. However over the last two years or so we’ve seen infrastructure providers such as Packet and AWS making this available to their customers directly. With these features, folks can now really deploy their high available services globally without necessarily needing to rely on CDN’s or any DNS tricks (or better, build your own DNS tricks now).</p><p>I think the pricing is a bit steep, but I’m guessing since it’s a new feature with possibly limited supply, this is one way to get to market while ramping up their capacity. The other thing to keep in mind is that folks like Packet and Stackpath are focusing on the Edge. They are deployed in some of the most expensive and most popular datacenters around the world. This will give its customers great low latency connectivity, but space and power are limited in these facilities, possibly pushing up the pricing.</p><p>Going forward I’d love to see some more features around, monitoring, metrics and logging for my containers. <br>Realizing this is early on, my first experience with Stackpath was a joy, it was easy to use, great support (thanks Ben and Sean) and I look forward to what’s next.</p>]]></content:encoded></item></channel></rss>
