<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Andree's Musings]]></title><description><![CDATA[Thoughts, stories and wild ideas from the world of Infrastructure Engineering.]]></description><link>http://toonk.io/</link><image><url>http://toonk.io/favicon.png</url><title>Andree&apos;s Musings</title><link>http://toonk.io/</link></image><generator>Ghost 3.34</generator><lastBuildDate>Tue, 16 Feb 2021 18:58:50 GMT</lastBuildDate><atom:link href="http://toonk.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Introducing SSH zero trust, Identity aware TCP sockets]]></title><description><![CDATA[<blockquote><em><em>In this article, we’ll look at Mysocket’s zero-trust <strong><strong><em>cloud-delivered, authenticating firewall. </em></strong></strong><em>Allowing</em><strong><strong><em> </em></strong></strong>you<strong><strong><em> to replace your trusted IP ranges with trusted identities.</em></strong></strong></em></em></blockquote><figure class="kg-card kg-embed-card"><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FAJ_4iHfoakY%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DAJ_4iHfoakY&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FAJ_4iHfoakY%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" allowfullscreen frameborder="0" height="480" width="640" title="Mysocket Demo - Introducing SSH zero trust, Identity aware TCP sockets" class="by fo fl kr w" scrolling="auto" style="box-sizing: inherit; width: 680px; position: absolute; left: 0px; top: 0px; height: 510px;"></iframe></figure><p>Last month we introduced our first zero trust features by introducing the concept of <em><em>Identity Aware Sockets</em></em>. It’s been great to see folks giving this</p>]]></description><link>http://toonk.io/introducing-ssh-zero-trust-identity-aware-tcp-sockets/</link><guid isPermaLink="false">602c13657c52791b41798673</guid><category><![CDATA[mysocket]]></category><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Tue, 16 Feb 2021 18:57:54 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1578223003535-35db3073ada7?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDg4fHx2YW5jb3V2ZXIlMjBwZW9wbGV8ZW58MHx8fA&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<blockquote><em><em>In this article, we’ll look at Mysocket’s zero-trust <strong><strong><em>cloud-delivered, authenticating firewall. </em></strong></strong><em>Allowing</em><strong><strong><em> </em></strong></strong>you<strong><strong><em> to replace your trusted IP ranges with trusted identities.</em></strong></strong></em></em></blockquote><figure class="kg-card kg-embed-card"><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FAJ_4iHfoakY%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DAJ_4iHfoakY&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FAJ_4iHfoakY%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" allowfullscreen frameborder="0" height="480" width="640" title="Mysocket Demo - Introducing SSH zero trust, Identity aware TCP sockets" class="by fo fl kr w" scrolling="auto" style="box-sizing: inherit; width: 680px; position: absolute; left: 0px; top: 0px; height: 510px;"></iframe></figure><img src="https://images.unsplash.com/photo-1578223003535-35db3073ada7?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxMTc3M3wwfDF8c2VhcmNofDg4fHx2YW5jb3V2ZXIlMjBwZW9wbGV8ZW58MHx8fA&ixlib=rb-1.2.1&q=80&w=2000" alt="Introducing SSH zero trust, Identity aware TCP sockets"><p>Last month we introduced our first zero trust features by introducing the concept of <em><em>Identity Aware Sockets</em></em>. It’s been great to see folks giving this a spin and start using it as a remote access alternative for the traditional VPN.</p><p>Most services out there today are HTTP based, typically served over HTTPS. However, there are a few other commonly used services that are not HTTP based and, as a result, up until today, didn’t benefit from our identity-aware sockets. In this article, we’ll introduce Zero trust support for non-HTTP based service, with the introduction Identity aware TCP sockets. Specifically, we’ll look at providing zero trust services for SSH as an example.</p><h1 id="determining-the-user-s-identity-authentication-and-authorization">Determining the user’s identity, authentication, and authorization</h1><p>Turning your mysocket services into an identity-aware socket is as simple as adding the — cloud_authentication flag to mysocketctl when creating the service. While doing so, you have the ability to add a list of email domains and/or a list of email addresses. Now each time a user tries to access your service, a browser will pop up asking the user to authenticate. Once authentication is finished, we know the user’s identity, and if that identity matches the list of authorized users, only then will the user be let through.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://toonk.io/content/images/2021/02/Screen-Shot-2021-02-15-at-10.25.14-AM.png" class="kg-image" alt="Introducing SSH zero trust, Identity aware TCP sockets" srcset="http://toonk.io/content/images/size/w600/2021/02/Screen-Shot-2021-02-15-at-10.25.14-AM.png 600w, http://toonk.io/content/images/size/w1000/2021/02/Screen-Shot-2021-02-15-at-10.25.14-AM.png 1000w, http://toonk.io/content/images/size/w1600/2021/02/Screen-Shot-2021-02-15-at-10.25.14-AM.png 1600w, http://toonk.io/content/images/size/w2400/2021/02/Screen-Shot-2021-02-15-at-10.25.14-AM.png 2400w" sizes="(min-width: 720px) 720px"><figcaption>Creating an Identity-aware TCP socket</figcaption></figure><p>If you think about what is happening here, you’ll realize that what we have here is a <strong><strong><em><em>per session, authenticating firewall</em></em></strong></strong>. Only after the user is authenticated and authorized do we allow the network traffic through. Notice that this is much more advanced than your traditional firewall; now, <strong><strong>every network flow has an identity</strong></strong>. That’s powerful!</p><p>This flow of redirecting users to authenticate and then back to the service was do-able because it’s done in the browser and largely built of HTTP session management. Now we’d like to extend this with non-HTTP services, so we’ll need to find an alternative for the HTTP session part.<br>The solution for this comes with the help of Mutual TLS (MTLS). MTLS forces the client to authenticate itself when talking to the server. This is achieved by presenting a signed client certificate to the server.</p><h1 id="identity-aware-tcp-sockets">Identity aware TCP sockets</h1><p>With the introduction of identity-aware TCP sockets, the mysocket edge proxies act as an authenticating firewall. Since we are relying on client TLS certificates, all traffic is securely tunneled over a TLS connection.</p><p>As you can see in the flow below, there are a few actions to take before the user can get through. To make this a seamless experience for the users of your service, we’ve extended the mysocketctl command-line tool with the required functionality that kicks of the authentication flow. It starts the authentication process; after that, it requests a client certificate (your ticket in), and then it sets up the TLS tunnel for you. After that, users can send traffic over this authenticated and encrypted tunnel. In its simplest form, it will look something like this:</p><pre><code class="language-bash">echo "hello" | mysocketctl client tls \ 
    --host muddy-pond-7106.edge.mysocket.io</code></pre><p>In the example above, we’re sending the string hello, to the service served by muddy-pond-7106.edge.mysocket.io.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://toonk.io/content/images/2021/02/Screen-Shot-2021-02-15-at-10.07.49-AM.png" class="kg-image" alt="Introducing SSH zero trust, Identity aware TCP sockets" srcset="http://toonk.io/content/images/size/w600/2021/02/Screen-Shot-2021-02-15-at-10.07.49-AM.png 600w, http://toonk.io/content/images/size/w1000/2021/02/Screen-Shot-2021-02-15-at-10.07.49-AM.png 1000w, http://toonk.io/content/images/size/w1600/2021/02/Screen-Shot-2021-02-15-at-10.07.49-AM.png 1600w, http://toonk.io/content/images/2021/02/Screen-Shot-2021-02-15-at-10.07.49-AM.png 1932w" sizes="(min-width: 720px) 720px"><figcaption>Traffic flow</figcaption></figure><p>Before the string “hello” arrives at the service protected by mysocket, the mysocketctl client will take care of the authentication flow, requests the TLS client certificate, and sends whatever comes in over stdin to the mysocket edge services.</p><h1 id="ssh-zero-trust">SSH zero trust</h1><p>Now that we understand the high-level flow let’s look at a more practical example. In this example, we have a server for which I’d like to make the SSH service available to only a subset of users. The ssh is on a private network such as your corporate network, your home network, or even in a private VPC or just firewalled off from the Internet.</p><p>First, we’ll provision the service using mysocketctl on the server-side and set up the tunnel.</p><pre><code class="language-bash">mysocketctl connect \  
	--name 'remote access for my ssh server' \ 
    --cloudauth \  
    --allowed_email_addresses'contractor@gmail.com,john@example.com' \ 
    --allowed_email_domains 'mycorp.com' \ 
    --port 22 --host localhost \ 
    --type tls</code></pre><p>In this example, I'm creating a mysocket service of type TLS, and we enable cloud authentication. This will force the user to present a valid client TLS certificate. The certificate can only ever be handed out to users that authenticate with a mycorp.com email address or using the specific email addresses contractor@gmail.com or john@example.com.<br>The same command will also set up a secure tunnel to the closest mysocket tunnel servers and expose the ssh service running on port 22.</p><figure class="kg-card kg-image-card"><img src="http://toonk.io/content/images/2021/02/Screen-Shot-2021-02-13-at-1.34.56-PM.png" class="kg-image" alt="Introducing SSH zero trust, Identity aware TCP sockets" srcset="http://toonk.io/content/images/size/w600/2021/02/Screen-Shot-2021-02-13-at-1.34.56-PM.png 600w, http://toonk.io/content/images/size/w1000/2021/02/Screen-Shot-2021-02-13-at-1.34.56-PM.png 1000w, http://toonk.io/content/images/size/w1600/2021/02/Screen-Shot-2021-02-13-at-1.34.56-PM.png 1600w, http://toonk.io/content/images/2021/02/Screen-Shot-2021-02-13-at-1.34.56-PM.png 2372w" sizes="(min-width: 720px) 720px"></figure><p>The result is that this SSH service is now accessible to allowed users only, as crimson-thunder-8434.edge.mysocket.io:38676<br>Only inbound traffic with a valid client TLS ticket will be let through. Valid TLS client certificates will only ever be issued to users with a mycorp.com domain or the two contractor email addresses we specified.</p><h2 id="setting-up-an-ssh-session">Setting up an SSH session</h2><p>Ok, time to test this and connect to this ssh service. Remember that we need a valid TLS client certificate. These are issued only with a valid token, and the token is only handed out to authorized users. To make all of this easier, we’ve extended the mysocketctl tool to take care of this workflow. The example below shows how we use the ssh ProxyCommand to make that easier for us, like this.</p><pre><code class="language-bash">ssh ubuntu@crimson-thunder-8434.edge.mysocket.io \ 
	-o 'ProxyCommand=mysocketctl client tls --host %h'</code></pre><p>This will tell ssh to send all ssh traffic through this <em><em>mysocketctl client </em></em>command. This will start the authentication process, fetch the TLS client certificate for us, set up the TLS tunnel to the mysocket edge server, and transport the ssh traffic through this authenticated tunnel. The user can now log in to the ssh server using whatever method you’re used to.</p><p>With this, we’ve made our private ssh server accessible from the Internet, while the <strong><strong><em><em>authenticating mysocket firewall</em></em></strong></strong> is only allowing in session from client identities we approved beforehand. No VPN needed. Pretty cool, right?</p><h1 id="mysocket-ssh-certificate-authorities-">Mysocket SSH Certificate authorities.</h1><figure class="kg-card kg-image-card"><img src="http://toonk.io/content/images/2021/02/but-wait-theres-more--1-.jpg" class="kg-image" alt="Introducing SSH zero trust, Identity aware TCP sockets"></figure><p>SSH is quite similar to TLS in terms of workflow. It too supports authenticating users using signed certificates.</p><p>So we decided to expand on this functionality. In addition to an API endpoint that is responsible for signing TLS certificates, we also created one for signing SSH keys.</p><p>If we build on the example above, the user can now, in addition to requesting a TLS client certificate, also request a signed SSH certificate. Our SSH certificate signing service will only sign the signing request if the user is authenticated and authorized, using the same logic as before.</p><h2 id="setting-up-the-server">Setting up the server</h2><p>In order to use this, we’ll need to make a few minor changes to the SSH server. The configuration changes below are needed to enable authentication using CA keys.</p><pre><code class="language-bash">echo "TrustedUserCAKeys /etc/ssh/ca.pub" &gt;&gt;/etc/ssh/sshd_config

echo "AuthorizedPrincipalsFile %h/.ssh/authorized_principals" &gt;&gt;/etc/ssh/sshd_config

echo "mysocket_ssh_signed" &gt; /home/ubuntu/.ssh/authorized_principals</code></pre><p>Finally, also make sure to get the Public key for the CA (<em><em>mysocketctl socket show)</em></em> and copy it into the ca.pub file (<code>/etc/ssh/ca.pub)</code></p><p>Now the server is configured to work with and allow authentication based on signed SSH keys from the mysocket certificate authority. Note that all signed certificates will have two principles, the email address of the authenticated user, as well as ‘<em><em>mysocket_ssh_signed</em></em>’. In the example configuration above, we told the server to map users with the principle ‘<em><em>mysocket_ssh_signed</em></em>’ to the local user ubuntu.</p><p>Now we’re ready to connect, but instead of making the ssh command even longer, I’m going to add the following to my ssh config file ~/.ssh/config</p><pre><code>Host *.edge.mysocket.io
    ProxyCommand bash -c 'mysocketctl client ssh-keysign --host %h; ssh -tt -o IdentitiesOnly=yes -i ~/.ssh/%h %r@%h.mysocket-dummy &gt;&amp;2 &lt;&amp;1'

Host *.mysocket-dummy
    ProxyCommand mysocketctl client tls --host %h</code></pre><p>The above will make sure that for all ssh sessions to *.edge.mysocket.io we start the authentication flow, fetch a TLS client certificate, and set up the TLS tunnel. We’ll also submit an SSH key signing request, which will result in a short-lived signed SSH certificate that will be used for authenticating the SSH user.</p><p>Now the user can just SSH like this, and the whole workflow will kick-off.</p><pre><code class="language-bash">ssh ubuntu@crimson-thunder-8434.edge.mysocket.io</code></pre><p>For those interested, the ssh certificate will end up in your ~/.ssh/ directory and will look like this.</p><pre><code>$ ssh-keygen -Lf ~/.ssh/nameless-thunder-8896.edge.mysocket.io-cert.pub
/Users/andreetoonk/.ssh/nameless-thunder-8896.edge.mysocket.io-cert.pub:
        Type: ecdsa-sha2-nistp256-cert-v01@openssh.com user certificate
        Public key: ECDSA-CERT SHA256:0u6TICEhrISMCk7fbwBi629In9VWHaDG1IfnXoxjwlg
        Signing CA: ECDSA SHA256:MEdE6L0TUS0ZZPp1EAlI6RZGzO81A429lG7+gxWOonQ (using ecdsa-sha2-nistp256)
        Key ID: "atoonk@gmail.com"
        Serial: 5248869306421956178
        Valid: from 2021-02-13T12:15:20 to 2021-02-13T12:25:20
        Principals:
                atoonk@gmail.com
                mysocket_ssh_signed
        Critical Options: (none)
        Extensions:
                permit-X11-forwarding
                permit-agent-forwarding
                permit-port-forwarding
                permit-pty
                permit-user-rc</code></pre><p>With this, users can SSH to the same server as before, but the cool thing is that the server won’t need to know any traditional known credentials for its users. Things like passwords or a public key entry in the authorized_keys file belong to the past. Instead, with the help of <em><em>mysocketctl</em></em>, the user will present a short-lived signed ssh certificate, which the server will trust.</p><p>With this, we achieved true Single Sign-on (SSO) for your SSH servers. Since the certificates are short-lived, five minutes in the past(to allow for time drift) to five minutes in the future, we can be sure that for each log-in the authentication and authorization flow was successful.</p><h1 id="give-it-a-try-yourself-using-my-ssh-server">Give it a try yourself using my SSH server</h1><p>If you’re curious about what it looks like for the user and want to give it a try? I have a test VM running on 165.232.143.236, it has firewall rules to prevent SSH traffic from the Internet, but using <em><em>mysocket</em></em>, anyone with a gmail.com account can access it. I encourage you to give it a spin, it will take you less than a minute to set up, just copy-paste the one-time setup config.</p><h2 id="onetime-setup">Onetime setup</h2><p>If you’re using a Mac laptop as your client, you’ll need the mysockectl tool which will request the short-lived certs and will setup up the TLS tunnel. To install the client just copy-paste the below (for Mac only, see download.edge.mysocket.io for other platforms).</p><pre><code class="language-bash">curl -o mysocketctl https://download.edge.mysocket.io/darwin_amd64/mysocketctl 

chmod +x ./mysocketctl
sudo mv ./mysocketctl /usr/local/bin/</code></pre><p></p><p>To make it easy to use we’ll add the following to our ssh client config file. This is a one-time setup and will make sure the ssh traffic to *.edge.mysocket.io is sent through the mysocketctl client tool.</p><pre><code class="language-bash">cat &lt;&lt;EOF &gt;&gt; ~/.ssh/config
Host *.edge.mysocket.io
 ProxyCommand bash -c ‘mysocketctl client ssh-keysign --host %h; ssh -tt -o IdentitiesOnly=yes -i ~/.ssh/%h %r@%h.mysocket-dummy &gt;&amp;2 &lt;&amp;1’
Host *.mysocket-dummy
 ProxyCommand mysocketctl client tls --host %h
EOF</code></pre><p>Now you should be able to ssh to my test server using</p><pre><code class="language-bash">ssh testuser@frosty-feather-1130.edge.mysocket.io</code></pre><p>When the browser pops up, make sure to use the “log in with Google” option, as this socket has been configured to only allow identities that have a Gmail.com email address.</p><h1 id="wrapping-up">Wrapping up</h1><p>In this post, we showed how we continued to build on our previous work with “identity-aware<em><em> sockets</em></em>”. We Introduced support for identity-aware TCP sockets, by leveraging TLS tunnels and Mutual TLS for authentication.</p><blockquote><em><em>I like to think of this as a <strong><strong><em>cloud-delivered, authenticating firewall.</em></strong></strong> With this, we can make your services available to the Internet on a very granular basis, and make sure that <strong><strong><em>each flow has an identity attached to it</em></strong></strong>. Ie, we know exactly, on a per TCP flow basis, what identity (user) is using this flow. That’s a really powerful feature when compared to a traditional firewall, where we had to allow SSH traffic from certain network ranges that were implicitly trusted. What we can now do with these identity-aware sockets is rewrite these firewall rules and <strong><strong><em>replace the trusted IP ranges with trusted identities.</em></strong></strong> This is incredibly powerful for those that need strict compliance, and need to answer things like, who (not an IP, but an identity) connected to what when.</em></em></blockquote><p>We looked at how this can be used to provide zero trust remote access to your SSH servers. And how it can be further extended by using the new SSH key signing service.</p><p>That’s it for now, I hope you found this interesting and useful. As always, if you have any questions or feedback, feel free to reach out.</p><p><a href="https://www.youtube.com/playlist?list=PLSqlOpN6fPZ1myn5we6UcOx4ll9oteG_8" rel="noopener nofollow">Hungry for more? check out all our demo’s on Youtube here</a></p>]]></content:encoded></item><item><title><![CDATA[Introducing Identity Aware Sockets: Enabling Zero Trust access for your Private services]]></title><description><![CDATA[<p><em><em>In this blog post, we’ll introduce an exciting new feature that, with the help of Mysocket, allows you to deploy your own Beyond Corp setup.</em></em></p><h1 id="what-is-zero-trust">What is Zero Trust</h1><p>The main concept behind Zero Trust is that users shouldn’t just be trusted because they are on your network.</p>]]></description><link>http://toonk.io/introducing-identity-aware-sockets-enabling-zero-trust-access-for-your-private-services/</link><guid isPermaLink="false">60007bd37c52791b41798651</guid><category><![CDATA[mysocket]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Thu, 14 Jan 2021 17:19:18 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1605672183331-d2002650cf00?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDg3fHx2YW5jb3V2ZXJ8ZW58MHx8fA&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1605672183331-d2002650cf00?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxMTc3M3wwfDF8c2VhcmNofDg3fHx2YW5jb3V2ZXJ8ZW58MHx8fA&ixlib=rb-1.2.1&q=80&w=2000" alt="Introducing Identity Aware Sockets: Enabling Zero Trust access for your Private services"><p><em><em>In this blog post, we’ll introduce an exciting new feature that, with the help of Mysocket, allows you to deploy your own Beyond Corp setup.</em></em></p><h1 id="what-is-zero-trust">What is Zero Trust</h1><p>The main concept behind Zero Trust is that users shouldn’t just be trusted because they are on your network. This implicit trust problem is something we typically see with, for example, corporate VPNs. With most corporate VPN’s once a user is authenticated, the user becomes part of the corporate network and, as a result, has access to many of the resources within the corporate infrastructure. In other words, once you’re on the VPN, you’re within the walls of the castle, you’re trusted, and you have lots of lateral access.</p><p>The world is changing, and the once traditional approach of trusting devices on your network are over. A few years ago, Google started the journey to their implementation of Zero trust called Beyond Corp. One of the core building blocks to get to a Zero Trust model is Identity aware application proxies. These proxies can provide strict access control on a per-application granularity, taking the users’ identity and contexts such as location and device status into account.</p><h1 id="identity-aware-proxies">Identity aware proxies</h1><p>As of today, the Mysocket proxies have support for OpenID Connect, and with that, your sockets are identity-aware. This means that mysocket users can now enable authentication for their services and provide authorization rules.</p><pre><code class="language-bash">mysocketctl connect \
   --port 3000 \
   --name "My Identity aware socket" \
   --cloudauth \
   --allowed_email_domains "mycorp.com" \
   --allowed_email_addresses "contractor1@gmail.com,john@doe.com"</code></pre><p>The example above shows how we can enable authentication by using the “<em><em>cloudauth</em></em>” CLI parameter. With <em><em>cloudauth</em></em> enabled, users will be asked to authenticate before access to your service is granted. Currently, we support authentication using Google, Facebook, Github, or locally created accounts.</p><p>The authentication flow uses OpenID connect to interact with the various Identity providers (IDP); thus, we can easily add more Identity providers in the future. We’re also looking at SAML as a second authentication flow. Please let us know if you have a need for more IDP’s or SAML, and we’ll work with you.</p><h1 id="authorizations-rules">Authorizations rules</h1><p>In addition to what the Identity Service Provider (IDP) provides, mysocket also provides two authorization rules. The <em><em>— allowed_email_domain </em></em>allows users to specify a comma-separated list of email domains. If your users are authenticating using their <em><em>mycorp.com</em></em> email address, then by adding this domain as an <em><em>allowed_email_domain</em></em>, will make sure only users with that domain have will be granted access.</p><p>Since multiple identities providers are supported, it’s easy to extend access to contractors or other 3rd party users. To provide access to external contractors that are not part of your mycorp.com domain, we can use the <em><em>allowed_email_addresses</em></em> parameter to add individual identities. This is great because now you can provide these contractors access without creating corporate accounts for them.</p><p>These are just two authorization rules; we’re planning to add more types of rules in the near future. Additional authorization rules that come to mind are, Geo-based rules (only allow access from certain countries or regions) or time of day type rules. If you require these types of rules or have suggestions for additional authorization rules, please let us know!</p><h1 id="vpn-replacement">VPN replacement</h1><p>One of the unique features of mysocket is that the origin server initiates the connection to the Mysocket edge. This means that the origin servers can be on a highly secure network that only allows outbound connections. Meaning the origins can be hosted behind strict firewall rules or even behind NAT, like for example, a Private AWS VPC. With this, your origin server remains private and hidden.</p><p>With the addition of authentication and authorization to Mysocket, we can now, on a very granular basis, provide access to your private services. Combining the secure outbound tunnel property and the identity-aware sockets, we can now look at this to provide an alternative to VPNs, while providing much more granular access to private or corporate resources.</p><figure class="kg-card kg-image-card"><img src="http://toonk.io/content/images/2021/01/Screen-Shot-2021-01-12-at-9.51.34-PM.png" class="kg-image" alt="Introducing Identity Aware Sockets: Enabling Zero Trust access for your Private services" srcset="http://toonk.io/content/images/size/w600/2021/01/Screen-Shot-2021-01-12-at-9.51.34-PM.png 600w, http://toonk.io/content/images/size/w1000/2021/01/Screen-Shot-2021-01-12-at-9.51.34-PM.png 1000w, http://toonk.io/content/images/size/w1600/2021/01/Screen-Shot-2021-01-12-at-9.51.34-PM.png 1600w, http://toonk.io/content/images/2021/01/Screen-Shot-2021-01-12-at-9.51.34-PM.png 1608w" sizes="(min-width: 720px) 720px"></figure><h1 id="example-use-case">Example use case</h1><p>Imagine a scenario where you work with a contractor that needs access to one specific private application, say an internal wiki, ticket system, or the git server in your corporate network. With the traditional VPN setup, this means we’d need to provide the contractor with a VPN account. Typically this means the contractor is now part of the corporate network, has a corporate user account, and now has access to much more than just the application needed.</p><blockquote><em>Instead, what we really want is to </em><strong>only</strong><em> provide access to the one application and be very granular in who has access. With the addition of identity-aware sockets, this is now possible.</em></blockquote><h1 id="demo-time-">Demo time!</h1><p>Alright, let’s give this a spin, demo time! In this demo, we’re making a Grafana instance that’s on a private network and behind two layers of NAT available to our employees as well as a contractor.</p><p>We’ll start by setting up the socket and tunnel using the “<em>mysocketctl</em> <em>connect</em>” command.</p><p>This works great for demo’s; for more permanent setups, it’s recommended to use “<em>mysocketctl socket create</em>” and “<em>mysocketctl tunnel create</em>” so that you have a permanent DNS name for your service.</p><pre><code class="language-bash">mysocketctl connect \
   --port 3000 \
   --name "My Identity aware socket" \
   --cloudauth \
   --allowed_email_domains "mycorp.com" \
   --allowed_email_addresses "andree@toonk.io,john@doe.com"</code></pre><p>With this, we created a socket on the mysocket.io infrastructure, enabled authentication, and provided a list of authorization rules. The same command also created the secure tunnel to the closest mysocket.io tunnel server, and we’re forwarding port 3000 on localhost to the newly created socket.</p><p>Next, we launch a Grafana container. For fun, I’m passing in my AWS cloudwatch credentials, so I can create some dashboards for my AWS resources. I’ve configured grafana for proxy authentication. Meaning it will trust mysocket.io to do the authentication and authorization. Grafana will use the HTTP headers added by mysocket to determine the user information.</p><pre><code>[auth.proxy]
enabled = true
header_name = X-Auth-Email
header_property = username
auto_sign_up = true
headers = Email:X-Auth-Email</code></pre><p>The complete example grafana.ini config file I used can <a href="https://github.com/mysocketio/examples/tree/main/2021-01-14-authentication-zero-trust-grafana" rel="noopener nofollow">be found here</a>. Now we’re ready to launch Grafana. I’m doing this from my laptop, using Docker.</p><pre><code class="language-bash">docker run -i -v grafana.ini:/etc/grafana/grafana.ini \
 -e “GF_AWS_PROFILES=default” \
 -e “GF_AWS_default_ACCESS_KEY_ID=$ACCESS_KEY_ID” \
 -e “GF_AWS_default_SECRET_ACCESS_KEY=$SECRET_ACCESS_KEY” \
 -e “GF_AWS_default_REGION=us-east-1” \
 -p 3000:3000 grafana/grafana</code></pre><figure class="kg-card kg-image-card"><img src="http://toonk.io/content/images/2021/01/Screen-Shot-2021-01-13-at-10.39.59-AM.png" class="kg-image" alt="Introducing Identity Aware Sockets: Enabling Zero Trust access for your Private services" srcset="http://toonk.io/content/images/size/w600/2021/01/Screen-Shot-2021-01-13-at-10.39.59-AM.png 600w, http://toonk.io/content/images/size/w1000/2021/01/Screen-Shot-2021-01-13-at-10.39.59-AM.png 1000w, http://toonk.io/content/images/size/w1600/2021/01/Screen-Shot-2021-01-13-at-10.39.59-AM.png 1600w, http://toonk.io/content/images/2021/01/Screen-Shot-2021-01-13-at-10.39.59-AM.png 1698w" sizes="(min-width: 720px) 720px"></figure><p>Grafana is now listening on localhost port 3000. The mysocket connection we created earlier is relaying authenticated and authorized traffic to that local socket. With that, we should now be able to test and see if we have access to Grafana.</p><h1 id="wrapping-up">Wrapping up</h1><p>In this article, we introduced identity aware sockets. We saw how Mysocket users can easily enable authentication for their HTTP(S) based sockets and how OpenID connect is used for the authentication flow to Google, Facebook, or Github (for now). We then looked at how authorization rules can be added by either matching the email domain or even a list of email addresses.</p><p>With this, it’s now easy to provide access to internal applications, from any device, any time anywhere, without the need for a VPN.</p>]]></content:encoded></item><item><title><![CDATA[Global load balancing with Kubernetes and Mysocket.io]]></title><description><![CDATA[<p>If you’re in the world of cloud infrastructure, then you’ve heard of Kubernetes. Some of you are experts already, while some of us are just learning or getting started. In this blog, we’ll introduce a mysocket controller for Kubernetes and demonstrate how easy it is to use</p>]]></description><link>http://toonk.io/global-load-balancing-with-kubernetes/</link><guid isPermaLink="false">5fe18d6451a5ff44fb64d99a</guid><category><![CDATA[mysocket]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Tue, 22 Dec 2020 06:17:15 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1541741716758-85ac18fb7c62?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDl8fHZhbmNvdXZlciUyMHNoaXB8ZW58MHx8fA&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1541741716758-85ac18fb7c62?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxMTc3M3wwfDF8c2VhcmNofDl8fHZhbmNvdXZlciUyMHNoaXB8ZW58MHx8fA&ixlib=rb-1.2.1&q=80&w=2000" alt="Global load balancing with Kubernetes and Mysocket.io"><p>If you’re in the world of cloud infrastructure, then you’ve heard of Kubernetes. Some of you are experts already, while some of us are just learning or getting started. In this blog, we’ll introduce a mysocket controller for Kubernetes and demonstrate how easy it is to use mysocket.io as your cloud-delivered load balancer for your Kubernetes Services. If you’re a Kubernetes user already, then it should just take a minute to get this mysocket controller setup.</p><blockquote><strong>See this video for a demo of the Mysocket.io integration with Kubernetes</strong></blockquote><figure class="kg-card kg-embed-card"><iframe width="267" height="200" src="https://www.youtube.com/embed/tFfLfI1jYi4?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></figure><h3 id="pods-deployments-and-services">Pods, Deployments, and Services</h3><p>Before we continue, let’s review some of the main Kubernetes building blocks we will be using to make this work.</p><p>A typical workload running in Kubernetes will look something like the diagram below. It typically starts with a <em>deployment</em>, in which you define how many replicas (<em>pods) you’d like</em>.</p><p>Since pods are ephemeral and can scale in and out as needed, the Pod IP addresses will be dynamic. As a result, communicating with the pods in your deployment from other Deployments would require constant service discovery, which may be challenging for certain apps. To solve this, Kubernetes has the concept of a Service. A service acts as a logical network abstraction for all the pods in a workload and is a way to expose an application running on a set of<a href="https://kubernetes.io/docs/concepts/workloads/pods/" rel="noopener"> Pods</a> as a network service.</p><p>In the diagram below the <em>service</em> is reachable via 10.245.253.152 on port 8000. The <em>Service</em> will make sure traffic is distributed over all the healthy endpoints for this service.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1455/1*_0YBbv7_koFiZgcHsbZyNg.png" class="kg-image" alt="Global load balancing with Kubernetes and Mysocket.io"></figure><h3 id="taking-your-service-global">Taking your Service Global</h3><p>Now that we know how a service makes your workload available within the cluster, it’s time to take your workload global! Kubernetes has a few ways to do this, typically using an ingress service. We’re going to use the architecture as outlined in the diagram below. We’ll use Mysocket.io to create a secure tunnel between our ‘myApp’ Service and the Mysocket cloud. From there on, it will be globally available via its anycasted edge nodes.</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://cdn-images-1.medium.com/max/2182/1*P7oVKsk2X0xBF53Xbp3Biw.png" class="kg-image" alt="Global load balancing with Kubernetes and Mysocket.io"></figure><p>To make this work, we’ll deploy a controller pod that runs the mysocketd container. The Container Image can be found on <a href="https://hub.docker.com/r/mysocket/mysocketd/tags?page=1&amp;ordering=last_updated" rel="noopener">Docker Hub</a>, and the corresponding Dockerfile on our <a href="https://github.com/mysocketio/kubernetes_controller" rel="noopener">github repo here</a>.</p><p>The mysocketd controller does two things:</p><p>1) it subscribes to the Kubernetes API and listens for events related to <em>services</em>. Specifically, it will watch for <em>service</em> events that have the <em>annotation</em> <strong><em>mysocket.io/enabled</em></strong></p><p>If a service has the following <em>annotation</em> mysocket.io/enabled: “true” then the mysocketd app will start a thread for that service.</p><p>2) In the per service thread, using the Mysocket API, a new mysocket.io “Socket” object is created if needed. This will give the “myApp” service a public DNS name and public IP. Next, it will check with the mysocket.io API to see if a tunnel already exists; if not, then a new one is created.</p><p>Finally, the secure tunnel is established, and the “myApp” service is now globally available and benefits from the mysocket.io high-performance infrastructure.</p><h3 id="demo-time-how-to-deploy-mysocketd-to-your-cluster">Demo time. How to Deploy mysocketd to your cluster</h3><p>The easiest way to get started is to download the <a href="https://github.com/mysocketio/kubernetes_controller/blob/main/mysocketd.yaml" rel="noopener">mysocketd workload yaml </a>file from the <a href="https://github.com/mysocketio/kubernetes_controller" rel="noopener">Mysocket Kubernetes controller repository</a>  and update the following three secrets to the ones for your mysocket account (<a href="https://github.com/mysocketio/kubernetes_controller/blob/main/mysocketd.yaml#L14-L16" rel="noopener">line 14,15,16</a>).</p><pre><code>email: &lt;mysocket login email in base64&gt; 
password: &lt;mysocket password in base64&gt; 
privatekey: &lt;mysocket private ssh key in base64&gt;</code></pre><p>Then simply apply like this and you’re good to go!</p><pre><code class="language-bash">kubectl apply -f mysocketd.yaml</code></pre><p>Cool, now we have the controller running!</p><h4 id="a-simple-demo-work-load">A simple demo work load</h4><p>Next up, we’d like to make our myApp service available to the Internet by using the mysocket.io service. I’m going to use <a href="https://github.com/mysocketio/examples/blob/main/2020-12-21-kubernetes-integration/demo-deploy.yaml" rel="noopener">this deployment</a> as our demo app. The deployment consists of three pods, with a little python web app, printing its hostname.</p><p>Next up, we’ll build a service (<a href="https://github.com/mysocketio/examples/blob/main/2020-12-21-kubernetes-integration/demo-service.yaml" rel="noopener">see definition here</a>) that acts as an in-cluster load balancer for the demo workload, and we’ll request the Service to be enabled for Mysocket.io.</p><pre><code class="language-bash">$ kubectl apply -f demo-deploy.yaml

$ kubectl apply -f demo-service.yaml

$ kubectl get all -n demo-app
NAME                            READY   STATUS    RESTARTS   AGE
pod/demo-app-6896cd4b88-5jzgn   1/1     Running   0          2m22s
pod/demo-app-6896cd4b88-78ngc   1/1     Running   0          2m22s
pod/demo-app-6896cd4b88-pzbc7   1/1     Running   0          2m22s
NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
service/demo-service   ClusterIP   10.245.114.194   &lt;none&gt;        8000/TCP   64s
NAME                       READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/demo-app   3/3     3            3           2m22s
NAME                                  DESIRED   CURRENT   READY   AGE
replicaset.apps/demo-app-6896cd4b88   3         3         3       2m22s</code></pre><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1455/1*Aw8DFTKHqtz6M77I2lKscQ.png" class="kg-image" alt="Global load balancing with Kubernetes and Mysocket.io"><figcaption><strong><em>Simply set mysocket.io/enabled to “true” and your service will be globally available.</em></strong></figcaption></figure><p>The same can be done for existing services: to do so, just edit your existing Service definition and add the “<strong>mysocket,io/enabled</strong>” <em>annotation, </em>like this:</p><pre><code class="language-yaml">kind: Service
metadata:
  annotations:
    mysocket.io/enabled: "true"</code></pre><p>After applying this change, the mysocketd controller will detect that the service has requested to be connected to the Mysocket global infrastructure. The controller will create the Socket and Tunnels as needed and start the tunnel.</p><p>A quick load balancing test shows that requests to our global mysocket endpoint are now being load-balanced over the three endpoints.</p><pre><code class="language-bash">$ for i in {1..60}; do  curl -s \ 
  https://blue-snowflake-1578.edge.mysocket.io/ &amp; ;done | sort | uniq -c | sort -n  
  
  19 Server: demo-app-6896cd4b88-pzbc7  
  20 Server: demo-app-6896cd4b88-5jzgn  
  21 Server: demo-app-6896cd4b88-78ngc  
  60</code></pre><p>Just like that, in a few seconds, your workload is globally available. Pretty neat he!? Make sure to watch the <a href="https://www.youtube.com/watch?v=tFfLfI1jYi4" rel="noopener nofollow">video recording of this demo</a> as well.</p><h3 id="wrapping-up">Wrapping up</h3><p>In this article, we looked at how we can easily connect Kubernetes Services to Mysocket.io. We saw that it was easy to use. All that is needed is to: 1) start the Mysocketd controller, and: 2) add the mysocket annotation to your Services. By doing so, we are giving the Kubernetes service a publicly reachable IP address, a TLS cert, and it instantly benefits from the mysocket.io Anycast infrastructure. Pretty powerful and easy to use.</p><p>I should add that this <a href="https://github.com/mysocketio/kubernetes_controller" rel="noopener">Mysocket Controller for Kubernetes</a> is for now just a starting point, ie. an MVP integration with Kubernetes. There are ways to improve this, both in terms of user-friendliness and high availability (i.e. more than one pod). The code for this Kubernetes integration is open source, and we’d be happy to accept improvements. Mostly it serves as an example of what’s possible and how we can continue to build on the Mysocket services.</p><p>Last but certainly not least, I’d like to thanks <a href="https://github.com/tresni" rel="noopener">Brian</a> for his code to improve the various mysocketctl client libraries. Also, a big thanks to <a href="https://github.com/btoonk" rel="noopener">Bas Toonk</a> (yes, my brother) for his help with this MVP. Most of this was his work, thanks buddy!</p><p>Finally, I hope this sparked your imagination, and you’ll all give it a whirl, and let me know your experience.</p><p><br></p><p><br></p><p><br></p>]]></content:encoded></item><item><title><![CDATA[Easy Multi-region load balancing with Mysocket.io]]></title><description><![CDATA[<p>Last week AWS had a major outage in its US-EAST1 region, lasting for most of the day, just before the big black Friday sales! Incidents like this are a great reminder of the importance of multi-region or even multi-cloud deployments for your services.</p><p>Depending on your “cloud maturity” and your</p>]]></description><link>http://toonk.io/easy-multi-region-load-balancing-with-mysocket/</link><guid isPermaLink="false">5fcd79a451a5ff44fb64d968</guid><category><![CDATA[mysocket]]></category><category><![CDATA[terraform]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Mon, 07 Dec 2020 00:42:46 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1544161519-0690a8886606?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDY2fHx8ZW58MHx8fA&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1544161519-0690a8886606?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxMTc3M3wwfDF8c2VhcmNofDY2fHx8ZW58MHx8fA&ixlib=rb-1.2.1&q=80&w=2000" alt="Easy Multi-region load balancing with Mysocket.io"><p>Last week AWS had a major outage in its US-EAST1 region, lasting for most of the day, just before the big black Friday sales! Incidents like this are a great reminder of the importance of multi-region or even multi-cloud deployments for your services.</p><p>Depending on your “cloud maturity” and your products’ complexity, you may already be there or just getting started. Either way, in today’s blog, we will take a look at how we can use mysocket’s load balancing features to make deployments over multi-region easier.</p><h3 id="a-global-load-balancing-service">A global load balancing service</h3><p>In earlier blogs, we looked mostly at how the mysocket.io tunnel service can help securely connect your resources that may be behind NAT and firewalls to the Internet. In this article, we’ll look at Mysocket’s global load balancing feature.</p><h3 id="three-types-of-load-balancers">Three types of load balancers</h3><p>Mysocket today supports three different types of cloud-native load balancers.</p><p><em>1) Application load balancers, for your HTTP and HTTPS services. </em><br><em>2) Network load balancer, for your TCP services.</em><br><em>3) TLS Load balancer, for your TCP services, where we take care of the encryption.</em></p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://toonk.io/content/images/2020/12/Screen-Shot-2020-12-06-at-2.58.50-PM.png" class="kg-image" alt="Easy Multi-region load balancing with Mysocket.io" srcset="http://toonk.io/content/images/size/w600/2020/12/Screen-Shot-2020-12-06-at-2.58.50-PM.png 600w, http://toonk.io/content/images/size/w1000/2020/12/Screen-Shot-2020-12-06-at-2.58.50-PM.png 1000w, http://toonk.io/content/images/size/w1600/2020/12/Screen-Shot-2020-12-06-at-2.58.50-PM.png 1600w, http://toonk.io/content/images/size/w2400/2020/12/Screen-Shot-2020-12-06-at-2.58.50-PM.png 2400w" sizes="(min-width: 720px) 720px"><figcaption>Load balancer types for mysocket.io&nbsp;</figcaption></figure><blockquote><em>When deploying Mysocket with your services, you now have a new front door. It just happens to be a front door that is anycasted, and as such has many doorbells around the globe made available to you. As a result, you’re always close to your users.</em></blockquote><h3 id="demo-creating-a-multi-region-service-in-two-minutes-">Demo: Creating a multi-region service in two minutes!</h3><p>Alright, time to get building! In this demo, we’ll continue using the Gif service we built in our last blog. Just like your workloads, I think this is a “critical” service, so we need it to be deployed in multiple regions. The service will need a 100% uptime, which means that even if a region is down, the Gif service will need to be available to our users.</p><figure class="kg-card kg-embed-card"><iframe width="459" height="344" src="https://www.youtube.com/embed/N96ghctEhb4?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></figure><h3 id="infrastructure-as-code">Infrastructure as code</h3><p>In this example, we’re going to deploy the service on Digital ocean VM’s in two of its regions, New York and Toronto. We’re big fans of infrastructure as code and require our service to be deployed with a simple deploy script. So we’ll use Terraform to spin up the instances and use a cloud-init script to bootstrap the necessary work to install the required software, start the Gif service and connect it to the Mysocket global infrastructure.</p><h3 id="step-1-terraform">Step 1: terraform</h3><p>We’re using terraform to define what type VM’s we’d like, which regions we want them to be deployed in, and how many per region. For this demo we’re using just two VM’s in two regions. But I’m sure, by just looking at the terraform file, you can see how easy it is to deploy many VM’s per region by just changing the ‘count’ number. It’s also easy to add additional regions. So scaling our Gif service for the future will be easy ;)</p><h3 id="step-2-cloud-init">Step 2: cloud-init</h3><p>The VM’s we’re launching are just vanilla Ubuntu machines. So we’ll need to modify them slightly to get our software and our ‘secrets’ on the machine. To do that, we’ll use cloud-init. <br>Cloud-init allows us to define a set of tasks that need to be executed when the VM is created. In our case, we’re asking it to create a user ‘mysocket’, we’re adding the Giphy API key, and mysocket credentials as secrets to the mysocket home directory. Finally, we’re telling it to download and execute a bootstrap script.</p><h3 id="step-3-bootstrapping-and-starting-our-services-">Step 3: bootstrapping and starting our services.</h3><p>Cloud-init’s last step was to start the bootstrap script that it download from <a href="https://gist.githubusercontent.com/atoonk/37ef0062fc1d90d31e2fc87e8f12d674/raw/ee83755af5214260fc9e6ad18849e77b7c8f7781/lb-do.sh" rel="noopener">here</a>. Basically, all it does is install the two python packages (mysocketctl and giphy_client) and download and start two more programs. The first program is our Gif application, which will run on port 8000. The second program is a small python script that makes sure the VM registers and connects to the mysocket.io infrastructure.</p><p>The code to connect to mysocket is <a href="https://github.com/mysocketio/examples/tree/main/2020-12-06-multi-region" rel="noopener">available on github</a>. It’s pretty easy, and I’m sure it’s low friction to get started with, even if you have limited experience. Below are the most important parts:</p><pre><code class="language-python">#These variables were made available as secrets in cloud Init.
username = os.getenv("email")
password = os.getenv("password")
socket_id = os.getenv("socket_id")

#Login to mysocket API and get a token. We can contruct the Auth header using this token.
token = get_token(username, password)
authorization_header = {
   "x-access-token": token["token"],    
   "accept": "application/json",    
   "Content-Type": "application/json",}
   
# register the service by creating a new tunnel for this VM
tunnel = new_tunnel(authorization_header, socket_id)
# setup the tunnel to mysocket and ready to serve traffic!
ssh_tunnel(port, tunnel["local_port"], ssh_server, ssh_user)</code></pre><blockquote><em>Make sure you take a quick peak at the code, it’s pretty easy to get started with and a good “getting started” example for both terraform and cloud-init.</em></blockquote><p>And with that, we now have four VM’s in two regions. All four VM’s registered with the Mysocket service and are now serving our ‘critical’ Gif app. You can see the demo service yourself here: <a href="https://fluffy-bunny-5697.edge.mysocket.io/" rel="noopener">https://fluffy-bunny-5697.edge.mysocket.io/</a></p><figure class="kg-card kg-image-card"><img src="http://toonk.io/content/images/2020/12/Screen-Shot-2020-12-06-at-4.44.43-PM-1.png" class="kg-image" alt="Easy Multi-region load balancing with Mysocket.io" srcset="http://toonk.io/content/images/size/w600/2020/12/Screen-Shot-2020-12-06-at-4.44.43-PM-1.png 600w, http://toonk.io/content/images/size/w1000/2020/12/Screen-Shot-2020-12-06-at-4.44.43-PM-1.png 1000w, http://toonk.io/content/images/2020/12/Screen-Shot-2020-12-06-at-4.44.43-PM-1.png 1364w" sizes="(min-width: 720px) 720px"></figure><p>The example below shows how the mysocket load balancing service distributes traffic evenly over all four of the origin servers in New York and Toronto.</p><pre><code class="language-bash">$ for i in {1..20}; do  curl -s \
 https://fluffy-bunny-5697.edge.mysocket.io/ | grep Server; 
done | sort | uniq -c

   5 Server: compute-000-nyc1
   5 Server: compute-000-tor1
   5 Server: compute-001-nyc1
   5 Server: compute-001-tor1</code></pre><p></p><p>Horizontally scaling the service is easy; simply change the count number in the <a href="https://github.com/mysocketio/examples/blob/main/2020-12-06-multi-region/main.tf">terraform file,</a> or add / remove regions. Since the VM’s will call the mysocket api on boot, these new VM’s will automatically become part of the load balancing pool. Pretty neat and easy, right?!</p><h3 id="failover-scenarios">Failover scenarios</h3><p>So what happens when a server or region becomes unavailable? There are a few things that make this as painless as possible for users. First, the origin service can de-register itself; this will allow for the most graceful scenario.</p><p>For less graceful scenarios, mysocket load balancers will, after 60 seconds automatically detect that a tunnel has gone down and take the origin out of the load balancing pool. And even during this 60-second degradation before the tunnel is declared down, our load balancers will use a 10 second connect time out when connecting to origin service and automatically fail back to the remaining origins. So, all in all, failures should be hidden as much as possible from your users.</p><h3 id="wrapping-up">Wrapping up</h3><p>In this blog, we looked at how Mysocket can be used as a global load balancer, for your multi-region load deployments. In our demo, we looked at two Digital ocean regions, but this could also be over multiple AWS regions, or even Multi-cloud, with one cluster in AWS, one in Digital Ocean, and throw in some Google cloud for good measure.</p><p>We saw how Mysocket provides users with a global anycasted ingress point and provides seamless load balancing for your services. Best of all, it only took us 90 seconds to get all of this going! I guess it’s fair to say that Mysocket makes going multi-region and even multi-cloud easier.</p>]]></content:encoded></item><item><title><![CDATA[Static DNS names for your mysocket.io services (and a new gif service)]]></title><description><![CDATA[<p>In my last blog post, I announced the <a href="https://mysocket.io ">mysocket.io </a>service and demonstrated how to get started quickly. It’s been great to see people signing up and giving it a spin! Your feedback has been great, motivating, and has helped make the service better already.</p><p>Most users that gave</p>]]></description><link>http://toonk.io/static-dns-names-for-your-sockets-and-a-new-gif-service/</link><guid isPermaLink="false">5fc5be7c51a5ff44fb64d914</guid><category><![CDATA[mysocket]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Tue, 01 Dec 2020 04:14:11 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1531610373189-61a2afd654e4?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDEwfHx8ZW58MHx8fA&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1531610373189-61a2afd654e4?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxMTc3M3wwfDF8c2VhcmNofDEwfHx8ZW58MHx8fA&ixlib=rb-1.2.1&q=80&w=2000" alt="Static DNS names for your mysocket.io services (and a new gif service)"><p>In my last blog post, I announced the <a href="https://mysocket.io ">mysocket.io </a>service and demonstrated how to get started quickly. It’s been great to see people signing up and giving it a spin! Your feedback has been great, motivating, and has helped make the service better already.</p><p>Most users that gave mysocket a try used the <em>mysocketctl connect</em> (aka “quick connect”) feature. This is the easiest way to get started and instantly creates a global socket, great for quick testing. However, when you’re done and exit the program, the “connect” feature cleans up the socket. It’s easy to create new ones, but each time with a different name. Not surprisingly then, that a few users asked the question about sockets with static names.</p><h3 id="static-names-for-your-services">Static names for your services</h3><p>Most residential ISPs give their customers a dynamic IP address (one that changes from time to time) through DHCP. If you have a service you’d like to make available but don’t have a static IP, then this post is for you!</p><p>Perhaps you have a server at home, either a fancy setup, rack-mounted and UPS for emergency power, or perhaps just a modest Raspberry Pi. Either way, you’d like to make this available from the Internet, so you can access it when you’re not at your home network, or perhaps you are home, but your nice cooperate VPN client blocks access to your local network. Or maybe you’d like to make it available to your friend.</p><p>That’s great, but you have two challenges:</p><p>1) the server sits behind NAT, so you can’t simply connect to the server from the Internet.</p><p>2) your ISP gives you dynamic IPs, so every few days/weeks, the IP changes, so it’s hard to keep track of the IP. Ideally, you could use a static name, that no matter your dynamic IP, remains stable.</p><p>So what you’d need is a static DNS name! Good news, that’s the default on the Socket primitive.</p><h2 id="mysocket-primitives">Mysocket primitives</h2><p>Let’s take a more in-depth look at the two main primitives that make up the mysocket service: Sockets and Tunnels</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1455/1*2y4Ngw325mE8T-OPoP5OSw.png" class="kg-image" alt="Static DNS names for your mysocket.io services (and a new gif service)"><figcaption>Socket and Tunnel primitives</figcaption></figure><h3 id="a-global-socket">A Global Socket</h3><p>The first primitive we need is a <em>socket</em> object. This object is the public endpoint for your service and can be created like this:</p><pre><code>mysocketctl socket create \
	--type http \
	--name "my service at home"</code></pre><p>This, among other things, returns a static DNS name that is yours to use. Think of it as your global public endpoint for your load balancer. In this case, mysocket runs the load balancer, and it’s made highly available through our anycast setup.</p><p>In the example above, we created an HTTP/HTTPS socket. Other options are TCP and TLS sockets. In those cases, the API will return not only a static DNS name for your service but also your own dedicated static TCP port number. A typical use case for a TCP socket is making your ssh service available.</p><h3 id="tunnels">Tunnels</h3><p>The second primitive is a tunnel. A tunnel object represents your origin service and the secure connection between the origin and the mysocket global infrastructure. Let’s look at the example below.</p><pre><code>mysocketctl tunnel create \
	--socket_id 1fab407c-a49d-4c5e-8287-8b138b7549c0</code></pre><p>When creating the tunnel object, simply pass along the socket_id from the socket you’d like to be connected to.</p><h3 id="putting-it-together">Putting it together</h3><p>In summary, we can create a globally available service by first creating a socket of type HTTP/HTTPS, TCP or TLS. This returns a static name for your service and optionally a unique port number. After that, we create a tunnel that links the origin to the socket.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1455/1*6FoxMwJ7gMzk3MvjAvufpw.png" class="kg-image" alt="Static DNS names for your mysocket.io services (and a new gif service)"></figure><p>Now that we have created a Socket and Tunnel, it’s time to connect to it, spin up the dataplane, and expose the local service port. We do that using the following command:</p><pre><code>mysocketctl tunnel connect \
	--port 8000 \
	--socket_id 1fab407c-a49d-4c5e-8287-8b138b7549c0 \
	--tunnel_id 3f46a01f-ef5b-4b0c-a1ce-9a294be2be03</code></pre><p>In the example above, we only create one tunnel for the socket, but nothing stops you from creating multiple tunnels (origins) per socket. In that case, mysocket will load balance over all available tunnels.</p><h2 id="demo-time-exposing-a-local-gif-service-to-the-internet">Demo time:<br>exposing a local Gif service to the Internet</h2><p>Alright, time to look at a simple demo and get our hands dirty. For this demo, I developed a small<a href="https://gist.github.com/atoonk/0bfc784feb66ffc03541462fbc945df7#file-gif_service-py" rel="noopener"> proof of concept python web service</a> that shows a random Gif from <a href="https://giphy.com/" rel="noopener">Giphy</a> each time a visitor loads the webpage.</p><p>I’m running this service locally on a VM on my laptop. The goal is to make this service publicly available, and overcoming the two levels of NAT and my ISP that hands out dynamic IP addresses. At the end of this demo, I’m able to share a static DNS name with my users, and you’ll be able to try it!</p><p><strong><em>Watch the video below for a live demo.</em></strong></p><figure class="kg-card kg-embed-card"><iframe width="459" height="344" src="https://www.youtube.com/embed/bZh3vZLCdYM?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></figure><p>First, let’s download the demo python code and start the Gif web service</p><pre><code>wget https://gist.githubusercontent.com/atoonk/0bfc784feb66ffc03541462fbc945df7/raw/812d839f60ea7bfd98a530a3fc549137abe0b329/gif_service.py

#make sure to update the API key in gif_service.py

python3 ./gif_service.py</code></pre><p>Alright, now we have this service running, but it’s only reachable from my local network. Next up, we create a socket and a tunnel.</p><pre><code>mysocketctl socket create \
	--name "my local http Gif service" \ 
	--type http</code></pre><p>Ok, that returns a socket_id and our static DNS name! In my case, the DNS name is: <a href="https://wandering-shape-7752.edge.mysocket.io" rel="noopener">wandering-shape-7752.edge.mysocket.io</a></p><p>Next up, we’ll use the socket_id to create the tunnel object:</p><pre><code>mysocketctl tunnel create \
	--socket_id 1fab407c-a49d-4c5e-8287-8b138b7549c0</code></pre><p>Cool, now all we need to do is start the tunnel connection.</p><pre><code>mysocketctl tunnel connect \
	--port 8000 \
	--socket_id 1fab407c-a49d-4c5e-8287-8b138b7549c0 \
	--tunnel_id 3f46a01f-ef5b-4b0c-a1ce-9a294be2be03</code></pre><p>This will securely connect the local gif web service listening on port 8000, to the mysocket infrastructure and make it available as <a href="https://wandering-shape-7752.edge.mysocket.io/" rel="noopener">https://wandering-shape-7752.edge.mysocket.io</a></p><h3 id="wrapping-up">Wrapping up</h3><p>In this blog post, we looked at the two main mysocket primitives, <em>Sockets</em>, and <em>Tunnels</em>. We saw how users can create a Socket object and get a static DNS name and possibly even a dedicated TCP port. In the demo, we used the <em>tunnel connect</em> feature to make port 8000 on my local VM available to the Internet. With that, we made the Internet a little bit better by adding <a href="http://wandering-shape-7752.edge.mysocket.io/" rel="noopener">yet another Gif service</a>, that just happens to run on a VM hosted on my laptop.</p><p></p><!--kg-card-begin: html--><img src="https://media.giphy.com/media/aaw0ay7NqrucU/source.gif" alt="Static DNS names for your mysocket.io services (and a new gif service)">
<!--kg-card-end: html-->]]></content:encoded></item><item><title><![CDATA[Introducing Mysocket.io]]></title><description><![CDATA[Mysocket is a service that provides users with fast and secure TCP sockets for services that aren’t normally directly reachable from the Internet. Using a simple client, we connect your local services to the Internet.]]></description><link>http://toonk.io/introducing-mysocket-io/</link><guid isPermaLink="false">5fbb2ca251a5ff44fb64d8b7</guid><category><![CDATA[mysocket]]></category><category><![CDATA[anycast]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Mon, 23 Nov 2020 03:40:48 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1519331582073-283f1a211a3e?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<blockquote>In this blog, I’d like to introduce a new project I’m calling Mysocket.io. Before we dive in, a bit of background.</blockquote><img src="https://images.unsplash.com/photo-1519331582073-283f1a211a3e?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Introducing Mysocket.io"><p>Loyal readers know I enjoy building global infrastructure services that need to be able to carry a significant amount of traffic and a large number of requests. Building services like these often require us to solve several challenges. Things to consider include: high availability, scaling, DDoS proofing, monitoring, logging, testing, deployments, user-facing &amp; backend APIs, policy management (user preferences) and distribution, life-cycling, etc. All this while keeping an eye on cost and keeping complexity to a minimum (which really is human, operational cost).</p><p>To experiment with these topics, it’s necessary to have a project to anchor these experiments to. Something I can continuously work on, and while doing so, improve the project as a whole. Now, there are many projects I started over time, but one that I've worked most on recently, and wanted to share with a wider audience, is <a href="https://www.mysocket.io/" rel="noopener"><strong>mysocket.io</strong></a>. A service that provides secure public endpoints for services that are otherwise not publicly reachable.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*43NirbSJ49IN0yPBE5wuAg.png" class="kg-image" alt="Introducing Mysocket.io"></figure><p>A typical example case that <a href="https://mysocket.io" rel="noopener">mysocket.io</a> can help with is a web service running on your laptop, which you’d like to make available to a team member or client. Or ssh access to servers behind NAT or a firewall, like a raspberry pi on your home network or ec2 instances behind NAT.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*yF9ppVXSZcwOz5Rlzh39QQ.png" class="kg-image" alt="Introducing Mysocket.io"><figcaption>make your localhost app available from&nbsp;anywhere</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*E-cZOCwqsH3tOkRjzA-ZJQ.png" class="kg-image" alt="Introducing Mysocket.io"><figcaption>Provide SSH access to your home server behind&nbsp;NAT.</figcaption></figure><h2 id="more-details">More details</h2><p>Alright, a good way to share more details and is to do a quick demo! You can see a brief overview in this video, or even better, try it yourself by simply following the four easy steps below.</p><figure class="kg-card kg-embed-card"><iframe width="459" height="344" src="https://www.youtube.com/embed/lEZX_xCTDlo?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></figure><blockquote>If you’re interested or curious, feel free to give it a spin and let me know what worked or didn’t, or even better, how it can be improved. Getting started will take you just one minute. Just follow these simple steps.</blockquote><pre><code class="language-bash">#Install client, using python's package manager (pip)
pip3 install mysocketctl

#Create account
mysocketctl account create \
    --name "your_name" \
    --email "your_email_address" \
    --password "a_secure_password" \
    --sshkey "$(cat ~/.ssh/id_rsa.pub)"
    
#login
mysocketctl login  \
    --email "your_email_address" \
    --password "a_secure_password" 
    
 
#Launch your first global socket ;)
mysocketctl connect \
    --port 8000 \
    --name "my test service"</code></pre><h2 id="architecture-overview">Architecture overview</h2><p>Ok, so how does it work? The process for requesting a “global socket” starts with an API call. You can do this by directly interfacing with <a href="https://api.mysocket.io/" rel="noopener">the RESTful API</a>, or by using the <a href="https://mysocket.readthedocs.io/en/latest/mysocketctl/mysocket.html" rel="noopener">mysocketctl</a> tool. This returns a global mysocket object, which has a name, port number(s), and some other information.</p><p>Users can now use this socket object to create tunnel objects. These tunnels are then used to connect your local service to the global mysocket.io infrastructure. By stitching these two TCP sessions together, we made your local service globally available.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*L4orGfToNQ3fUgjrZC_3Qw.png" class="kg-image" alt="Introducing Mysocket.io"><figcaption>Creating a Socket, a Tunnel and connecting to mysocket.io</figcaption></figure><p>The diagram below provides a high-level overview of the service data-plane. On the left, we have the origin service. This could be your laptop, your raspberry pi at home, or even a set of containers in a Kubernetes cluster. The origin service can be behind a very strict firewall or even NAT. All it needs is outbound network access. We can then set up a secure encrypted tunnel to any of the mysocket.io servers around the world.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*ePYWcZbw_jzNriOwCThNFQ.png" class="kg-image" alt="Introducing Mysocket.io"><figcaption>Mysocket.io dataplane</figcaption></figure><h2 id="anycast">Anycast</h2><p>The Mysocket.io services use AWS’ global accelerator. With this, I’m making both the tunnel servers and proxy services anycasted. This solves some of the load balancing and high availability challenges. The mysocket tunnel and proxy servers are located in North America, Europe, and Asia.</p><p>Once the tunnel is established, the connection event is signaled to all other nodes in real-time, ensuring that all edge nodes know where the tunnel for the service is.</p><h2 id="documentation">Documentation</h2><p>One of my goals is to make Mysocket super easy to use. One way to do that is to have good documentation. I invite you to check out our readthedocs.io documentation here <a href="https://mysocket.readthedocs.io/en/latest/" rel="noopener">https://mysocket.readthedocs.io/</a></p><p>It’s divided into two sections:</p><ol><li><a href="https://mysocket.readthedocs.io/en/latest/about/about.html" rel="noopener">General information </a>about mysocket.io and some of the concepts.</li><li>Information and user guides for the <a href="https://mysocket.readthedocs.io/en/latest/mysocketctl/mysocket.html" rel="noopener">mysocketctl command-line tool</a>.</li></ol><p>The documentation itself and mysocketctl tool are both <a href="https://github.com/mysocketio" rel="noopener">opensource</a> so feel free to open pull requests or open issues if you have any questions.</p><p>You may have noticed there’s a <a href="https://mysocket.io" rel="noopener">website</a> as well. I wanted to create a quick landing page, so I decided to play with Wix.com. They make it super easy;  I may have gone overboard a bit ;)  All that was clicked together in just one evening, pretty neat.</p><h2 id="more-to-come">More to come</h2><p>There’s a lot more to tell and plenty more geeky details to dive into. More importantly, we can continue to build on this and make it even better (ping me if you have ideas or suggestions)! <br>So stay tuned. That’s the plan for subsequent Blog posts soon, either in this blog or the <a href="https://www.mysocket.io/blog" rel="noopener">mysocket.io blog</a>.</p><p><em>Cheers,</em><br><em> -Andree</em><br></p>]]></content:encoded></item><item><title><![CDATA[AWS and their Billions in IPv4 addresses]]></title><description><![CDATA[<p>Earlier this week, I was doing some work on AWS and wanted to know what IP addresses were being used. Luckily for me, AWS publishes this all here <a href="https://ip-ranges.amazonaws.com/ip-ranges.json" rel="nofollow noopener">https://ip-ranges.amazonaws.com/ip-ranges.json</a>. When you go through this list, you’ll quickly see that AWS has a massive asset</p>]]></description><link>http://toonk.io/aws-and-their-billions-in-ipv4-addresses/</link><guid isPermaLink="false">5f88bf632257c9dcdf92feee</guid><category><![CDATA[aws]]></category><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Tue, 20 Oct 2020 16:01:11 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1572288717056-ea97fb77c71e?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1572288717056-ea97fb77c71e?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="AWS and their Billions in IPv4 addresses"><p>Earlier this week, I was doing some work on AWS and wanted to know what IP addresses were being used. Luckily for me, AWS publishes this all here <a href="https://ip-ranges.amazonaws.com/ip-ranges.json" rel="nofollow noopener">https://ip-ranges.amazonaws.com/ip-ranges.json</a>. When you go through this list, you’ll quickly see that AWS has a massive asset of IPv4 allocations. Just counting quickly I noticed a lot of big prefixes.</p><figure class="kg-card kg-embed-card"><blockquote class="twitter-tweet" data-width="550"><p lang="en" dir="ltr">Ever wondered what all of the AWS network ranges are? You can find them all here:<a href="https://t.co/NBaBF6w0la">https://t.co/NBaBF6w0la</a><br>That&#39;s *a lot* of big prefixes!<br>4x /11, 14x /12, 30x /13, 78x /14, 184x /15, 278x /16</p>&mdash; Andree Toonk, Adelante! (@atoonk) <a href="https://twitter.com/atoonk/status/1316098702260359168?ref_src=twsrc%5Etfw">October 13, 2020</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</figure><p>However, the IPv4 ranges on that list are just the ranges that are in use and allocated today by AWS. Time to dig a bit deeper.</p><h3 id="ipv4-address-acquisitions-by-aws">IPv4 address acquisitions by AWS</h3><p>Over the years, AWS has acquired a lot of IPv4 address space. Most of this happens without gaining too much attention, but there were a few notable acquisitions that I’ll quickly summarize below.</p><h4 id="2017-mit-selling-8-million-ipv4-addresses-to-aws">2017: MIT selling 8 million IPv4 addresses to AWS</h4><p>In 2017 <a href="https://www.internetsociety.org/blog/2017/05/mit-goes-on-ipv4-selling-spree/" rel="noopener">MIT sold half of its 18.0.0.0/8</a> allocation to AWS. This 18.128.0.0/9 range holds about 8 million IPv4 addresses.</p><h4 id="2018-ge-sells-3-0-0-0-8-to-aws">2018: GE sells 3.0.0.0/8 to AWS</h4><p>In 2018 the IPv4 prefix 3.0.0.0/8 was transferred from GE to AWS. With this, AWS became the proud owner of its first /8! That’s sixteen million new IPv4 addresses to feed us hungry AWS customers. <a href="https://news.ycombinator.com/item?id=18407173" rel="nofollow noopener">https://news.ycombinator.com/item?id=18407173</a></p><h4 id="2019-aws-buys-amprnet-44-192-0-0-10">2019: AWS buys AMPRnet 44.192.0.0/10</h4><p>In 2019 AWS bought a /10 from AMPR.org, the Amateur Radio Digital Communications (ARDC). The IPv4 range 44.0.0.0/8 was an allocation made to the Amateur Radio organization in 1981 and known as the AMPRNet. This sell caused a fair bit of discussion, check out the <a href="https://mailman.nanog.org/pipermail/nanog/2019-July/thread.html#102103" rel="noopener">nanog discussion here.</a></p><p>Just this month, it <a href="http://www.southgatearc.org/news/2020/october/sale-of-amateur-radio-amprnet-tcp-ip-addresses.htm" rel="noopener">became public knowledge</a> AWS paid $108 million for this /10. That’s $25.74 per IP address.</p><p>These are just a few examples. Obviously, AWS has way more IP addresses than the three examples I listed here. The IPv4 transfer market is very active. Check out this website to get a sense of all transfers: <a href="https://account.arin.net/public/transfer-log#NRPM-8.3IPv4" rel="noopener">https://account.arin.net/public/transfer-log</a></p><h3 id="all-aws-ipv4-addresses">All AWS IPv4 addresses</h3><p>Armed with the information above it was clear that not all of the AWS owned ranges were in the <a href="https://ip-ranges.amazonaws.com/ip-ranges.json">JSON</a> that AWS published. For example, parts of the 3.0.0.0/8 range are missing. Likely because some of it is reserved for future use.</p><p>I did a bit of digging and tried to figure out how many IPv4 addresses AWS really owns. A good start is the Json that AWS publishes. I then combined that with all the ARIN, APNIC, and RIPE entries for Amazon I could find. A few examples include:<br><br><a href="https://rdap.arin.net/registry/entity/AMAZON-4" rel="nofollow noopener">https://rdap.arin.net/registry/entity/AMAZON-4</a><br><a href="https://rdap.arin.net/registry/entity/AMAZO-4" rel="nofollow noopener">https://rdap.arin.net/registry/entity/AMAZO-4</a><br><a href="https://rdap.arin.net/registry/entity/AT-88-Z" rel="nofollow noopener">https://rdap.arin.net/registry/entity/AT-88-Z</a></p><p>Combining all those IPv4 prefixes, removing duplicates and overlaps by aggregating them results in the following list of unique IPv4 address owned by AWS: <a href="https://gist.github.com/atoonk/b749305012ae5b86bacba9b01160df9f#all-prefixes" rel="nofollow noopener">https://gist.github.com/atoonk/b749305012ae5b86bacba9b01160df9f#all-prefixes</a></p><p>The total number of IPv4 addresses in that list is just over 100 Million (100,750,168). That’s <strong>the equivalent of just over six /8’s,</strong> not bad!</p><p>If we break this down by allocation size, we see the following:</p><pre><code>1x /8     =&gt; 16,777,216 IPv4 addresses
1x /9     =&gt; 8,388,608 IPv4 addresses
4x /10    =&gt; 16,777,216 IPv4 addresses
5x /11    =&gt; 10,485,760 IPv4 addresses
11x /12   =&gt; 11,534,336 IPv4 addresses
13x /13   =&gt; 6,815,744 IPv4 addresses
34x /14   =&gt; 8,912,896 IPv4 addresses
53x /15   =&gt; 6,946,816 IPv4 addresses
182x /16  =&gt; 11,927,552 IPv4 addresses
&lt;and more&gt;</code></pre><p>A complete breakdown can be found here: <a href="https://gist.github.com/atoonk/b749305012ae5b86bacba9b01160df9f#breakdown-by-ipv4-prefix-size" rel="nofollow noopener">https://gist.github.com/atoonk/b749305012ae5b86bacba9b01160df9f#breakdown-by-ipv4-prefix-size</a></p><h3 id="putting-a-valuation-on-aws-ipv4-assets">Putting a valuation on AWS’ IPv4 assets</h3><blockquote>Alright.. this is just for fun…</blockquote><p>Since AWS is (one of) the largest buyers of IPv4 addresses, they have spent a significant amount on stacking up their IPv4 resources. It’s impossible, as an outsider, to know how much AWS paid for each deal. However, we can for fun, try to put a dollar number on AWS’ current IPv4 assets.</p><p>The average price for IPv4 addresses has gone up over the years. From ~$10 per IP a few years back to ~$25 per IP <a href="https://auctions.ipv4.global/" rel="noopener">nowadays</a>. <br>Note that these are market prices, so if AWS would suddenly decide to sell its IPv4 addresses and overwhelm the market with supply, prices would drop. But that won’t happen since we’re all still addicted to IPv4 ;)</p><p>Anyway, let’s stick with $25 and do the math just for fun.</p><pre><code>100,750,168 ipv4 addresses x $25 per IP = $2,518,754,200</code></pre><p>Just<strong> over $2.5 billion worth of IPv4 addresses,</strong> not bad! </p><h3 id="peeking-into-the-future">Peeking into the future</h3><p>It’s clear AWS is working hard behind the scenes to make sure we can all continue to build more on AWS. One final question we could look at is: <em>how much buffer does AWS have?</em> ie. how healthy is their IPv4 reserve?</p><p>According to their <a href="https://ip-ranges.amazonaws.com/ip-ranges.json" rel="noopener">published data</a>, they have allocated roughly 53 Million IPv4 addresses to existing AWS services. We found that all their IPv4 addresses combined equates to approximately 100 Million IPv4 addresses. That means they still have ~47 Million IPv4 addresses, or 47% available for future allocations. That’s pretty healthy! And on top of that, I’m sure they’ll continue to source more IPv4 addresses. The IPv4 market is still hot!</p><p></p>]]></content:encoded></item><item><title><![CDATA[100G networking in AWS, a network performance deep dive]]></title><description><![CDATA[<h3></h3><p>Loyal readers of my blog will have noticed a theme, I’m interested in the continued move to virtualized network functions, and the need for faster networking options on cloud compute. In this blog, we’ll look at the network performance on the juggernaut of cloud computing, AWS.</p><p>AWS is</p>]]></description><link>http://toonk.io/aws-network-performance-deep-dive/</link><guid isPermaLink="false">5f889c6f2257c9dcdf92feb0</guid><category><![CDATA[aws]]></category><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Thu, 15 Oct 2020 19:06:42 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1571864156103-d3c37503b6af?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<h3></h3><img src="https://images.unsplash.com/photo-1571864156103-d3c37503b6af?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="100G networking in AWS, a network performance deep dive"><p>Loyal readers of my blog will have noticed a theme, I’m interested in the continued move to virtualized network functions, and the need for faster networking options on cloud compute. In this blog, we’ll look at the network performance on the juggernaut of cloud computing, AWS.</p><p>AWS is the leader in the cloud computing world, and many companies now run parts of their services on AWS. The question we’ll try to answer in this article is: how well suited is AWS’ ec2 for high throughput network functions.</p><p><em>I’ve decided to experiment with adding a short demo video to this blog. Below you will find a quick demo and summary of this article. Since these videos are new and a bit of an experiment, let me know if you like it.</em></p><figure class="kg-card kg-embed-card"><iframe width="612" height="344" src="https://www.youtube.com/embed/iwe0gL8VBvA?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></figure><h3 id="100g-networking">100G networking</h3><p>It’s already been two years since AWS <a href="https://aws.amazon.com/about-aws/whats-new/2018/11/introducing-amazon-ec2-c5n-instances/" rel="noopener">announced the C5n instances</a>, featuring 100 Gbps networking. I’m not aware of any other cloud provider offering 100G instances, so this is pretty unique. Ever since this was released I wondered exactly what, if any, the constraints were. Can I send/receive 100g line rate (144Mpps)? So, before we dig into the details, let’s just check if we can really get to 100Gbs.</p><figure class="kg-card kg-embed-card kg-card-hascaption"><blockquote class="twitter-tweet" data-width="550"><p lang="en" dir="ltr">this is fun :)  97Gbs <a href="https://t.co/6VdkR2Rlr4">pic.twitter.com/6VdkR2Rlr4</a></p>&mdash; Andree Toonk, Adelante! (@atoonk) <a href="https://twitter.com/atoonk/status/1266037590492241921?ref_src=twsrc%5Etfw">May 28, 2020</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<figcaption>100gbs testing.. We’re gonna need a bigger boat..</figcaption></figure><p>There you have it, I was able to get to 100Gbs between 2 instances! That’s exciting. But there are a few caveats. We’ll dig into all of them in this article, with the aim to understand exactly what’s possible, what the various limits are, and how to get to 100g.</p><h3 id="understand-the-limits">Understand the limits</h3><p>Network performance on Linux is typically a function of a few parameters. Most notably, the number of TX/RX queues available on the NIC (network card). The number of CPU cores, ideally at least equal to the number of queues. The pps (packets per second) limit per queue. And finally, in virtual environments like AWS and GCP, potential admin limits on the instance.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1200/0*JUjZ5NOIWUrey-Xm" class="kg-image" alt="100G networking in AWS, a network performance deep dive"></figure><p>Doing networking in software means that processing a packet (or a batch of them) uses a number of CPU cycles. It’s typically not relevant how many bytes are in a packet. As a result, the best metric to look at is the: pps number (related to our cpu cycle budget). Unfortunately, the pps performance numbers for AWS aren’t published so, we’ll have to measure them in this blog. With that, we should have a much better understanding of the network possibilities on AWS, and hopefully, this saves someone else a lot of time (this took me several days of measuring) ;)</p><h3 id="network-queues-per-instance-type">Network queues per instance type</h3><p>The table below shows the number of NIC queues by ec2 (c5n) Instance type.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*P9_cWmValN63fmRXAWqdqg.png" class="kg-image" alt="100G networking in AWS, a network performance deep dive"></figure><p><em>In the world of ec2, 16 vCPUs on the C5n 4xl instance means 1 Socket, 8 Cores per socket, 2 Threads per core.</em></p><p>On AWS, an Elastic Network Adapter (ENA) NIC has as many queues as you have vCPUs. Though it stops at 32 queues, as you can see with the C5n 9l and C5n 18xl instance.</p><p>Like many things in computing, to make things faster, things are parallelized. We see this clearly when looking at CPU capacity, we’re adding more cores, and programs are written in such a way that can leverage the many cores in parallel (multi-threaded programs).</p><p>Scaling Networking performance on our servers is done largely the same. It’s hard to make things significantly faster, but it is easier to add more ‘workers’, especially if the performance is impacted by our CPU capacity. In the world of NICs, these ‘workers’ are queues. Traffic send and received by a host is load-balanced over the available network queues on the NIC. This load balancing is done by hashing (typically the 5 tuples, protocol, source + destination address, and port number). Something you’re likely familiar with from ECMP.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1200/1*VsV_F3dbhosQXAi9A97mqQ.jpeg" class="kg-image" alt="100G networking in AWS, a network performance deep dive"></figure><blockquote>So queues on a NIC are like lanes on a highway, the more lanes, the more cars can travel the highway. The more queues, the more packets (flows) can be processed.</blockquote><h3 id="test-one-ena-queue-performance">Test one, ENA queue performance</h3><p>As discussed, the network performance of an instance is a function of the number of available queues and cpu’s. So let’s start with measuring the maximum performance of a single flow (queue) and then scale up and measure the pps performance.</p><p>In this measurement, I used two c5n.18xlarge ec2 instances in the same subnet and the same placement zone. The sender is using <a href="https://toonk.io/building-a-high-performance-linux-based-traffic-generator-with-dpdk/index.html" rel="noopener">DPDK-pktgen</a> (igb_uio). The receiver is a stock ubuntu 20.04 LTS instance, using the ena driver.</p><p>The table below shows the TX and RX performance between the two c5n.18xlarge ec2 instances for one and two flows.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*GVmlTopDSacvRFilauWZag.png" class="kg-image" alt="100G networking in AWS, a network performance deep dive"></figure><p>With this, it seems the per queue limit is about 1Mpps. Typically the per queue limit is due to the fact that a single queue (soft IRQ) is served by a single CPU core. Meaning, the per queue performance is limited by how many packets per second a single CPU core can process. So again, what you typically see in virtualized environments is that the number of network queues goes up with the number of cores in the VM. In ec2 this is the same, though it’s maxing out at 32 queues.</p><h3 id="test-two-rx-only-pps-performance">Test two, RX only pps performance</h3><p>Now that we determined that the per queue limit appears to be roughly one million packets per second, it’s natural to presume that this number scales up horizontally with the number of cores and queues. For example, the C5n 18xl comes with 32 nic queues and 72 cores, so in theory, we could naively presume that the (RX/TX) performance (given enough flows) should be 32Mpps. Let’s go ahead and validate that.</p><p>The graph below shows the Transmit (TX) performance as measured on a c5n.18xlarge. In each measurement, I gave the packet generator one more queue and vcpu to work with. Starting with one TX queue and one VCPu, incrementing this by one in each measurement until we reached 32 vCPU and 32 queues (max). The results show that the per TX queue performance varied between 1Mpps to 700Kpps. The maximum total TX performance I was able to get however, was ~8.5Mpps using 12 TX queues. After that, adding more queues and vCPu’s didn’t matter, or actually degraded the performance. So this indicates that the performance scales horizontally (per queue), but does max out at a certain point (varies per instance type), in this case at 8.5 Mpps</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/0*7ATryTmrHyn_Inaj" class="kg-image" alt="100G networking in AWS, a network performance deep dive"><figcaption>c5n.18xlarge per TX queue performance</figcaption></figure><p>In this next measurement, we’ll use two packet generators and one receiver. I’m using two generators, just to make sure the limit we observed earlier isn’t caused by limitations on the packet generator. Each traffic generator is sending many thousands of flows, making sure we leverage all the available queues.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*S8jlTc-v-Krm8BLx1QCGtw.png" class="kg-image" alt="100G networking in AWS, a network performance deep dive"><figcaption>RX pps per C5N instance&nbsp;type</figcaption></figure><p>Alright, after a few minutes of reading (and many, many hours, well really days.. of measurements on my end), we now have a pretty decent idea of the performance numbers. We know how many queues each of the various c5n instance types have.</p><blockquote><strong>We have seen that the per queue limit is roughly 1Mpps. And with the table above, we now see how many packets per second each instance is able to receive (RX)</strong>.</blockquote><h3 id="forwarding-performance">Forwarding performance</h3><p>If we want to use ec2 for virtual network functions, then just receiving traffic isn’t enough. A typical router or firewall should both receive and send traffic at the same time. So let’s take a look at that.</p><p>For this measurement, I used the following setup. Both the traffic generator and receiver were C5n-18xl instances. The Device Under Test (DUT) was a standard Ubuntu 20.04 LTS instance using the ena driver. Since the earlier observed pps numbers weren’t too high, I determined it’s safe to use the regular Linux kernel to forward packets.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*rK_4B6M-0NF2mrrDmheuFQ.png" class="kg-image" alt="100G networking in AWS, a network performance deep dive"><figcaption>test setup</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*UUWrmoLH-MXLMsNBdCvJXg.png" class="kg-image" alt="100G networking in AWS, a network performance deep dive"><figcaption>pps forwarding performance</figcaption></figure><p>The key takeaway from this measurement is that the TX and RX numbers are similar as we’d seen before for the instance types up to (including) the C5n 4xl. For example, earlier we saw the C5n 4xl could receive up to ~3Mpps. This measurement shows that it can do ~3Mpps simultaneously on RX and TX.</p><p>However, if we look at the C5n 9l, we can see it was able to process RX+ TX about 6.2Mpps. Interestingly, earlier we saw it was also able to receive (rx only) ~6Mpps. So it looks like we hit some kind of aggregate limit. We observed a similar limit for the C5n 18xl instance.</p><h3 id="in-summary-">In Summary.</h3><p>In this blog, we looked at the various performance characteristics of networking on ec2. We determined that the <strong>performance of a single queue is roughly 1Mpps</strong>. We then saw how the number of queues goes up with the higher end instances up until <strong>32 queues maximum</strong>.</p><p>We then measure the RX performance of the various instances as well as the forwarding (RX + TX aggregate) performance. Depending on the measurement setup (RX, or TX+RX) we see that <strong>for the largest instance types, the pps performance maxes out at roughly 6.6Mpps to 8.3Mpps</strong>. With that, I think that the C5n 9l hits the sweet spot in terms of cost vs performance.</p><h3 id="so-how-about-that-100g-test">So how about that 100G test?</h3><p>Ah yes! So far, we talked about pps only. How does that translate that to gigabits per second?<br>Let’s look at the quick table below that shows how the pps number translates to Gbs at various packet sizes.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*sXL3CJJ9M955aa8DvRUVyw.png" class="kg-image" alt="100G networking in AWS, a network performance deep dive"></figure><p>These are a few examples to get to 10G at various packet sizes. This shows that in order to support line-rate 10G at the smallest packet size, the system will need to be able to do ~14.88 Mpps. The 366 byte packet size is roughly the equivalent average of what you’ll see with an IMIX test, for which the systems needs to be able to process ~3,4Mpps to get to 10G line rate.</p><p>If we look at the same table but then for 100gbps, we see that at the smallest packet size, an instance would need to be able to process is over 148Mpps. But using 9k jumbo frames, you only need 1.39Mpps.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*WbChAl1uTuUMnP6oHFzRhg.png" class="kg-image" alt="100G networking in AWS, a network performance deep dive"></figure><p>And so, that’s what you need to do to get to 100G networking in ec2. Use Jumbo frames (supported in ec2, in fact, for the larger instances, this was the default). With that and a few parallel flows you’ll be able to get to 100G “easily”!</p><h3 id="a-few-more-limits">A few more limits</h3><p>One more limitation I <a href="https://cloudonaut.io/ec2-network-performance-cheat-sheet/" rel="noopener">read about while researching</a>, but didn’t look into myself. It appears that some of the instances have time-based limits on the performance. This <a href="https://www.bluematador.com/blog/ec2-packets-per-second-guaranteed-throughput-vs-best-effort" rel="noopener">blog</a> calls it Guaranteed vs. Best Effort. Basically, you’re allowed to burst for a while, but after a certain amount of time, you’ll get throttled. Finally, there is a per-flow limit of 10Gbs. So if you’re doing things like IPSEC, GRE, VXLAN, etc, note that you will never go any faster than 10g.</p><h3 id="closing-thoughts">Closing thoughts</h3><p>Throughout this blog, I mentioned the word ‘limits’ quite a bit, which has a bit of a negative connotation. However, it’s important to keep in mind that AWS is a multi-tenant environment, and it’s their job to make sure the user experience is still as much as possible as if the instance is dedicated to you. So you can also think of them as ‘guarantees’. AWS will not call them that, but in my experience, the throughput tests have been pretty reproducible with, say a +/- 10% measurement margin.</p><p>All in all, it’s pretty cool to be able to do 100G on AWS. As long as you are aware of the various limitations, which unfortunately aren’t well documented. Hopefully, this article helps some of you with that in the future. <br>Finally, could you use AWS to run your virtual firewalls, proxies, VPN gateways, etc? Sure, as long as you’re aware of the performance constraints. And with that design a horizontally scalable design, according to AWS best practices. The one thing you really do need to keep an eye on is the (egress) bandwidth pricing, which, when you started doing many gigabits per second, can add up.</p><p><em>Cheers</em><br><em>- Andree</em></p><p><br></p>]]></content:encoded></item><item><title><![CDATA[Building a global anycast service in under a minute]]></title><description><![CDATA[<p>This weekend I decided to take another look at Stackpath and their workload edge compute features. This is a relatively new feature, in fact, <a href="https://medium.com/@atoonk/experimenting-with-stackpath-edge-computing-and-anycast-f335ba86e60d?source=friends_link&amp;sk=ab2c1ae803a9f3ed314624f4545edde4" rel="noopener">I wrote about it in Feb 2109 when it was just released</a>. I remember being quite enthusiastic about the potential but also observed some things that</p>]]></description><link>http://toonk.io/building-a-global-anycast-service-in-under-a-minute/</link><guid isPermaLink="false">5f531ce73680d46e73ec5fdf</guid><category><![CDATA[terraform]]></category><category><![CDATA[anycast]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Sun, 21 Jun 2020 05:15:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1527685216219-c7bee79b0089?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1527685216219-c7bee79b0089?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Building a global anycast service in under a minute"><p>This weekend I decided to take another look at Stackpath and their workload edge compute features. This is a relatively new feature, in fact, <a href="https://medium.com/@atoonk/experimenting-with-stackpath-edge-computing-and-anycast-f335ba86e60d?source=friends_link&amp;sk=ab2c1ae803a9f3ed314624f4545edde4" rel="noopener">I wrote about it in Feb 2109 when it was just released</a>. I remember being quite enthusiastic about the potential but also observed some things that were lacking back then. Now, one and a half years later, it seems most of those have been resolved, so let’s take a look!</p><blockquote><em><em>I’ve decided to experiment with adding a small demo video to these blogs.</em></em><br><em><em>Below you will find a quick 5min demo of the whole setup. Since these videos are new and a bit of an experiment, let me know if you like it.</em></em></blockquote><figure class="kg-card kg-embed-card kg-card-hascaption"><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FoP3_wearfo0%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DoP3_wearfo0&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FoP3_wearfo0%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" allowfullscreen frameborder="0" height="480" width="640" title="Building a global anycast service in under a minute" class="s t u kq ai" scrolling="auto" style="box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 510px;"></iframe><figcaption>Demo: Building a global anycast service in under a minute</figcaption></figure><h1 id="workloads">Workloads</h1><p>Stackpath support two types of workloads (in addition to serverless), VM and container-based deployments. Both can be orchestrated using API’s and Terraform. Terraform is an “Infrastructure as code” tool. You simply specify your intent with Terraform, apply it, and you’re good to go. I’m a big fan of Terraform, so we’ll use that for our test.</p><p>One of the cool things about Stackpath is that they have built-in support for Anycast, for both their VM and Container service. I’m going to use that feature and the Container service to build this highly available, low latency web service. It’s super easy, see for your self <a href="https://github.com/atoonk/stackpath-anycast-terraform" rel="noopener nofollow">on my github here</a>.</p><h1 id="docker-setup">Docker setup</h1><p>Since I’m going to use the container service, we need to create a Docker container to work with. This is my <a href="https://github.com/atoonk/stackpath-anycast-terraform/blob/master/container/Dockerfile" rel="noopener nofollow">Dockerfile</a></p><!--kg-card-begin: markdown--><pre><code>FROM python:3
WORKDIR /usr/src/app
COPY ./mywebserver.py .
EXPOSE 8000
ENV PYTHONUNBUFFERED 1
CMD [ “python”, “./mywebserver.py” ]</code></pre>
<!--kg-card-end: markdown--><p>The <a href="https://github.com/atoonk/stackpath-anycast-terraform/blob/master/container/mywebserver.py" rel="noopener nofollow"><em><em>mywebserver.py</em></em></a> program is a simple web service that prints the hostname environment variable. This will help us determine which node is servicing our request when we start our testing.</p><p>After I built the container, I uploaded it to my <a href="https://hub.docker.com/repository/docker/atoonk/pythonweb" rel="noopener nofollow">Dockerhub</a> repo, so that Stackpath can pull it from there.</p><h1 id="terraform">Terraform</h1><p>Now it’s time to define our infrastructure using terraform. The relevant code can be found on my <a href="https://github.com/atoonk/stackpath-anycast-terraform/blob/master/container/main.tf" rel="noopener nofollow">github here</a>. I’ll highlight a few parts:</p><p>On line 17 we start with defining a new workload, and I’m requesting an Anycast IP for this workload. This means that Stackpath will load balance (ECMP) between all nodes in my workload (which I’m defining later).</p><!--kg-card-begin: markdown--><pre><code>resource “stackpath_compute_workload” “my-anycast-workload” {   
    name = “my-anycast-workload”
    slug = “my-anycast-workload”   
    annotations = {       
        # request an anycast IP       
        “anycast.platform.stackpath.net” = “true”   
    }
</code></pre>
<!--kg-card-end: markdown--><p>On line 31, we define the type of workload, in this case, a container. As part of that we’re opening the correct ports, in my case port 8000 for the python service.</p><!--kg-card-begin: markdown--><pre><code>container {   
    # Name that should be given to the container   
    name = “app”   
    port {      
        name = “web”      
        port = 8000      
        protocol = “TCP”      
        enable_implicit_network_policy = true   
    }
</code></pre>
<!--kg-card-end: markdown--><p>Next up we define the container we’d like to deploy (from Dockerhub)</p><!--kg-card-begin: markdown--><pre><code># image to use for the container
image = “atoonk/pythonweb:latest”
</code></pre>
<!--kg-card-end: markdown--><p>In the resources section we define the container specifications. In my case I’m going with a small spec, of one CPU core and 2G of ram.</p><!--kg-card-begin: markdown--><pre><code>resources {
   requests = {
      “cpu” = “1”
      “memory” = “2Gi”
   }
}
</code></pre>
<!--kg-card-end: markdown--><p>We now get to the section where we define how many containers we’d like per datacenter and in what datacenters we’d like this service to run.</p><p>In the example below, we’re deploying three containers in each datacenter, with the possibility to grow to four as part of auto-scaling. We’re deploying this in both Seattle and Dallas.</p><!--kg-card-begin: markdown--><pre><code>target {
    name         = &quot;global&quot;
    min_replicas = 3
    max_replicas = 4
    scale_settings {
      metrics {
        metric = &quot;cpu&quot;
        # Scale up when CPU averages 50%.
        average_utilization = 50
      }
    }
    # Deploy these instances to Dallas and Seattle
    deployment_scope = &quot;cityCode&quot;
    selector {
      key      = &quot;cityCode&quot;
      operator = &quot;in&quot;
      values   = [
        &quot;DFW&quot;, &quot;SEA&quot;
      ]
    }
  }
</code></pre>
<!--kg-card-end: markdown--><h1 id="time-to-bring-up-the-service-">Time to bring up the service.</h1><p>Now that we’ve defined our intent with terrraform, it’s time to bring this up. The proper way to do this is:</p><!--kg-card-begin: markdown--><pre><code>terraform init
terraform plan
terraform apply</code></pre>
<!--kg-card-end: markdown--><blockquote><em><em>After that, you’ll see the containers come up, and our anycasted python service will become available. Since the containers come up rather quickly, you should have all six containers in the two datacenters up and running in under a minute.</em></em></blockquote><h1 id="testing-the-load-balancing-">Testing the load balancing.</h1><p>I’ve deployed the service in both Seattle and Dallas, and since I am based in Vancouver Canada, I expect to hit the Seattle datacenter as that is the closest datacenter for me.</p><!--kg-card-begin: markdown--><pre><code class="language-bash">$ for i in `seq 1 10`; do curl 185.85.196.41:8000 ; done

my-anycast-workload-global-sea-2
my-anycast-workload-global-sea-0
my-anycast-workload-global-sea-2
my-anycast-workload-global-sea-0
my-anycast-workload-global-sea-1
my-anycast-workload-global-sea-1
my-anycast-workload-global-sea-2
my-anycast-workload-global-sea-1
my-anycast-workload-global-sea-2
my-anycast-workload-global-sea-0</code></pre>
<!--kg-card-end: markdown--><p>The results above show that I am indeed hitting the Seattle datacenter, and that my requests are being load balanced over the three instances in Seattle, all as expected.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://toonk.io/content/images/2020/09/image.png" class="kg-image" alt="Building a global anycast service in under a minute" srcset="http://toonk.io/content/images/size/w600/2020/09/image.png 600w, http://toonk.io/content/images/size/w1000/2020/09/image.png 1000w, http://toonk.io/content/images/2020/09/image.png 1400w" sizes="(min-width: 720px) 720px"><figcaption>In the portal, I can see the per container logs as well</figcaption></figure><h1 id="in-summary">In Summary</h1><p>Compared to <a href="https://medium.com/@atoonk/experimenting-with-stackpath-edge-computing-and-anycast-f335ba86e60d?source=friends_link&amp;sk=ab2c1ae803a9f3ed314624f4545edde4" rel="noopener">my test last year </a>with Stackpath, there has been a nice amount of progress. It’s great to now be able to do all of this with just a Terraform file. It’s kind of exciting you can bring up a fully anycast service in under a minute with only one command! By changing the replicate number in the Terraform file we can also easily grow and shrink our deployment if needed.<br>In this article we looked at the container service only, but the same is possible with Virtual machines, my github repo has an example for that as well.</p><p><em><em>Finally, don’t forget to check the </em></em><a href="https://youtu.be/oP3_wearfo0" rel="noopener nofollow"><em><em>demo recording </em></em></a><em><em>and let me know if you’d like to see more video content.</em></em></p>]]></content:encoded></item><item><title><![CDATA[Building an XDP (eXpress Data Path) based BGP peering router]]></title><description><![CDATA[<p>Over the last few years, we’ve seen an increase in projects and initiatives to speed up networking in Linux. Because the Linux kernel is slow when it comes to forwarding packets, folks have been looking at userland or kernel bypass networking. In the last few blog posts, we’ve</p>]]></description><link>http://toonk.io/building-an-xdp-express-data-path-based-bgp-peering-router/</link><guid isPermaLink="false">5f53ccd83680d46e73ec6039</guid><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Sun, 19 Apr 2020 00:00:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1555496710-2660a86c4557?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1555496710-2660a86c4557?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Building an XDP (eXpress Data Path) based BGP peering router"><p>Over the last few years, we’ve seen an increase in projects and initiatives to speed up networking in Linux. Because the Linux kernel is slow when it comes to forwarding packets, folks have been looking at userland or kernel bypass networking. In the last few blog posts, we’ve looked at examples of this, mostly leveraging DPDK to speed up networking. The trend here is, let’s just take networking away from the kernel and process them in userland. Great for speed, not so great for all the Kernel network stack features that now have to be re-implemented in userland.</p><p>The Linux Kernel community has recently come up with an alternative to userland networking, called XDP, Express data path, it tries to strike a balance between the benefits of the kernel and faster packet processing. In this article, we’ll take a look at what it would take to build a Linux router using XDP. We will go over what XDP is, how to build an XDP packet forwarder combined with a BGP router, and of course, look at the performance.</p><h1 id="xdp-express-data-path-">XDP (eXpress Data Path)</h1><p>XDP (eXpress Data Path) is an eBPF based high-performance data path merged in the Linux kernel since version 4.8. Yes, BPF, the same Berkeley packet filter as you’re likely familiar with from tcpdump filters, though that’s now referred to as Classic BPF. Enhanced BPF has gained a lot of popularity over the last few years within the Linux community. BPF allows you to connect to Linux kernel hook points, each time the kernel reaches one of those hook points, it can execute an eBPF program. I’ve heard some people describe eBPF as what Java script was for the web, an easy way to enhance the ’web’, or in this case, the kernel. With BPF you can execute code without having to write kernel modules. XDP, as part of the BPF family, operates early on in the Kernel network code. The idea behind XDP is to add an early hook in the RX path of the kernel and let a user-supplied eBPF program decide the fate of the packet. The hook is placed in the NIC driver just after the interrupt processing and before any memory allocation needed by the network stack itself. So all this happens before an SKB (the most fundamental data structure in the Linux networking code) is allocated. Practically this means this is executed before things like tc and iptables.</p><p>A BPF program is a small virtual machine, perhaps not the typical virtual machines you’re familiar with, but a tiny (RISC register machine) isolated environment. Since it’s running in conjunction with the kernel, there are some protective measures that limit how much code can be executed and what it can do. For example, it can not contain loops (only bounded loops), there are a limited number of eBPF instructions and helper functions. The maximum instruction limit per program is restricted to 4096 BPF instructions, which, by design, means that any program will terminate quickly. For kernel newer than 5.1, this limit was lifted to 1 million BPF instructions.</p><h1 id="when-and-where-is-the-xdp-code-executed">When and Where is the XDP code executed</h1><p>XDP programs can be attached to three different points. The fastest is to have it run on the NIC itself, for that you need a smartnic and is called offload mode. To the best of my knowledge, this is currently only supported on Netronome cards. The next attachment opportunity is essentially in the driver before the kernel allocates an SKB. This is called “native” mode and means you need your driver to support this, luckily <a href="https://github.com/xdp-project/xdp-project/blob/master/areas/drivers/README.org" rel="noopener nofollow">most popular drivers do nowadays</a>.</p><p>Finally, there is SKB or Generic Mode XDP, where the XDP hook is called from <em><em>netif _ receive _ skb()</em></em>, this is after the packet DMA and skb allocation are completed, as a result, you lose most of the performance benefits.</p><p>Assuming you don’t have a smartnic, the best place to run your XDP program is in native mode as you’ll really benefit from the performance gain.</p><h1 id="xdp-actions">XDP actions</h1><p>Now that we know that XDP code is an eBPF C program, and we understand where it can run, now let’s take a look at what you can do with it. Once the program is called, it receives the packet context and from that point on you can read the content, update some counters, potentially modify the packet, and then the program needs to terminate with one of 5 XDP actions:</p><p><strong><strong>XDP_DROP</strong></strong><br>This does exactly what you think it does; it drops the packet and is often used for XDP based firewalls and DDOS mitigation scenarios.<br><strong><strong>XDP_ABORTED</strong></strong><br>Similar to DROP, but indicates something went wrong when processing. This action is not something a functional program should ever use as a return code.<br><strong><strong>XDP_PASS</strong></strong><br>This will release the packet and send it up to the kernel network stack for regular processing. This could be the original packet or a modified version of it.<br><strong><strong>XDP_TX</strong></strong><br>This action results in bouncing the received packet back out the same NIC it arrived on. This is usually combined with modifying the packet contents, like for example, rewriting the IP and Mac address, such as for a one-legged load balancer.<br><strong><strong>XDP_REDIRECT</strong></strong><br>The redirect action allows a BPF program to redirect the packet somewhere else, either a different CPU or different NIC. We’ll use this function later to build our router. It is also used to implement AF_XDP, a new socket family that solves the highspeed packet acquisition problem often faced by virtual network functions. AF_XDP is, for example, used by IDS’ and now also supported by Open vSwitch.</p><h1 id="building-an-xdp-based-high-performant-router">Building an XDP based high performant router</h1><p>Alright, now that we have a better idea of what XDP is and some of its capabilities, let’s start building! My goal is to build an XDP program that forwards packets at line-rate between two 10G NICs. I also want the program to use the regular Linux routing table. This means I can add static routes using the “ip route” command, but it also means I could use an opensource BGP daemon such as Bird or FRR.</p><p>We’ll jump straight to the code. I’m using the excellent XDP tutorial code to get started.<a href="https://github.com/atoonk/xdp-tutorial/blob/master/packet-solutions/xdp_prog_kern_03.c#L225-L320" rel="noopener nofollow"> I forked it here</a>, but it’s mostly the same code as the original. This is an example called “xdp_router” and uses the <em><em>bpf_fib_lookup()</em></em> function to determine the egress interface for a given packet using the Linux routing table. The program then uses the action <em><em>bpf_redirect_map()</em></em> to send it out to the correct egress interface. <a href="https://github.com/atoonk/xdp-tutorial/blob/master/packet-solutions/xdp_prog_kern_03.c#L225-L335" rel="noopener nofollow">You can see code here</a>. It’s only a hundred lines of code to do all the work.</p><p>After we compile the code (just run make in the parent directory), we load the code using the <em><em>./xdp_loader</em></em> program included in the repo and use the .<em><em>/xdp_prog_user</em></em> program to populate and query the redirect_params maps.</p><pre><code>#pin BPF resources (redirect map) to a persistent filesystem
mount -t bpf bpf /sys/fs/bpf/

# attach xdp_router code to eno2
./xdp_loader -d eno2 -F — progsec xdp_router

# attach xdp_router code to eno4
./xdp_loader -d eno4 -F — progsec xdp_router

# populate redirect_params maps
./xdp_prog_user -d eno2
./xdp_prog_user -d eno4</code></pre><h1 id="test-setup">Test setup</h1><p>So far, so good, we’ve built an XDP based packet forwarder! For each packet that comes in on either network interface eno2 or eno4 it does a route lookup and redirects it to the correct egres interface, all in eBPF code. All in a hundred lines of code, Pretty awesome, right?! Now let’s measure the performance to see if it’s worth it. Below is the test setup.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://toonk.io/content/images/2020/09/image-1.png" class="kg-image" alt="Building an XDP (eXpress Data Path) based BGP peering router" srcset="http://toonk.io/content/images/size/w600/2020/09/image-1.png 600w, http://toonk.io/content/images/size/w1000/2020/09/image-1.png 1000w, http://toonk.io/content/images/2020/09/image-1.png 1400w" sizes="(min-width: 720px) 720px"><figcaption>test setup</figcaption></figure><p>I’m using <a href="https://medium.com/@atoonk/building-a-high-performance-linux-based-traffic-generator-with-dpdk-93bb9904416c?source=friends_link&amp;sk=fb002771094f1f79654ec9a8be5761c7" rel="noopener">the same traffic generator as before </a>to generate 14Mpps at 64Bytes for each 10G link. Below are the results:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://toonk.io/content/images/2020/09/image-2.png" class="kg-image" alt="Building an XDP (eXpress Data Path) based BGP peering router" srcset="http://toonk.io/content/images/size/w600/2020/09/image-2.png 600w, http://toonk.io/content/images/size/w1000/2020/09/image-2.png 1000w, http://toonk.io/content/images/2020/09/image-2.png 1400w" sizes="(min-width: 720px) 720px"><figcaption>XDP forwarding Test results</figcaption></figure><p>The results are amazing! A single flow in one direction can go as high as 4.6 Mpps, using one core. Earlier, we saw the Linux kernel can go as high as 1.4Mpps for one flow using one core.</p><p>14Mpps in one direction between the two NICs require four cores. Our earlier blog showed that the regular kernel would need 16 cores to do this work!</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="http://toonk.io/content/images/2020/09/image-3.png" class="kg-image" alt="Building an XDP (eXpress Data Path) based BGP peering router" srcset="http://toonk.io/content/images/size/w600/2020/09/image-3.png 600w, http://toonk.io/content/images/size/w1000/2020/09/image-3.png 1000w, http://toonk.io/content/images/2020/09/image-3.png 1600w" sizes="(min-width: 1200px) 1200px"><figcaption>Test result — XDP forwarding using XDP_REDIRECT, 5 cores to forward 29Mpps</figcaption></figure><p>Finally, for the bidirectional 10,000 flow test, forwarding 28Mpps, we need five cores. All tests are significantly faster than forwarding packets using the regular kernel and all that with minor changes to the system.</p><h2 id="just-so-you-know">Just so you know</h2><p>Since all packet forwarding happens in XDP, packets redirected by XDP won’t be visible to IPtables or even tcpdump. Everything happens before packets even reach that layer, and since we’re redirecting the packet, it never moves up higher the stack. So if you need features like ACLs or NAT, you will have to implement that in XDP (take a look at <a href="https://cilium.io/" rel="noopener nofollow">https://cilium.io/</a>).</p><p></p><!--kg-card-begin: markdown--><p><strong>A word on measuring cpu usage.</strong><br>
To control and measure the number of CPU cores used by XDP, I’m changing the number of queues the NIC can use. I increase the number of queues on my XL710 Intel NIC incrementally until I get a packet loss-free transfer between the two ports on the traffic generator. For example, to get 14Mpps in one direction from port 0 to 1 on the traffic generator through our XDP router, which was forwarding between eno2 and eno4, I used the following settings:</p>
<pre><code>ethtool -L eno2 combined 4
ethtool -L eno4 combined 4</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>For the 28Mpps testing, I used the following</p>
<pre><code>ethtool -L eno2 combined 4
ethtool -L eno4 combined 4</code></pre>
<!--kg-card-end: markdown--><blockquote><em><em><strong>A word of caution</strong></em></em><br><em><em>Interestingly, increasing the number of queues, and thus using more cores, appears to, in some cases, have a negative impact on the efficiency. Ie. I’ve seen scenarios when using 30 queues, where the unidirectional 14mps test with 10,000 flows appear to use almost no CPU (between 1 and 2) while the same test bidirectionally uses up all 30 cores. When restarting this test, I see some inconsistent behavior in terms of CPU usage, so not sure what’s going on, I will need to spend a bit more time on this later.</em></em></blockquote><h1 id="xdp-as-a-peering-router"><strong>XDP as a peering router</strong></h1><p>The tests above show promising results, but one major difference between a simple forwarding test and a real life peering router is the number of routes in the forwarding table. So the questions we need to answer was how the <em><em>bpf_fib_lookup</em></em> function will perform when there are more than just a few routes in the routing table. More concretely, <strong><strong><em><em>could you use Linux with XDP as a full route peering router?</em></em></strong></strong><br>To answer this question, I installed <a href="https://bird.network.cz/" rel="noopener nofollow">bird</a> as a bgp daemon on the XDP router. Bird has a peering session with an <a href="https://github.com/Exa-Networks/exabgp" rel="noopener nofollow">exabgp</a> instance, which I loaded with a full routing table using <a href="https://github.com/t2mune/mrtparse/blob/master/examples/mrt2exabgp.py" rel="noopener nofollow">mrt2exabgp.py</a> and a MRT files from <a href="https://www.ripe.net/analyse/internet-measurements/routing-information-service-ris/ris-raw-data" rel="noopener nofollow">RIPE RIS</a>.<br>Just to be a <em><em>real</em></em> peering router, I also filtered out the RPKI invalid routes using <a href="https://github.com/job/rtrsub" rel="noopener nofollow">rtrsub</a>. The end result is a full routing table with about 800k routes in the Linux FIB.</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="http://toonk.io/content/images/2020/09/image-4.png" class="kg-image" alt="Building an XDP (eXpress Data Path) based BGP peering router" srcset="http://toonk.io/content/images/size/w600/2020/09/image-4.png 600w, http://toonk.io/content/images/size/w1000/2020/09/image-4.png 1000w, http://toonk.io/content/images/size/w1600/2020/09/image-4.png 1600w, http://toonk.io/content/images/2020/09/image-4.png 2000w" sizes="(min-width: 1200px) 1200px"><figcaption>Test result — XDP router with a ful routing table. 5 cores to forward 28Mpps</figcaption></figure><blockquote>After re-running the performance tests with 800k bgp routes in the FIB, I observed <strong><em>no noticeable decrease in performance</em></strong>.</blockquote><blockquote>This indicates that a larger FIB table has no measurable impact on the XDP helper <em>bpf_fib_lookup</em>(). This is exciting news for those interested in a cheap and fast peering router.</blockquote><h2 id="conclusion-and-closing-thoughts-">Conclusion and closing thoughts.</h2><p>We started the article with a quick introduction to eBPF and XDP. We learned that XDP is a subset of the recent eBPF developments focused specifically on the hooks in the network stack. We went over the different XDP actions and introduced the redirect action, which, together with the bpf_fib_lookup helper allows us to build the XDP router.</p><p>When looking at the performance, we see this we can speed up <a href="https://medium.com/@atoonk/linux-kernel-and-measuring-network-throughput-547c3b68c4d2?source=friends_link&amp;sk=b8a74c58f8b7a0d998a8796410b3fb96">packet forwarding in Linux</a> by roughly five times in terms of CPU efficiency compared to regular kernel forwarding. We observed we needed about five cores to forward 28Mpps bidirectional between two 10G NICs.</p><p>When we compare these results with the results from my last blog,<a href="https://medium.com/swlh/kernel-bypass-networking-with-fd-io-and-vpp-fc3a53a669f9?source=friends_link&amp;sk=ab92fa42f7ffdfb6dca39ae9601f3d3e"> DPDK and VPP</a>, we see that XDP is slightly slower, ie. 3 cores (vpp) vs 5 cores (XDP) for the 28Mpps test. However, the nice part about working with XDP was that I was able to leverage the Linux routing table out of the box, which is a major advantage.</p><p>The exciting part is that this setup integrates natively with Netlink, which allowed us to use Bird, or really any other routing daemon, to populate the FIB. We also saw that the impact of 800K routes in the fib had no measurable impact on the performance.</p><blockquote>The fib_lookup helper function allowed us to build a router and leverage well-known userland routing daemons. I would love to also see a similar helper function for conntrack, or perhaps some other integration with Netfilter. It would make building firewalls and perhaps even NAT a lot easier. Punting the first packet to the kernel, and subsequent packets are handled by XDP.</blockquote><blockquote>Wrapping up, we started with the question can we build a high performant peering router using XDP? The answer is yes! You can build a high performant peering router using just Linux and relying on XDP to accelerate the dataplane. While leveraging the various open-source routing daemons to run your routing protocols. That’s exciting!</blockquote><blockquote>Cheers<br> -Andree</blockquote>]]></content:encoded></item><item><title><![CDATA[Kernel bypass networking with FD.io and VPP.]]></title><description><![CDATA[In this blog, we’ll look at VPP, a fast, flexible, and open-source network forwarding plane. I think you will be blown away by the performance numbers.]]></description><link>http://toonk.io/kernel-bypass-networking-with-fd-io-and-vpp/</link><guid isPermaLink="false">5f53d4c53680d46e73ec6097</guid><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Sun, 05 Apr 2020 18:14:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1514900417871-7912cae3d726?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1514900417871-7912cae3d726?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Kernel bypass networking with FD.io and VPP."><p></p><p>Over the last few years, I have experimented with various flavors of userland, kernel-bypass networking. In this article, we’ll take <a href="https://fd.io/" rel="noopener">FD.IO</a> for a spin.</p><p>We will compare the result with the results of my <a href="https://medium.com/@atoonk/linux-kernel-and-measuring-network-throughput-547c3b68c4d2?source=friends_link&amp;sk=b8a74c58f8b7a0d998a8796410b3fb96">last blog</a> in which we looked at how much a vanilla Linux kernel could do in terms of forwarding (routing) packets. We observed that on Linux, to achieve 14Mpps we needed roughly 16 and 26 cores for a unidirectional and bidirectional test. In this article, we’ll look at what we need to accomplish this with FD.io</p><h3 id="userland-networking">Userland networking</h3><p>The principle of Userland networking is that the networking stack is no longer handled by the kernel, but instead by a userland program. The Linux kernel is incredibly feature-rich, but for fast networking, it also requires a lot of cores to deal with all the (soft) interrupts. Several of the userland networking projects rely on DPDK to achieve incredible numbers. One reason why DPDK is so fast is that it doesn’t rely on Interrupts. Instead, it’s a poll mode driver. Meaning it’s continuously spinning at 100% picking up packets from the NIC. A typical server nowadays comes with quite a few CPU cores, and dedicating one or more cores for picking packets of the NIC is, in some cases, entirely worth it. Especially if the server needs to process lots of network traffic.</p><p>So DPDK provides us with the ability to efficiently and extremely fast, send and receive packets. But that’s also it! Since you’re not using the kernel, we now need a program that takes the packets from DPDK and does something with it. Like for example, a virtual switch or router.</p><h3 id="fd-io">FD.IO</h3><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1200/1*xnuX9v2emwe179_6PGIp7g.png" class="kg-image" alt="Kernel bypass networking with FD.io and VPP."></figure><p><a href="https://fd.io/" rel="noopener">FD.IO</a> is an open-source software dataplane developed by Cisco. At the heart of FD.io is something called Vector Packet Processing (VPP).</p><p>The VPP platform is an <a href="https://fd.io/vppproject/vpptech/" rel="noopener">extensible framework </a>that provides switching and routing functionality. VPP is built on a ‘packet processing graph.’ This modular approach means that anyone can ‘plugin’ new graph nodes. This makes extensibility rather simple, and it means that plugins can be customized for specific purposes.</p><p>FD.io can use DPDK as the drivers for the NIC and can then process the packets at a high performant rate that can run on commodity CPU. It’s important to remember that it is not a fully-featured router, ie. it doesn’t really have a control plane; instead, it’s a forwarding engine. Think of it as a router line-card, with the NIC and the DPDK drivers as the ports. VPP allows us to take a packet from one NIC to another, transform it if needed, do table lookups, and send it out again. There are API’s that allow you to manipulate the forwarding tables. Or you can use the CLI to, for example, configure static routes, VLAN, vrf’s etc.</p><h3 id="test-setup">Test setup</h3><p>I’ll use mostly the same test setup as in my previous test. Again using two<a href="https://www.packet.com/cloud/servers/n2-xlarge/" rel="noopener"> n2.xlarge.x86</a> servers from<a href="https://www.packet.com/" rel="noopener"> packet.com</a> and our <a href="https://medium.com/@atoonk/building-a-high-performance-linux-based-traffic-generator-with-dpdk-93bb9904416c?source=friends_link&amp;sk=fb002771094f1f79654ec9a8be5761c7">DPDK traffic generator</a>. The set up is as below.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*bPwcK3XnekCTdwU3HVgeeQ.png" class="kg-image" alt="Kernel bypass networking with FD.io and VPP."><figcaption>Test setup</figcaption></figure><p>I’m using the VPP code from the FD.io master branch and installed it on a vanilla Ubuntu 18.04 system <a href="https://fd.io/docs/vpp/master/gettingstarted/installing/ubuntu.html" rel="noopener">following these steps</a>.</p><h3 id="test-results-packet-forwarding-using-vpp">Test results — Packet forwarding using VPP</h3><p>Now that we have our test setup ready to go, it’s time to start our testing!<br>To start, I configured VPP with “vppctl” like this, note that I need to set static ARP entries since the packet generator doesn’t respond to ARP.</p><p>set int ip address TenGigabitEthernet19/0/1 10.10.10.2/24<br>set int ip address TenGigabitEthernet19/0/3 10.10.11.2/24<br>set int state TenGigabitEthernet19/0/1 up<br>set int state TenGigabitEthernet19/0/3 up<br>set ip neighbor TenGigabitEthernet19/0/1 10.10.10.3 e4:43:4b:2e:b1:d1<br>set ip neighbor TenGigabitEthernet19/0/3 10.10.11.3 e4:43:4b:2e:b1:d3</p><p>That’s it! Pretty simple right?</p><p>Ok, time to look at the results just like before we did a single flow test, both unidirectional and bidirectional, as well as a 10,000 flow test.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*SOuQiKUviuPLjlOlAlAP8Q.png" class="kg-image" alt="Kernel bypass networking with FD.io and VPP."><figcaption>VPP forwarding test&nbsp;results</figcaption></figure><p>Those are some remarkable numbers! With a single flow, VPP can process and forward about 8Mpps, not bad. The perhaps more realistic test with 10,000 flows, shows us that it can handle 14Mpps with just two cores. To get to a full bi-directional scenario where both NICs are sending and receiving at line rate (28 Mpps per NIC) we need three cores and three receive queues on the NIC. To achieve this last scenario with Linux, we needed approximately 26 cores. Not bad, not bad at all!</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/2400/1*CnHwc00tX2BSnE5c424zuA.png" class="kg-image" alt="Kernel bypass networking with FD.io and VPP."><figcaption>Traffic generator on the left, VPP server on the right. This shows the full line-rate bidirectional test: 14Mpps per NIC, while VPP uses 3&nbsp;cores.</figcaption></figure><h3 id="test-results-nat-using-vpp">Test results — NAT using VPP</h3><p>In my previous blog we saw that when doing SNAT on Linux with iptables, we got as high as 3Mpps per direction needing about 29 CPUs per direction. This showed us that packet rewriting is significantly more expensive than just forwarding. Let’s take a look at how VPP does nat.</p><p>To enable nat on VPP, I used the following commands:</p><pre><code>nat44 add interface address TenGigabitEthernet19/0/3
nat addr-port-assignment-alg default
set interface nat44 in TenGigabitEthernet19/0/1 out TenGigabitEthernet19/0/3 output-feature</code></pre><p>My first test is with one flow only in one direction. With that, I’m able to get 4.3Mpps. That’s’ exactly half of what we saw in the performance test without nat. It’s no surprise this is slower due to the additional work needed. Note that with Linux iptables I was seeing about 1.1Mpps.</p><p>A single flow for nat isn’t super representative of a real-life nat example where you’d be translating many sources. So for the next measurements, I’m using 255 different source IP addresses and 255 destination IP addresses as well as different port numbers; with this setup, the nat code is seeing about 16k sessions. I can now see the numbers go to 3.2Mpps; more flows mean more nat work. Interestingly, this number is exactly the same as I saw with iptables. There is however one big difference, with iptables the system was using about 29 cores. In this test, I’m only using two cores. That’s a low number of workers, and also the reason I’m capped. To remove that cap, I added more cores and validated that the VPP code scales horizontally. Eventually, I need 12 cores to run 14Mpps for a stable experience.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*Rrh8rnpAB-SMMqdpe5pG5w.png" class="kg-image" alt="Kernel bypass networking with FD.io and VPP."><figcaption>VPP forwarding with NAT test&nbsp;results</figcaption></figure><p>Below is the relevant VPP config to control the number of cores used by VPP. Also, I should note that I <a href="https://www.linuxtopia.org/online_books/linux_kernel/kernel_configuration/re46.html" rel="noopener">isolated the cores</a> I allocated to VPP so that the kernel wouldn’t schedule anything else on it.</p><pre><code>cpu {
    main-core 1
    # CPU placement:
    corelist-workers 3–14
    # Also added this to grub: isolcpus=3-31,34-63
}
dpdk {
   dev default {
      # RSS, number of queues
      num-rx-queues 12
      num-tx-queues 12
      num-rx-desc 2048
      num-tx-desc 2048
   }
   dev 0000:19:00.1
   dev 0000:19:00.3
}
plugins {
   plugin default { enable }
   plugin dpdk_plugin.so { enable }
}
nat {
   endpoint-dependent
   translation hash buckets 1048576
   translation hash memory 268435456
   user hash buckets 1024
   max translations per user 10000
 }</code></pre><h3 id="conclusion">Conclusion</h3><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1200/0*6AoxbyuX5YbpSjeu" class="kg-image" alt="Kernel bypass networking with FD.io and VPP."><figcaption>Photo by <a href="https://unsplash.com/@nci?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@nci?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener" target="_blank">National Cancer Institute</a> on&nbsp;<a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener" target="_blank">Unsplash</a></figcaption></figure><p>In this blog, we looked at VPP from the FD.io project as a userland forwarding engine. VPP is one example of a kernel bypass method for processing packets. It works closely with and further augments DPDK.</p><p>We’ve seen that the VPP code is <a href="https://wiki.fd.io/view/VPP/What_is_VPP%3F#Feature_Rich" rel="noopener">feature-rich</a>, especially for a kernel bypass packet forwarder. Most of all, <strong>it’s crazy fast</strong>.</p><p>We need just three cores to have two NICs forward full line-rate (14Mpps) in both directions. Comparing that to the Linux kernel, which needed 26 cores, we see an almost 9x increase in performance. <br>We noticed that the results were even better when using nat. In Linux, I wasn’t able to get any higher than 3.2Mpps for which I needed about 29 cores. With VPP we can do 3.2Mpps with just two cores and get to full line rate nat with 12 cores.</p><p>I think <a href="https://fd.io/" rel="noopener">FD.io</a> is an interesting and exciting project, and I’m a bit surprised it’s not more widely used. One of the reasons is likely that there’s a bit of a learning curve. But if you need high-performance packet forwarding, it’s certainly something to explore! Perhaps this is the start of your VPP project? if so, <a href="https://twitter.com/atoonk" rel="noopener">let me know!</a></p><p><em>Cheers</em><br><em> -Andree</em></p>]]></content:encoded></item><item><title><![CDATA[Linux Kernel and Measuring network throughput.]]></title><description><![CDATA[can Linux route at line-rate between two network interfaces? That’s the question we will try to answer in the next few minutes.]]></description><link>http://toonk.io/linux-kernel-and-measuring-network-throughput/</link><guid isPermaLink="false">5f53d62b3680d46e73ec60b5</guid><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Sun, 29 Mar 2020 18:21:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1448056975861-28196f26abd6?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1448056975861-28196f26abd6?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Linux Kernel and Measuring network throughput."><p>In <a href="https://medium.com/@atoonk/building-a-high-performance-linux-based-traffic-generator-with-dpdk-93bb9904416c">my last blog</a>, I wrote about how we can use dpdk pktgen for performance testing. Today I spent some time on some baseline testing to see what we can expect out of a vanilla Linux system nowadays when used as a router. Over the last two years I’ve been playing a fair bit with kernel bypass networking and hope to write about it in the near future. The promise of kernel bypass networking is higher performance, to determine how much of performance increase over the Kernel we need to establish a baseline first, we’ll do that in this article.</p><h3 id="test-setup">Test setup</h3><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1200/1*Z2de1wSgOo9UGYqJL5X2Ag.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>n2.large.x86 CPU&nbsp;specs.</figcaption></figure><p>I’m using two <a href="https://www.packet.com/cloud/servers/n2-xlarge/" rel="noopener">n2.xlarge.x86</a> servers from <a href="https://www.packet.com/" rel="noopener">packet.com</a>. With its two Numa nodes, 16cores per socket, 32 cores in total, 64 with hyper-threading, this is a very beefy machine! It also comes with a quad-port Intel x710 NIC, giving us 4 x 10Gbs. Packet allows you to create custom vlans and assign network ports to a vlan. I’ve created two vlans and assigned one NIC to each vlan. The setup looks like below.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*TvT0rHAopTG6cx8v8Ny9TA.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>Test setup</figcaption></figure><p>The Device Under Test (DUT), is a vanilla Ubuntu 19.04 system running a 5.0.0–38-generic kernel. The only minor tune I’ve done is to set the NIC rx ring to 4096. And I enabled ip forwarding ( net.ipv4.ip_forward=1)</p><p>Using the <a href="https://github.com/atoonk/dpdk_pktgen" rel="noopener">traffic generator</a>, I’m sending as many packets possible and observe when packets stop coming back at the same rate, which indicates packet-loss. I record the point that happens as the maximum throughput. I’m also keeping a close eye on the CPU usage, to get a sense of how many CPU cores (hyper threads) are needed to serve the traffic.</p><h3 id="test-1-packet-forwarding-on-linux">Test 1 — packet forwarding on Linux</h3><p>The first test was easy. I’m simply sending packets from 10.10.11.1 to 10.10.12.1 and vice versa, through the DUT (Device under Test), which is routing the packets between the two interfaces eno2 and eno4.<br>Note that that I did both a one directional test (10.10.11.1 &gt; 10.10.12.1) and a bidirectional test (10.10.11.1 &gt; 10.10.12.1 AND 10.10.12.1 &gt; 10.10.11.1). <br>I also tested with just one flow, and with 10,000 flows.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1200/1*moJCGd0xZ8uN0F_dSJrlBg.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>Receive Side Scaling&nbsp;(RSS)</figcaption></figure><p>This is important as the NIC is doing something called<a href="https://medium.com/@anubhavchoudhary/introduction-to-receive-side-scaling-rss-7cd97307d220"> Receive Side Scaling (RSS)</a>, which will load balance different flows on to different NIC receive Queues. Each queue is then served by a different core, meaning the system scales horizontally. But, keep in mind, you may still be limited by what a single core can do depending on your traffic patterns.</p><p>Ok, show me the results! Keep in mind that we’re talking mostly about Packets Per Second (PPS) as that is the major indicator of the performance, it’s not super relevant how much data is caried in each packet. In the world of Linux networking, it really comes down to, how many interrrupts per second the system can process.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*qs0jj0QIJRCsGeY-Laf8QA.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>Test results for test&nbsp;1</figcaption></figure><p>In the results above, you can see that one flow can go as high as 1.4Mpps. At that point, the core serving that queue is maxed out (running 100%), and can not process any more packets and will start dropping. The single flow forwarding performance is good to know for DDOS use-cases or large single flow network streams such as ESP. For services like these, the performance is as good as a single queue / cpu can handle.</p><p>When doing the same test with 10,000 flows, I get to 14 Mpps, full 10g line rate at the smallest possible packet size (64B), yay! At this point I can see all cores doing a fair amount of work. This is expected and is due to the hashing of flows over different queues. Looking at the CPU usage, I estimate that you’d need roughly 16 cores at 100% usage to serve this amount of packets (interrupts).</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/2400/1*orhgjD2BpWHCVxGdutKCPg.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>14M pps, unidirectional test.</figcaption></figure><p>Interestingly, I wasn’t able to get to full line rate when doing the bidirectional test. Meaning both NICs both sending and receiving simultaneously. Although I am getting reasonably close at 12Mpps (24Mpps total per NIC). When eyeballing the cpu usage and amount of idle left over, I’d expect you’d need roughly 26 cores at 100% usage to do that.</p><h3 id="test-2-introducing-a-simple-stateful-iptables-rule">Test 2 - Introducing a simple stateful iptables rule</h3><p>In this test we’re adding two simple iptables rules to the DUT to see what the impact is. The hypothesis here is that since we’re now going to ask the system to invoke conntrack and do stateful session mapping, we’re starting to execute more code, which could impact the performance and system load. This test will show us the impact of that.</p><p>The Iptables rules added were:</p><pre><code>iptables -I FORWARD -d 10.10.11.1 -m conntrack — ctstate RELATED,ESTABLISHED -j ACCEPT
iptables -I FORWARD -d 10.10.12.1 -m conntrack — ctstate RELATED,ESTABLISHED -j ACCEPT</code></pre><p></p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*2bA807FtoZwr2K3YgSot9Q.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>Test results for test 2, impact of conntrack</figcaption></figure><p>The results for the single flow performance test look exactly the same, that’s good. The results for the 10,000 flows test, look the same as well when it comes to packet per second. However, we do need a fair amount of extra CPU’s to do the work. Good thing, our test system has plenty. <br>So you can still achieve (close) to full line rate with a simple stateful iptables rule, as long as you have enough cpu’s. Note that in this case, the state table had 10,000 state entries. I didn’t test with more iptables rules.</p><h3 id="test-3-introducing-a-nat-rule">Test 3 - Introducing a NAT rule</h3><p>In this test, we’re starting from scratch as we did in test 1 and I’m adding a simple nat rule which causes all packets going through the DUT to be rewritten to a new source IP. These are the two rules:</p><pre><code>iptables -I POSTROUTING -t nat -d 10.10.12.1 -s 10.10.11.1 -j SNAT — to 10.10.12.2iptables -I POSTROUTING -t nat -d 10.10.11.1 -s 10.10.12.1 -j SNAT — to 10.10.11.2</code></pre><p>The results below are quite different than what we saw earlier.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*zGL9WLmMNQUSItaf0cSmXA.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>Test results for test&nbsp;3</figcaption></figure><p>The results show that rewriting the packets is quite a bit more expensive than just allowing or dropping a packet. For example, if we look at the unidirectional test with 10,000 flows, we see that we dropped from 14M pps (test 1) to 3.2 Mpps, we also needed 13 cores more to do this!</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*vqQ8Ag_pkW7g19SRCpuhxQ.png" class="kg-image" alt="Linux Kernel and Measuring network throughput."><figcaption>This is what a (unhappy) 64core system looks like when trying to forward and NAT 5.9M&nbsp;pps</figcaption></figure><p>For what it’s worth, i did do a quick measurement with using nftables instead of iptables, but saw no significant changes in NAT performance.</p><h3 id="conclusion">Conclusion</h3><p>One of the questions I had starting this experiment was: <strong>can Linux route at line-rate between two network interfaces?</strong> The answer is yes, we saw 14Mpps (unidirectional), as long as there are sufficient flows, and you have enough cores (~16). The bidirectional test made it to 12Mpps (24Mpps total per NIC) with 26cores at 100%.</p><p>We also saw that with the addition of two stateful Iptables rules, I was still able to get the same throughput, but needed extra CPU to do the work. So at least it scales horizontally.</p><p>Finally, we saw the rather dramatic drop in performance when adding SNAT rules to test. With SNAT the maximum I was able to get out of the system was 5.9Mpps; this was for 20k sessions (10k per direction).</p><p>So yes, you can build a close to line rate router in Linux, as long as you have sufficient cores and don’t do too much packet manipulations. All in all, an interesting test, and now we have a starting benchmark for future (kernel bypass / userland) networking experiments on Linux!</p>]]></content:encoded></item><item><title><![CDATA[Building a high performance - Linux Based Traffic generator with DPDK]]></title><description><![CDATA[<hr><p>Often in my, now 20 years, networking career, I had to do some form of network performance testing. Use-cases varied, from troubleshooting a customer problem to testing new network hardware, and nowadays more and more Virtual network functions and software-based ‘bumps in the wire’.</p><p>I’ve always enjoyed playing with</p>]]></description><link>http://toonk.io/building-a-high-performance-linux-based-traffic-generator-with-dpdk/</link><guid isPermaLink="false">5f53d8003680d46e73ec60d6</guid><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Wed, 18 Mar 2020 18:32:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1489976908522-aabacf277f49?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<hr><img src="https://images.unsplash.com/photo-1489976908522-aabacf277f49?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Building a high performance - Linux Based Traffic generator with DPDK"><p>Often in my, now 20 years, networking career, I had to do some form of network performance testing. Use-cases varied, from troubleshooting a customer problem to testing new network hardware, and nowadays more and more Virtual network functions and software-based ‘bumps in the wire’.</p><p>I’ve always enjoyed playing with hardware-based traffic generators. My first experience with for example an IXIA hardware testing goes back to I think 2003, at the <a href="https://www.ams-ix.net/ams" rel="noopener">Amsterdam Internet Exchange</a> where we were testing brand new Foundry 10G cards. These hardware-based testers were super powerful and a great tool to validate new gear, such as router line cards, firewalls, and IPsec gear. However, we don’t always have access to these hardware-based traffic generators, as they tend to be quite expensive or only available in a lab. In this blog, we will look at a software-based traffic generator that anyone can use - based on DPDK. As you’re going through this remember that the scripts and additional info can be found on <a href="https://github.com/atoonk/dpdk_pktgen/" rel="noopener">my GitHub page here</a>.</p><hr><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1200/1*L3shetNxtIGOhKt-_0xv5A.png" class="kg-image" alt="Building a high performance - Linux Based Traffic generator with DPDK"></figure><p>DPDK, The Data Plane Development Kit, is an Open source software project started by Intel and now managed by the Linux Foundation. It provides a set of data plane libraries and network interface controller polling-mode drivers that are running in userspace. Ok, let’s think about that for a sec, what does that mean? Userspace networking is something you likely increasingly hear and read about. The main driver behind userspace networking (aka Kernel bypass) has to do with the way Linux has built its networking stack; it is built as part of a generic, multi-purpose, multi-user OS. Networking in Linux is powerful and feature-rich, but it’s just one of the many features of Linux, and so; as a result, the networking stack needs to play fair and share its resources with the rest of the kernel and userland programs. The end result is that getting a few (1 to 3) million packets per second through the Linux networking stack is about what you can do on a standard system. That’s not enough to fill up a 10G link at 64 bytes packets, which is the equivalent of 14M packets per second (pps). This is the point where the traditional interrupt-driven (IRQs) way of networking in Linux starts to limit what is needed, and this is where DPDK comes in. With DPDK and userland networking programs, we take away the NIC from the kernel and give it to a userland DPDK program. The DPDK driver is a pull mode driver (PMD), which means that, typically, one core per nic always uses a 100% CPU, it’s in a busy loop always pulling for packets. This means that you will see that core running at 100%, regardless of how many packets are arriving or being sent on that nic. This is obviously a bit of waste, but nowadays, with plenty of cores and the need for high throughput systems, this is often a great trade-off, and best of all, it allows us to get to the 14M pps number on Linux.</p><p>Ok, high performance, we should all move to DPDK then, right?! Well, there’s just one problem… Since we’re now bypassing the kernel, we don’t get to benefit from the rich Linux features such as Netfilter and not even some of what we now think are basic features like a TCP/IP stack. This means you can’t just run your Nginx, Mysql, Bind, etc, socket-based applications with DPDK as all of these rely on the Linux Socket API and the Kernel to work. So although DPDK gives us a lot of speed and performance by bypassing the kernel, you also lose a lot of functionality.</p><p>Now there are quite a few DKDK based applications nowadays, varying from network forwarders such as software-based routers and switches as well as TCP/IP stacks such as F-stack.</p><p>In this blog, we’re going to look at DPDK-pktgen, a DPDK based traffic generator maintained by the DPDK team. I’m going to walk through installing DPDK, setting up SR-IOV, and running pktgen; all of the below was tested on a <a href="https://www.packet.com/" rel="noopener">Packet.com</a> server of type <a href="https://www.packet.com/cloud/servers/x1-small/" rel="noopener">x1.small.x86</a> which has a single Intel X710 10G nic and a 4 core E3–1578L Xeon CPU. I’m using Ubuntu 18.04.4 LTS.</p><h3 id="installing-dpdk-and-pktgen">Installing DPDK and Pktgen</h3><p>First, we need to install the DPKD libraries, tools, and drivers. There are various ways to install DPDK and pktgen; I elected to compile the code from source. There are a few things you need to do; to make it easier, you can download the <a href="https://github.com/atoonk/dpdk_pktgen/blob/master/install-dpdk-pktgen.sh" rel="noopener">same bash script </a>I used to help you with the installation.</p><h3 id="solving-the-single-nic-problem">Solving the single NIC problem</h3><p>One of the challenges with DPDK is that it will take full control of the nic. To use DPDK, you will need to release the nic from the kernel and give it to DPDK. Given we only have one nic, once we give it to DKDK, I’d lose all access (remember there’s no easy way to keep on using SSH, etc., since it relies on the Linux kernel). Typically folks solve this by having a management NIC (for Linux) and one or more NICs for DPDK. But I have only one NIC, so we need to be creative: we’re going to use SR-IOV to achieve the same. SR-IOV allows us to make one NIC appear as multiple PCI slots, so in a way, we’re virtualizing the NIC.</p><p>To use SR-IOV, we need to enable iommu in the kernel (done in the DPDK install script). After that, we can set the number of Virtual Functions (the number of new PCI NIC) like this.</p><pre><code class="language-bash">echo 1 &gt; /sys/class/net/eno1/device/sriov_numvfs
ip link set eno1 vf 0 spoofchk off
ip link set eno1 vf 0 trust on</code></pre><p></p><p>dmesg -t will show something like this:</p><pre><code class="language-bash">[Tue Mar 17 19:44:37 2020] i40e 0000:02:00.0: Allocating 1 VFs.
[Tue Mar 17 19:44:37 2020] iommu: Adding device 0000:03:02.0 to group 1
[Tue Mar 17 19:44:38 2020] iavf 0000:03:02.0: Multiqueue Enabled: Queue pair count = 4
[Tue Mar 17 19:44:38 2020] iavf 0000:03:02.0: MAC address: 1a:b5:ea:3e:28:92
[Tue Mar 17 19:44:38 2020] iavf 0000:03:02.0: GRO is enabled
[Tue Mar 17 19:44:39 2020] iavf 0000:03:02.0 em1_0: renamed from eth0</code></pre><p>We can now see the new PCI device and nic name:</p><pre><code class="language-bash">root@ewr1-x1:~# lshw -businfo -class network | grep 000:03:02.0
pci@0000:03:02.0 em1_0 network Illegal Vendor ID</code></pre><p>Next up we will unbind this NIC from the kernel and give it to DPDK to manage:</p><pre><code class="language-bash">/opt/dpdk-20.02/usertools/dpdk-devbind.py -b igb_uio 0000:03:02.0</code></pre><p>We can validate that like this (note em2 is not connected and not used):</p><pre><code class="language-bash">/opt/dpdk-20.02/usertools/dpdk-devbind.py -s
Network devices using DPDK-compatible driver
============================================
0000:03:02.0 'Ethernet Virtual Function 700 Series 154c' drv=igb_uio unused=iavf,vfio-pci,uio_pci_generic
Network devices using kernel driver
===================================
0000:02:00.0 'Ethernet Controller X710 for 10GbE backplane 1581' if=eno1 drv=i40e unused=igb_uio,vfio-pci,uio_pci_generic
0000:02:00.1 'Ethernet Controller X710 for 10GbE backplane 1581' if=em2 drv=i40e unused=igb_uio,vfio-pci,uio_pci_generic</code></pre><h3 id="testing-setup">Testing setup</h3><p>Now that we’re ready to start testing, I should explain our simple test setup. I’m using two x1-small servers; one is the sender (running dpdk-pktgen), the other is a vanilla Ubuntu machine. What we’re going to test is the ability for the receiver Kernel, sometimes referred to as Device Under Test (DUT), to pick up the packets from the NIC. That’s all; we’re not processing anything, the IP address the packets are sent to isn’t even configured on the DUT, so the kernel will drop the packets asap after picking it up from the NIC.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*4dnNk4hTHqehbtjSq7c5kQ.png" class="kg-image" alt="Building a high performance - Linux Based Traffic generator with DPDK"><figcaption>test setup</figcaption></figure><h3 id="single-flow-traffic">Single flow traffic</h3><p>Ok, time to start testing! Let’s run pktgen and generate some packets! My first experiment is to figure out how much I can send in a single flow to the target machine before it starts dropping packets.</p><p>Note that you can find the exact config in the <a href="https://github.com/atoonk/dpdk_pktgen/" rel="noopener">GitHub repo for this blog</a>. The file <a href="https://github.com/atoonk/dpdk_pktgen/blob/master/pktgen.pkt" rel="noopener">pktgen.pkt</a> contains the commands to configure the test setup. Things that I configured were the mac and IP addresses, ports and protocols, and the sending rate. Note that I’m testing from 10.99.204.3 to 10.99.204.8. These are on /31 networks, so I’m setting the destination mac address to that of the default gateway. With the config as defined in <a href="https://github.com/atoonk/dpdk_pktgen/blob/master/pktgen.pkt" rel="noopener">pktgen.pkt</a> I’m sending the same 64 byte packets (5 tuple, UDP 10.99.204.3:1234 &gt; 10.99.204.8:81 ) over and over.</p><p>I’m using the following to start pktgen.</p><pre><code class="language-bash">/opt/pktgen-20.02.0/app/x86_64-native-linuxapp-gcc/pktgen - -T -P -m "2.[0]" -f pktgen.pkt</code></pre><p>After adjusting the sending rate properties on the sender and monitoring with <a href="https://github.com/atoonk/dpdk_pktgen/blob/master/monitorpkts.sh" rel="noopener"><em>./monitorpkts.sh</em></a> on the receiver, we find that a single flow (single queue, single-core) will run clean on this receiver machine up until about 120k pps. If we up the sending rate higher than that, I’m starting to observe packets being dropped on the receiver. That’s a bit lower than expected, and even though it’s one flow, I can see the CPU that is serving that queue having enough idle time left. There must be something else happening…</p><p>The answer has to do with the receive buffer ring on the receiver network card. It was too small for the higher packet rates. After I increased it from 512 to 4096. I can now receive up to 1.4Mpps before seeing drops, not bad for a single flow!</p><pre><code>ethtool -G eno1 rx 4096</code></pre><h3 id="multi-flow-traffic">Multi flow traffic</h3><p>Pktgen also comes with the ability to configure it for ranges. Examples of ranges include source and destination IP addresses as well as source and destination ports. You can find an example in the <a href="https://github.com/atoonk/dpdk_pktgen/blob/master/pktgen-range.pkt" rel="noopener">pktgen-range.pkt file</a>. For most environments, this is a more typical scenario as your server is likely to serve many different flows from many different IP addresses. In fact, the Linux system relies on the existence of many flows to be able to deal with these higher amounts of traffic. The Linux kernel hashes and load-balances these different flows to the available receive queues on the nic. Each queue is then served by a separate Interrupt thread, allowing the kernel to parallelize the work and leverage the multiple cores on the system.</p><p>Below you’ll find a screenshot from when I was running the test with many flows. The receiver terminals can be seen on the left, the sender on the right. The main thing to notice here is that on the receiving node, all available CPU’s are being used, note the <em>ksoftirqd/X</em> processes. Since we are using a wide range of source and destination ports, we’re getting proper load balancing over all cores. With this, I can now achieve 0% lost packets up to about 6Mpps. To get to 14Mpps, 10g line rate @64Bytes packets, I’d need more CPUs.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*H4YbY1b8viqfjoHNi6NPjA.png" class="kg-image" alt="Building a high performance - Linux Based Traffic generator with DPDK"></figure><h3 id="imix-test">IMIX test</h3><p>Finally, we’ll run a basic IMIX test, using the dpdk-pktgen pcap feature. Internet Mix or IMIX refers to typical Internet traffic. When measuring equipment performance using an IMIX of packets, the performance is assumed to resemble what can be seen in “real-world” conditions.</p><p>The <a href="https://github.com/atoonk/dpdk_pktgen/blob/master/imix.pcap" rel="noopener">imix pcap file</a> contains 100 packets with the sizes and ratio according to the <a href="https://en.wikipedia.org/wiki/Internet_Mix" rel="noopener">IMIX specs</a>.</p><pre><code>tshark -r imix.pcap -V | grep 'Frame Length'| sort | uniq -c|sort -n
9 Frame Length: 1514 bytes (12112 bits)
33 Frame Length: 590 bytes (4720 bits)
58 Frame Length: 60 bytes (480 bits)</code></pre><p>I need to rewrite the source and destination IP and MAC addresses so that they match my current setup, this can be done like this:</p><pre><code>tcprewrite \
 - enet-dmac=44:ec:ce:c1:a8:20 \
 - enet-smac=00:52:44:11:22:33 \
 - pnat=16.0.0.0/8:10.10.0.0/16,48.0.0.0/8:10.99.204.8/32 \
 - infile=imix.pcap \
 - outfile=output.pcap</code></pre><blockquote>For more details also see my notes here : <a href="https://github.com/atoonk/dpdk_pktgen/blob/master/DPDKPktgen.md" rel="noopener">https://github.com/atoonk/dpdk_pktgen/blob/master/DPDKPktgen.md</a></blockquote><p>We then start the packetgen app and give it the pcap</p><pre><code>/opt/pktgen-20.02.0/app/x86_64-native-linuxapp-gcc/pktgen - -T -P -m "2.[0]" -s 0:output.pcap</code></pre><p>I can now see I’m sending and receiving packets at a rate of 3.2M pps at 10Gbs, well below the maximum we saw earlier. This means that the Device Under Test (DUT) is capable of receiving packets at 10Gbs using an IMIX traffic pattern.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*xxb0aQmNeSvhvFfOwTI4nw.png" class="kg-image" alt="Building a high performance - Linux Based Traffic generator with DPDK"><figcaption>Result of IMIX test with a PCAP as the source. Receiver (DUT) on the left, sender window on the&nbsp;right.</figcaption></figure><h3 id="conclusion">Conclusion</h3><p>In this article, we looked at getting DPDK up and running, talked a bit about what DPDK is, and used its pktgen traffic generator application. A typical challenge when using DPDK is that you lose the network interface, meaning that the kernel can no longer use it. In this blog, we solved this using SR-IOV, which allowed us to create a second logical interface for DPDK. Using this interface, I was able to generate 14Mpps without issues.</p><p>On the receiving side of this test traffic, we had another Linux machine (no DPDK), and we tested its ability to receive traffic from the NIC (after which the kernel dropped it straight away). We saw how the packets per second number is limited by the rx-buffer, as well as the ability for the CPU cores to pick up the packets (soft interrupts). We saw a single core was able to do about 1,4Mpps. Once we started leveraging more cores, by creating more flows, we started seeing dropped packets at about 6M pps. If we would have had more CPU’s we’d likely be able to do more than that.</p><p>Also note that throughout this blog, I spoke mostly of packets per second and not much in terms of bits per second. The reason for this is that every new packet on the Linux receiver (DUT) creates an interrupt. As a result, the number of interrupts the system can handle is the most critical indicator of how many bits per second the Linux system can handle.</p><p>All in all, pktgen and dpdk require a bit of work to set up, and there is undoubtedly a bit of a learning curve. I hope the scripts and examples in the GitHub repo will help with your testing and remember: with great power comes great responsibility.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/1600/1*60-YU-v_jMuccCaCqqDw6A.jpeg" class="kg-image" alt="Building a high performance - Linux Based Traffic generator with DPDK"></figure>]]></content:encoded></item><item><title><![CDATA[TCP BBR - Exploring TCP congestion control]]></title><description><![CDATA[<p></p><p>One of the oldest protocols and possibly the most used protocol on the Internet today is TCP. You likely send and receive hundreds of thousands or even over a million TCP packets (eeh segments?) a day. And it just works! Many folks believe TCP development has finished, but that’s</p>]]></description><link>http://toonk.io/tcp-bbr-exploring-tcp-congestion-control/</link><guid isPermaLink="false">5f53dac53680d46e73ec610d</guid><category><![CDATA[networking]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Sat, 15 Feb 2020 00:00:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1534477357488-36c99519f91d?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1534477357488-36c99519f91d?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="TCP BBR - Exploring TCP congestion control"><p></p><p>One of the oldest protocols and possibly the most used protocol on the Internet today is TCP. You likely send and receive hundreds of thousands or even over a million TCP packets (eeh segments?) a day. And it just works! Many folks believe TCP development has finished, but that’s incorrect. In this blog will take a look at a relatively new TCP congestion control algorithm called BBR and take it for a spin.</p><p>Alright, we all know the difference between the two most popular transport protocols used on the Internet today. We have UDP and TCP. UDP is a send and forget protocol. It is stateless and has no congestion control or reliable delivery support. We often see UDP used for DNS and VPNs. TCP is UDP’s sibling and does provide reliable transfer and flow control, as a result, it is quite a bit more complicated.</p><p>People often think the main difference between TCP and UDP is that TCP gives us guaranteed packet delivery. This is one of the most important features of TCP, but TCP also gives us flow control. Flow control is all about fairness, and critical for the Internet to work, without some form of flow control, the Internet would collapse.</p><p>Over the years, different flow control algorithms have been implemented and used in the various TCP stacks. You may have heard of TCP terms such as Reno, Tahoe, Vegas, Cubic, Westwood, and, more recently, BBR. These are all different congestion control algorithms used in TCP. What these algorithms do is determining how fast the sender should send data while adapting to network changes. Without these algorithms, our Internet pipes would soon be filled with data and collapse.</p><h3 id="bbr">BBR</h3><p>Bottleneck Bandwidth and Round-trip propagation time (BBR) is a TCP congestion control algorithm developed at Google in 2016. Up until recently, the Internet has primarily used loss-based congestion control, relying only on indications of lost packets as the signal to slow down the sending rate. This worked decently well, but the networks have changed. We have much more bandwidth than ever before; The Internet is generally more reliable now, and we see new things such as bufferbloat that impact latency. BBR tackles this with a ground-up rewrite of congestion control, and it uses latency, instead of lost packets as a primary factor to determine the sending rate.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*DwjjUQ3f5Kpv6mtJCASpTw.gif" class="kg-image" alt="TCP BBR - Exploring TCP congestion control"><figcaption><a href="https://cloud.google.com/blog/products/gcp/tcp-bbr-congestion-control-comes-to-gcp-your-internet-just-got-faster" data-href="https://cloud.google.com/blog/products/gcp/tcp-bbr-congestion-control-comes-to-gcp-your-internet-just-got-faster" class="markup--anchor markup--figure-anchor" rel="nofollow noopener noopener" target="_blank">Source: https://cloud.google.com/blog/products/gcp/tcp-bbr-congestion-control-comes-to-gcp-your-internet-just-got-faster</a></figcaption></figure><h3 id="why-is-bbr-better">Why is BBR better?</h3><p>There are a lot of details I’ve omitted, and it gets complicated pretty quickly, but the important thing to know is that with BBR, you can get significantly better throughput and reduced latency. The throughput improvements are especially noticeable on long haul paths such as Transatlantic file transfers, especially when there’s minor packet loss. The improved latency is mostly seen on the last mile path, which is often impacted by Bufferbloat <em>(4 seconds ping times, anyone?</em>). Since BBR attempts not to fill the buffers, it tends to be better in avoiding buffer bloat.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1200/0*oAa5qgaXoDWLx7MZ" class="kg-image" alt="TCP BBR - Exploring TCP congestion control"><figcaption>Photo by <a href="https://unsplash.com/@kaziiparkour?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@kaziiparkour?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener" target="_blank">Zakaria Zayane</a> on&nbsp;<a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener" target="_blank">Unsplash</a></figcaption></figure><h4 id="let-s-take-bbr-for-a-spin-">let’s take BBR for a spin!</h4><p>BBR has been in the Linux kernel since version 4.9 and can be enabled with a simple <em>sysctl</em> command. In my tests, I’m using two Ubuntu machines and Iperf3 to generate TCP traffic. The two servers are located in the same data center; I’m using two <a href="https://www.packet.com/" rel="noopener">Packet.com </a>servers type: <a href="https://www.packet.com/cloud/servers/t1-small/" rel="noopener">t1.small</a>, which come with a 2.5Gbps NIC.</p><p>The first test is a quick test to see what we can get from a single TCP flow between the two servers. This shows 2.35Gb/s, which sounds about right, good enough to run our experiments.</p><p><strong>The effect of latency on TCP throughput</strong><br>In my day job, I deal with machines that are distributed over many dozens of locations all around the world, so I’m mostly interested in the performance between machines that have some latency between them. In this test, we are going to introduce 140ms round trip time between the two servers using Linux Traffic Control (tc). This is roughly the equivalent of the latency between San Francisco and Amsterdam. This can be done by adding 70ms per direction on both servers like this:</p><pre><code class="language-bash">tc qdisc replace dev enp0s20f0 root netem latency 70ms</code></pre><p>If we do a quick ping, we can now see the 140ms round trip time</p><pre><code class="language-bash">root@compute-000:~# ping 147.75.69.253
PING 147.75.69.253 (147.75.69.253) 56(84) bytes of data.
64 bytes from 147.75.69.253: icmp_seq=1 ttl=61 time=140 ms
64 bytes from 147.75.69.253: icmp_seq=2 ttl=61 time=140 ms
64 bytes from 147.75.69.253: icmp_seq=3 ttl=61 time=140 ms</code></pre><p>Ok, time for our first tests, I’m going to use Cubic to start, as that is the most common TCP congestion control algorithm used today.</p><pre><code>sysctl -w net.ipv4.tcp_congestion_control=cubic</code></pre><p>A 30 second iperf shows an average transfer speed of 347Mbs. This is the first clue of the effect of latency on TCP throughput. The only thing that changed from our initial test (2.35Gbs) is the introduction of 140ms round trip delay. Let’s now set the congestion control algorithm to bbr and test again.</p><pre><code>sysctl -w net.ipv4.tcp_congestion_control=bbr</code></pre><p>The result is very similar, the 30seconds average now is 340Mbs, slightly lower than with Cubic. So far no real changes.</p><h3 id="the-effect-of-packet-loss-on-throughput">The effect of packet loss on throughput</h3><p>We’re going to repeat the same test as above, but with the addition of a minor amount of packet loss. With the command below, I’m introducing 1,5% packet loss on the server (sender) side only.</p><pre><code>tc qdisc replace dev enp0s20f0 root netem loss 1.5% latency 70ms</code></pre><p>The first test with Cubic shows a <strong>dramatic</strong> drop in throughput; the throughput drops from 347Mb/s to 1.23 Mbs/s. That’s a ~99.5% drop and results in this link basically being unusable for today’s bandwidth needs.</p><p>If we repeat the exact same test with BBR we see a significant improvement over Cubic. With BBR the throughput drops to 153Mbs, which is a 55% drop.</p><p>The tests above show the effect of packet loss and latency on TCP throughput. The impact of just a minor amount (1,5%) of packet loss on a long latency path is dramatic. Using anything other than BBR on these longer paths will cause significant issues when there is even a minor amount of packet loss. Only BBR maintains a decent throughput number at anything more than 1,5% loss.</p><p>The table below shows the complete set of results for the various TCP throughput tests I did using different congestion control algorithms, latency and packet loss parameters.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*BzXd_1HLSAdRSBQNtPQ_Nw.png" class="kg-image" alt="TCP BBR - Exploring TCP congestion control"><figcaption>Throughput Test results with various congestion control algorithms</figcaption></figure><blockquote>Note: the congestion control algorithm used for a TCP session is only locally relevant. So, two TCP speakers can use different congestion control algorithms on each side of the TCP session. In other words: the server (sender), can enable BBR locally; there is no need for the client to be BBR aware or support BBR.</blockquote><h3 id="tcp-socket-statistics">TCP socket statistics</h3><p>As you’re exploring tuning TCP performance, make sure to use <em>socket statistics</em>, or <em>ss,</em> like below. This tool displays a ton of socket information, including the TCP flow control algorithm used, the round trip time per TCP session as well as the calculated bandwidth and actual delivery rate between the two peers.</p><figure class="kg-card kg-image-card"><img src="http://toonk.io/content/images/2020/09/Screen-Shot-2020-09-05-at-11.41.38-AM.png" class="kg-image" alt="TCP BBR - Exploring TCP congestion control" srcset="http://toonk.io/content/images/size/w600/2020/09/Screen-Shot-2020-09-05-at-11.41.38-AM.png 600w, http://toonk.io/content/images/size/w1000/2020/09/Screen-Shot-2020-09-05-at-11.41.38-AM.png 1000w, http://toonk.io/content/images/2020/09/Screen-Shot-2020-09-05-at-11.41.38-AM.png 1364w" sizes="(min-width: 720px) 720px"></figure><h2 id="when-to-use-bbr">When to use BBR</h2><p>Both Cubic and BBR perform well for these longer latency links when there is no packet loss, and BBR really shines under (moderate) packet loss. Why is that important? You could argue why you would want to design for these packet loss situations. For that, let’s think about a situation where you have multiple data centers around the world, and you rely on transit to connect the various data centers (possibly using your own Overlay VPN). You likely have a steady stream of data between the various data centers, think of logs files, ever-changing configuration or preference files, database synchronization, backups, etc. All major Transit providers at times suffer from packet loss due to various reasons. If you have a few dozen of these globally distributed data centers, depending on your Transit providers and the locations of your POPs you can expect packet loss incidents between a set of data centers several times a week. In situations like this BBR will shine and help you maintain your SLO’s.</p><p>I’ve mostly focused on the benefits of BBR for long haul links. But CDNs and various application hosting environments will also see benefits. In fact, Youtube has been using BBR for a while now to speed up their already highly optimized experience. This is mostly due to the fact that BBR ramps up to the optimal sending rate aggressively, causing your video stream to load even faster.</p><h4 id="downsides-of-bbr">Downsides of BBR</h4><p>It sounds great right, just execute this one <em>sysctl</em> command, and you get much better throughput resulting in your users to get a better experience. Why would you not do this? Well, BBR has <a href="https://huitema.wordpress.com/2019/01/12/will-transport-innovation-collapse-the-internet/" rel="noopener">received some criticism </a>due to its tendency to consume all available bandwidth and pushing out other TCP streams that use say Cubic or different congestion algorithms. This is something to be mindful of when testing BBR in your environment. <a href="https://datatracker.ietf.org/meeting/105/materials/slides-105-iccrg-bbr-v2-a-model-based-congestion-control" rel="noopener">BBRv2</a> is supposed to resolve some of these challenges.</p><p>All in all, I was amazed by the results. It looks to me this is certainly worth taking a closer look at. You won’t be the first, in addition to Google, <a href="https://blogs.dropbox.com/tech/2017/09/optimizing-web-servers-for-high-throughput-and-low-latency/" rel="noopener">Dropbox</a> and <a href="https://labs.spotify.com/2018/08/31/smoother-streaming-with-bbr/" rel="noopener">Spotify</a> are two other examples where BBR is being used or experimented with.</p>]]></content:encoded></item><item><title><![CDATA[Building A Smarter AWS Global Accelerator]]></title><description><![CDATA[In this blog post, we’ll take a look at how we could build our own global accelerator.  I’ve been thinking a lot about Global Accelerator and while it provides a powerful data plane, I think it would benefit from a smarter control plane.]]></description><link>http://toonk.io/building-a-smarter-aws-global-accelerator/</link><guid isPermaLink="false">5f53e04f3680d46e73ec613f</guid><category><![CDATA[aws]]></category><category><![CDATA[anycast]]></category><dc:creator><![CDATA[Andree Toonk]]></dc:creator><pubDate>Sun, 01 Dec 2019 00:00:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1553623095-2b4d2819983f?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1553623095-2b4d2819983f?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Building A Smarter AWS Global Accelerator"><p>In my last blog post, we looked at Global Accelerator, a global load balancer provided by AWS. I think Global Accelerator is an excellent tool for folks building global applications in AWS as it will help them directing traffic to the right origin locations or servers. This is great for high volume applications, as well as providing improved availability.</p><p>In this blog post, we’ll take a look at how we could build our own global accelerator by building on other previous blog posts (<a href="https://medium.com/@atoonk/building-a-high-available-anycast-application-in-5-minutes-on-packet-198c82eaabc">building anycast applications on packet</a>). I’ve been thinking a lot about Global Accelerator and while it provides a powerful data plane, I think it would benefit from a smarter control plane. A control plane that provides load balancing with more intelligence, by taking into account the capacity, load and round trip time to each origin. In this blog post, we’ll evaluate and demonstrate what that could look like by implementing a <em>Smarter Global Accelerator </em>ourselves.</p><h3 id="typical-architecture"><strong>Typical Architecture</strong></h3><p>Many applications nowadays are delivered using the architecture below. Clients always hit one of the nearest edge nodes (the blue diamonds). Which edge node depends on the way traffic is directed to the edge node, typically either using DNS based load balancing, or straight anycast, this is what AWS Global Accelerator uses.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1200/1*YI0T8iXatDz57M-7eHDvZw.png" class="kg-image" alt="Building A Smarter AWS Global Accelerator"><figcaption>Typical application delivery architecture</figcaption></figure><p>The edge node then needs to determine what origin server to send the request to (assuming there is no caching or cache misses). This is how your typical CDN works, but also how for example, Google and Facebook deliver their applications. In the case of a simple CDN there could be one or more origin servers. In the case of Facebook, the choice is more which of their ‘core’ or ‘larger’ datacenters to send the request to.</p><p>With AWS Global Accelerator you can configure listeners (the diamond) in a region to send a certain percentage of traffic to an origin group, ‘Endpoint Groups’ in AWS speak. This is a static configuration, which is not ideal. Additionally, if an origin (the green box in the diagram) reaches its capacity, you will need to update the configuration. This is the part we’re going to make smarter.</p><p>In an ideal world, each edge node (the diamond) routes the requests to the closest origin based on the latency between the edge node and the origin. It should also be aware of the total load the origin is under, and how much load the origin can handle. An individual edge node doesn’t know how many other edge nodes there are, and how much each of them is sending each origin. So we need a centralized brain and a feedback loop.</p><h3 id="building-a-closed-loop-system">Building a Closed-loop system</h3><p>To have the system continuously adapt to the changing environment, we need to have access to several operational metrics. We need to know how many requests each edge node (load balancer) is receiving, with that we can infer the total, global, number of incoming requests per second. We also need to know the capacity of each origin since we want to make sure we don’t send more traffic to an origin than it can handle. Finally, we need to know the health and latency between each edge node and each origin. Most of these metrics are dynamic, so we need to continuously publish (or poll) the health information and request per second information.</p><p>Now that we have all the input data, we can feed this into our software. The software essentially a scheduler, solving a constraint-based assignment problem. The output is a list with all edge nodes and a weight assignment per edge node for each origin. A simple example could look like this:</p><pre><code>-Listener 192.0.2.10:443 
 - Edge node Amsterdam:
    - Origin EU DC:  90%
    - Origin US-WEST DC:  0%
    - Origin US-EAST DC:  10%
    - Origin Asia DC:  0%
 - Edge node New York:
    - Origin EU DC: 0%
    - Origin US-WEST DC:  0%
    - Origin US-EAST DC:  100%
    - Origin Asia DC:  0%</code></pre><p>In the above example for listener <em>192.0.2.10:443</em>, the Amsterdam edge node will send 90% of the requests to the EU origin, while the remaining 10% is directed to the next closest DC, US-EAST. This means this the EU datacenter is at capacity and is offloading traffic to the next closest origin.</p><p>The New York edge node is sending all traffic to the EU-EAST datacenter as there is enough capacity at this point and no need to offload traffic.</p><p>Our closed-loop system will re-calculate and publish the results every few seconds so that we can respond to changes quickly.</p><h3 id="let-s-start-building"><strong>Let’s start building</strong></h3><p>I’m going to re-use much of what we’ve built earlier, in this experiment I’m again using <a href="https://medium.com/@atoonk/building-a-high-available-anycast-application-in-5-minutes-on-packet-198c82eaabc">Packet.net and their BGP anycast support</a> to build the edge nodes. Please see this <a href="https://medium.com/@atoonk/building-a-high-available-anycast-application-in-5-minutes-on-packet-198c82eaabc">blog for details</a>. I’m using Linux LVS as a load balancer for this setup. Each edge node is publishing the needed metrics to <a href="https://prometheus.io/" rel="noopener">prometheus</a>, a time-series database, every 15 seconds. With this, we now have a handful of edge nodes, fully anycasted, and access to all needed metrics per edge node in a centralized system.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1200/1*iXsxBwPZsGxrGXEOVtXiCg.png" class="kg-image" alt="Building A Smarter AWS Global Accelerator"><figcaption>Swagger file, built using Flask-RESTPlus</figcaption></figure><p>The other thing that is needed is a centralized source of truth. For this, I wrote a Flask based REST API. This API allows us to create new load balancers, add origins, etc. We can also ask this same API for all load balancers, its origins and the health and operational metrics.</p><p>The next thing we needed is a script that every few seconds talks to the API to retrieve the latest configuration. With that information, each edge node can update the load balancer configuration, such as create new load balancer listeners and update the origin details such as weight per origin. We now have everything in place and can start testing.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/1600/1*PbSBDEjF_1mYGVH4snMhTQ.png" class="kg-image" alt="Building A Smarter AWS Global Accelerator"><figcaption>JSON definition for each load&nbsp;balancer</figcaption></figure><h3 id="observations-and-tuning"><strong>Observations and tuning</strong></h3><p>I started testing by generating many get requests to one Listener that has two origins, one <a href="https://www.digitalocean.com/" rel="noopener">digitalocean</a> VM in the US and one in Europe. Since all testing was performed from one location, it was hitting one edge datacenter, that has two edge nodes. Those edge nodes would send the traffic to the closest origin, which is the US origin. Now imagine this origin server was hitting its maximum capacity and I want to protect it from being overloaded and start sending some traffic to the other origin. To do that I set the maximum load number for the US origin to 200 requests per second (also see JSON above).</p><p>Below you’ll see an interesting visualization of this measurement. At t=0 the total traffic load for both origins is 0, no traffic is coming in at all, which also meant that both origins are well below their max capacity. This means that the US load balancers are configured to send all requests to the US origin as they have the lowest latency and are below the max threshold.</p><p>After we generate the traffic, all requests are sent to the US origin to start. As the metrics start coming in the system detects that the total number of incoming requests is exceeding 200, as a result, the load balancer configuration will be updated to start sending traffic to both origin servers, with the intent to not send more than 200 requests per second to the US origin.</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://cdn-images-1.medium.com/max/2400/1*I_rh2VgUAN2w45QQXnpuzg.png" class="kg-image" alt="Building A Smarter AWS Global Accelerator"></figure><h4 id="speed-vs-accuracy-">Speed vs. accuracy.</h4><p>One of the things we want to prevent is big sudden swings in traffic. To achieve that I built in a dampening factor that limits the load shifting (ie. load balancer configuration) change to 2 percent per origin for each 15-second interval. Note; that if you have two origins, this means a 2% change per origin, so 4% swing per 15 secsond cycle. This means it will take a bit longer for the system to respond to major changes but will give us substantially more stability, meaning less oscillation between origins and will allow for the system to stabilize. In my initial version, I had no dampening and the system never stabilized and showed significant unwanted sudden traffic swings.</p><p>The graph shows an interesting side effect of my testing setup. Since I’m testing from the US west coast and start offloading more and more requests to the EU origin, this means that on average, a single curl will take longer due to the increased round trip time. As a result, the total number of requests goes down. Which is fun, because it means the software needs to adapt constantly. Every time we change the origin weights slightly, the total number or requests changes slightly. This causes some oscillation, but it’s also exactly the oscillation a closed-loop system is designed for, and it works well as long as we have a dampening factor. It also shows that in some instances the total number of inbound requests increases if your website (or any app) is responding faster. Though I’m not sure if that’s representative of a real-world scenario. Still, this was a fun side effect that put a bit of extra stress on the software.</p><h3 id="closing-thoughts">Closing thoughts</h3><blockquote>This project was fun as it allowed me to combine several of my interests. One of them is global traffic engineering, ie. how do we get traffic to where we’d like it to be processed. We also go to re-use the lessons learned and experience gained from a few of the previous blog posts, specifically how to build anycasted applications with Packet and a deep-dive into AWS Global Accelerator. I got to improve my Python skills by building a Restful API in Flask and make sure it was properly documented using the OpenAPI spec.</blockquote><blockquote>Finally, building the actual scheduler was a fun challenge, and it took me a while to figure out how to best solve the assignment problem before I was really happy with the outcome. The result is what could be a Smarter Global Accelerator.</blockquote>]]></content:encoded></item></channel></rss>
